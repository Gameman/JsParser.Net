//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//     ANTLR Version: 3.5.0.2
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

// $ANTLR 3.5.0.2 JavaScript.g 2013-04-16 11:53:56

// The variable 'variable' is assigned but its value is never used.
#pragma warning disable 219
// Unreachable code detected.
#pragma warning disable 162
// Missing XML comment for publicly visible type or member 'Type_or_Member'
#pragma warning disable 1591
// CLS compliance checking will not be performed on 'type' because it is not visible from outside this assembly.
#pragma warning disable 3019

 #pragma warning disable 219, 162 

using System.Collections.Generic;
using Antlr.Runtime;
using Antlr.Runtime.Misc;


using Antlr.Runtime.Tree;
using RewriteRuleITokenStream = Antlr.Runtime.Tree.RewriteRuleTokenStream;

namespace  JsParser.Net 
{
[System.CodeDom.Compiler.GeneratedCode("ANTLR", "3.5.0.2")]
[System.CLSCompliant(false)]
public partial class JavaScriptParser : Antlr.Runtime.Parser
{
	internal static readonly string[] tokenNames = new string[] {
		"<invalid>", "<EOR>", "<DOWN>", "<UP>", "ABSTRACT", "ADD", "ADDASS", "AND", "ANDASS", "ARGS", "ARRAY", "ASSIGN", "BLOCK", "BOOLEAN", "BREAK", "BSLASH", "BYFIELD", "BYINDEX", "BYTE", "BackslashSequence", "CALL", "CASE", "CATCH", "CEXPR", "CHAR", "CLASS", "COLON", "COMMA", "CONST", "CONTINUE", "CR", "CharacterEscapeSequence", "DEBUGGER", "DEC", "DEFAULT", "DELETE", "DIV", "DIVASS", "DO", "DOT", "DOUBLE", "DQUOTE", "DecimalDigit", "DecimalIntegerLiteral", "DecimalLiteral", "ELSE", "ENUM", "EOL", "EQ", "EXPORT", "EXPR", "EXTENDS", "EscapeSequence", "ExponentPart", "FALSE", "FF", "FINAL", "FINALLY", "FLOAT", "FOR", "FORITER", "FORSTEP", "FUNCTION", "GOTO", "GT", "GTE", "HexDigit", "HexEscapeSequence", "HexIntegerLiteral", "IF", "IMPLEMENTS", "IMPORT", "IN", "INC", "INSTANCEOF", "INT", "INTERFACE", "INV", "ITEM", "Identifier", "IdentifierNameASCIIStart", "IdentifierPart", "IdentifierStartASCII", "LABELLED", "LAND", "LBRACE", "LBRACK", "LF", "LONG", "LOR", "LPAREN", "LS", "LT", "LTE", "LineTerminator", "MOD", "MODASS", "MUL", "MULASS", "MultiLineComment", "NAMEDVALUE", "NATIVE", "NBSP", "NEG", "NEQ", "NEW", "NOT", "NSAME", "NULL", "OBJECT", "OR", "ORASS", "OctalDigit", "OctalEscapeSequence", "OctalIntegerLiteral", "PACKAGE", "PAREXPR", "PDEC", "PINC", "POS", "PRIVATE", "PROTECTED", "PS", "PUBLIC", "QUE", "RBRACE", "RBRACK", "RETURN", "RPAREN", "RegularExpressionChar", "RegularExpressionFirstChar", "RegularExpressionLiteral", "SAME", "SEMIC", "SHL", "SHLASS", "SHORT", "SHR", "SHRASS", "SHU", "SHUASS", "SP", "SQUOTE", "STATIC", "SUB", "SUBASS", "SUPER", "SWITCH", "SYNCHRONIZED", "SingleLineComment", "StringLiteral", "TAB", "THIS", "THROW", "THROWS", "TRANSIENT", "TRUE", "TRY", "TYPEOF", "USP", "UnicodeEscapeSequence", "VAR", "VOID", "VOLATILE", "VT", "WHILE", "WITH", "WhiteSpace", "XOR", "XORASS", "ZeroToThree"
	};
	public const int EOF=-1;
	public const int ABSTRACT=4;
	public const int ADD=5;
	public const int ADDASS=6;
	public const int AND=7;
	public const int ANDASS=8;
	public const int ARGS=9;
	public const int ARRAY=10;
	public const int ASSIGN=11;
	public const int BLOCK=12;
	public const int BOOLEAN=13;
	public const int BREAK=14;
	public const int BSLASH=15;
	public const int BYFIELD=16;
	public const int BYINDEX=17;
	public const int BYTE=18;
	public const int BackslashSequence=19;
	public const int CALL=20;
	public const int CASE=21;
	public const int CATCH=22;
	public const int CEXPR=23;
	public const int CHAR=24;
	public const int CLASS=25;
	public const int COLON=26;
	public const int COMMA=27;
	public const int CONST=28;
	public const int CONTINUE=29;
	public const int CR=30;
	public const int CharacterEscapeSequence=31;
	public const int DEBUGGER=32;
	public const int DEC=33;
	public const int DEFAULT=34;
	public const int DELETE=35;
	public const int DIV=36;
	public const int DIVASS=37;
	public const int DO=38;
	public const int DOT=39;
	public const int DOUBLE=40;
	public const int DQUOTE=41;
	public const int DecimalDigit=42;
	public const int DecimalIntegerLiteral=43;
	public const int DecimalLiteral=44;
	public const int ELSE=45;
	public const int ENUM=46;
	public const int EOL=47;
	public const int EQ=48;
	public const int EXPORT=49;
	public const int EXPR=50;
	public const int EXTENDS=51;
	public const int EscapeSequence=52;
	public const int ExponentPart=53;
	public const int FALSE=54;
	public const int FF=55;
	public const int FINAL=56;
	public const int FINALLY=57;
	public const int FLOAT=58;
	public const int FOR=59;
	public const int FORITER=60;
	public const int FORSTEP=61;
	public const int FUNCTION=62;
	public const int GOTO=63;
	public const int GT=64;
	public const int GTE=65;
	public const int HexDigit=66;
	public const int HexEscapeSequence=67;
	public const int HexIntegerLiteral=68;
	public const int IF=69;
	public const int IMPLEMENTS=70;
	public const int IMPORT=71;
	public const int IN=72;
	public const int INC=73;
	public const int INSTANCEOF=74;
	public const int INT=75;
	public const int INTERFACE=76;
	public const int INV=77;
	public const int ITEM=78;
	public const int Identifier=79;
	public const int IdentifierNameASCIIStart=80;
	public const int IdentifierPart=81;
	public const int IdentifierStartASCII=82;
	public const int LABELLED=83;
	public const int LAND=84;
	public const int LBRACE=85;
	public const int LBRACK=86;
	public const int LF=87;
	public const int LONG=88;
	public const int LOR=89;
	public const int LPAREN=90;
	public const int LS=91;
	public const int LT=92;
	public const int LTE=93;
	public const int LineTerminator=94;
	public const int MOD=95;
	public const int MODASS=96;
	public const int MUL=97;
	public const int MULASS=98;
	public const int MultiLineComment=99;
	public const int NAMEDVALUE=100;
	public const int NATIVE=101;
	public const int NBSP=102;
	public const int NEG=103;
	public const int NEQ=104;
	public const int NEW=105;
	public const int NOT=106;
	public const int NSAME=107;
	public const int NULL=108;
	public const int OBJECT=109;
	public const int OR=110;
	public const int ORASS=111;
	public const int OctalDigit=112;
	public const int OctalEscapeSequence=113;
	public const int OctalIntegerLiteral=114;
	public const int PACKAGE=115;
	public const int PAREXPR=116;
	public const int PDEC=117;
	public const int PINC=118;
	public const int POS=119;
	public const int PRIVATE=120;
	public const int PROTECTED=121;
	public const int PS=122;
	public const int PUBLIC=123;
	public const int QUE=124;
	public const int RBRACE=125;
	public const int RBRACK=126;
	public const int RETURN=127;
	public const int RPAREN=128;
	public const int RegularExpressionChar=129;
	public const int RegularExpressionFirstChar=130;
	public const int RegularExpressionLiteral=131;
	public const int SAME=132;
	public const int SEMIC=133;
	public const int SHL=134;
	public const int SHLASS=135;
	public const int SHORT=136;
	public const int SHR=137;
	public const int SHRASS=138;
	public const int SHU=139;
	public const int SHUASS=140;
	public const int SP=141;
	public const int SQUOTE=142;
	public const int STATIC=143;
	public const int SUB=144;
	public const int SUBASS=145;
	public const int SUPER=146;
	public const int SWITCH=147;
	public const int SYNCHRONIZED=148;
	public const int SingleLineComment=149;
	public const int StringLiteral=150;
	public const int TAB=151;
	public const int THIS=152;
	public const int THROW=153;
	public const int THROWS=154;
	public const int TRANSIENT=155;
	public const int TRUE=156;
	public const int TRY=157;
	public const int TYPEOF=158;
	public const int USP=159;
	public const int UnicodeEscapeSequence=160;
	public const int VAR=161;
	public const int VOID=162;
	public const int VOLATILE=163;
	public const int VT=164;
	public const int WHILE=165;
	public const int WITH=166;
	public const int WhiteSpace=167;
	public const int XOR=168;
	public const int XORASS=169;
	public const int ZeroToThree=170;

	public JavaScriptParser(ITokenStream input)
		: this(input, new RecognizerSharedState())
	{
	}
	public JavaScriptParser(ITokenStream input, RecognizerSharedState state)
		: base(input, state)
	{
		ITreeAdaptor treeAdaptor = default(ITreeAdaptor);
		CreateTreeAdaptor(ref treeAdaptor);
		TreeAdaptor = treeAdaptor ?? new CommonTreeAdaptor();
		OnCreated();
	}
	// Implement this function in your helper file to use a custom tree adaptor
	partial void CreateTreeAdaptor(ref ITreeAdaptor adaptor);

	private ITreeAdaptor adaptor;

	public ITreeAdaptor TreeAdaptor
	{
		get
		{
			return adaptor;
		}

		set
		{
			this.adaptor = value;
		}
	}

	public override string[] TokenNames { get { return JavaScriptParser.tokenNames; } }
	public override string GrammarFileName { get { return "JavaScript.g"; } }


	partial void OnCreated();
	partial void EnterRule(string ruleName, int ruleIndex);
	partial void LeaveRule(string ruleName, int ruleIndex);

	#region Rules
	partial void EnterRule_token();
	partial void LeaveRule_token();
	// $ANTLR start "token"
	// JavaScript.g:305:1: token : ( reservedWord | Identifier | punctuator | numericLiteral | StringLiteral );
	[GrammarRule("token")]
	private AstParserRuleReturnScope<object, IToken> token()
	{
		EnterRule_token();
		EnterRule("token", 1);
		TraceIn("token", 1);
		AstParserRuleReturnScope<object, IToken> retval = new AstParserRuleReturnScope<object, IToken>();
		retval.Start = (IToken)input.LT(1);

		object root_0 = default(object);

		IToken Identifier2 = default(IToken);
		IToken StringLiteral5 = default(IToken);
		AstParserRuleReturnScope<object, IToken> reservedWord1 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> punctuator3 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> numericLiteral4 = default(AstParserRuleReturnScope<object, IToken>);

		object Identifier2_tree = default(object);
		object StringLiteral5_tree = default(object);
		try { DebugEnterRule(GrammarFileName, "token");
		DebugLocation(305, 1);
		try
		{
			// JavaScript.g:306:2: ( reservedWord | Identifier | punctuator | numericLiteral | StringLiteral )
			int alt1=5;
			try { DebugEnterDecision(1, false);
			switch (input.LA(1))
			{
			case ABSTRACT:
			case BOOLEAN:
			case BREAK:
			case BYTE:
			case CASE:
			case CATCH:
			case CHAR:
			case CLASS:
			case CONST:
			case CONTINUE:
			case DEBUGGER:
			case DEFAULT:
			case DELETE:
			case DO:
			case DOUBLE:
			case ELSE:
			case ENUM:
			case EXPORT:
			case EXTENDS:
			case FALSE:
			case FINAL:
			case FINALLY:
			case FLOAT:
			case FOR:
			case FUNCTION:
			case GOTO:
			case IF:
			case IMPLEMENTS:
			case IMPORT:
			case IN:
			case INSTANCEOF:
			case INT:
			case INTERFACE:
			case LONG:
			case NATIVE:
			case NEW:
			case NULL:
			case PACKAGE:
			case PRIVATE:
			case PROTECTED:
			case PUBLIC:
			case RETURN:
			case SHORT:
			case STATIC:
			case SUPER:
			case SWITCH:
			case SYNCHRONIZED:
			case THIS:
			case THROW:
			case THROWS:
			case TRANSIENT:
			case TRUE:
			case TRY:
			case TYPEOF:
			case VAR:
			case VOID:
			case VOLATILE:
			case WHILE:
			case WITH:
				{
				alt1 = 1;
				}
				break;
			case Identifier:
				{
				alt1 = 2;
				}
				break;
			case ADD:
			case ADDASS:
			case AND:
			case ANDASS:
			case ASSIGN:
			case COLON:
			case COMMA:
			case DEC:
			case DIV:
			case DIVASS:
			case DOT:
			case EQ:
			case GT:
			case GTE:
			case INC:
			case INV:
			case LAND:
			case LBRACE:
			case LBRACK:
			case LOR:
			case LPAREN:
			case LT:
			case LTE:
			case MOD:
			case MODASS:
			case MUL:
			case MULASS:
			case NEQ:
			case NOT:
			case NSAME:
			case OR:
			case ORASS:
			case QUE:
			case RBRACE:
			case RBRACK:
			case RPAREN:
			case SAME:
			case SEMIC:
			case SHL:
			case SHLASS:
			case SHR:
			case SHRASS:
			case SHU:
			case SHUASS:
			case SUB:
			case SUBASS:
			case XOR:
			case XORASS:
				{
				alt1 = 3;
				}
				break;
			case DecimalLiteral:
			case HexIntegerLiteral:
			case OctalIntegerLiteral:
				{
				alt1 = 4;
				}
				break;
			case StringLiteral:
				{
				alt1 = 5;
				}
				break;
			default:
				{
					NoViableAltException nvae = new NoViableAltException("", 1, 0, input, 1);
					DebugRecognitionException(nvae);
					throw nvae;
				}
			}

			} finally { DebugExitDecision(1); }
			switch (alt1)
			{
			case 1:
				DebugEnterAlt(1);
				// JavaScript.g:306:4: reservedWord
				{
				root_0 = (object)adaptor.Nil();

				DebugLocation(306, 4);
				PushFollow(Follow._reservedWord_in_token1759);
				reservedWord1=reservedWord();
				PopFollow();

				adaptor.AddChild(root_0, reservedWord1.Tree);

				}
				break;
			case 2:
				DebugEnterAlt(2);
				// JavaScript.g:307:4: Identifier
				{
				root_0 = (object)adaptor.Nil();

				DebugLocation(307, 4);
				Identifier2=(IToken)Match(input,Identifier,Follow._Identifier_in_token1764); 
				Identifier2_tree = (object)adaptor.Create(Identifier2);
				adaptor.AddChild(root_0, Identifier2_tree);

				}
				break;
			case 3:
				DebugEnterAlt(3);
				// JavaScript.g:308:4: punctuator
				{
				root_0 = (object)adaptor.Nil();

				DebugLocation(308, 4);
				PushFollow(Follow._punctuator_in_token1769);
				punctuator3=punctuator();
				PopFollow();

				adaptor.AddChild(root_0, punctuator3.Tree);

				}
				break;
			case 4:
				DebugEnterAlt(4);
				// JavaScript.g:309:4: numericLiteral
				{
				root_0 = (object)adaptor.Nil();

				DebugLocation(309, 4);
				PushFollow(Follow._numericLiteral_in_token1774);
				numericLiteral4=numericLiteral();
				PopFollow();

				adaptor.AddChild(root_0, numericLiteral4.Tree);

				}
				break;
			case 5:
				DebugEnterAlt(5);
				// JavaScript.g:310:4: StringLiteral
				{
				root_0 = (object)adaptor.Nil();

				DebugLocation(310, 4);
				StringLiteral5=(IToken)Match(input,StringLiteral,Follow._StringLiteral_in_token1779); 
				StringLiteral5_tree = (object)adaptor.Create(StringLiteral5);
				adaptor.AddChild(root_0, StringLiteral5_tree);

				}
				break;

			}
			retval.Stop = (IToken)input.LT(-1);

			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);

		}
		 
		finally
		{
			TraceOut("token", 1);
			LeaveRule("token", 1);
			LeaveRule_token();
		}
		DebugLocation(311, 1);
		} finally { DebugExitRule(GrammarFileName, "token"); }
		return retval;

	}
	// $ANTLR end "token"

	partial void EnterRule_reservedWord();
	partial void LeaveRule_reservedWord();
	// $ANTLR start "reservedWord"
	// JavaScript.g:315:1: reservedWord : ( keyword | futureReservedWord | NULL | booleanLiteral );
	[GrammarRule("reservedWord")]
	private AstParserRuleReturnScope<object, IToken> reservedWord()
	{
		EnterRule_reservedWord();
		EnterRule("reservedWord", 2);
		TraceIn("reservedWord", 2);
		AstParserRuleReturnScope<object, IToken> retval = new AstParserRuleReturnScope<object, IToken>();
		retval.Start = (IToken)input.LT(1);

		object root_0 = default(object);

		IToken NULL8 = default(IToken);
		AstParserRuleReturnScope<object, IToken> keyword6 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> futureReservedWord7 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> booleanLiteral9 = default(AstParserRuleReturnScope<object, IToken>);

		object NULL8_tree = default(object);
		try { DebugEnterRule(GrammarFileName, "reservedWord");
		DebugLocation(315, 1);
		try
		{
			// JavaScript.g:316:2: ( keyword | futureReservedWord | NULL | booleanLiteral )
			int alt2=4;
			try { DebugEnterDecision(2, false);
			switch (input.LA(1))
			{
			case BREAK:
			case CASE:
			case CATCH:
			case CONTINUE:
			case DEFAULT:
			case DELETE:
			case DO:
			case ELSE:
			case FINALLY:
			case FOR:
			case FUNCTION:
			case IF:
			case IN:
			case INSTANCEOF:
			case NEW:
			case RETURN:
			case SWITCH:
			case THIS:
			case THROW:
			case TRY:
			case TYPEOF:
			case VAR:
			case VOID:
			case WHILE:
			case WITH:
				{
				alt2 = 1;
				}
				break;
			case ABSTRACT:
			case BOOLEAN:
			case BYTE:
			case CHAR:
			case CLASS:
			case CONST:
			case DEBUGGER:
			case DOUBLE:
			case ENUM:
			case EXPORT:
			case EXTENDS:
			case FINAL:
			case FLOAT:
			case GOTO:
			case IMPLEMENTS:
			case IMPORT:
			case INT:
			case INTERFACE:
			case LONG:
			case NATIVE:
			case PACKAGE:
			case PRIVATE:
			case PROTECTED:
			case PUBLIC:
			case SHORT:
			case STATIC:
			case SUPER:
			case SYNCHRONIZED:
			case THROWS:
			case TRANSIENT:
			case VOLATILE:
				{
				alt2 = 2;
				}
				break;
			case NULL:
				{
				alt2 = 3;
				}
				break;
			case FALSE:
			case TRUE:
				{
				alt2 = 4;
				}
				break;
			default:
				{
					NoViableAltException nvae = new NoViableAltException("", 2, 0, input, 1);
					DebugRecognitionException(nvae);
					throw nvae;
				}
			}

			} finally { DebugExitDecision(2); }
			switch (alt2)
			{
			case 1:
				DebugEnterAlt(1);
				// JavaScript.g:316:4: keyword
				{
				root_0 = (object)adaptor.Nil();

				DebugLocation(316, 4);
				PushFollow(Follow._keyword_in_reservedWord1792);
				keyword6=keyword();
				PopFollow();

				adaptor.AddChild(root_0, keyword6.Tree);

				}
				break;
			case 2:
				DebugEnterAlt(2);
				// JavaScript.g:317:4: futureReservedWord
				{
				root_0 = (object)adaptor.Nil();

				DebugLocation(317, 4);
				PushFollow(Follow._futureReservedWord_in_reservedWord1797);
				futureReservedWord7=futureReservedWord();
				PopFollow();

				adaptor.AddChild(root_0, futureReservedWord7.Tree);

				}
				break;
			case 3:
				DebugEnterAlt(3);
				// JavaScript.g:318:4: NULL
				{
				root_0 = (object)adaptor.Nil();

				DebugLocation(318, 4);
				NULL8=(IToken)Match(input,NULL,Follow._NULL_in_reservedWord1802); 
				NULL8_tree = (object)adaptor.Create(NULL8);
				adaptor.AddChild(root_0, NULL8_tree);

				}
				break;
			case 4:
				DebugEnterAlt(4);
				// JavaScript.g:319:4: booleanLiteral
				{
				root_0 = (object)adaptor.Nil();

				DebugLocation(319, 4);
				PushFollow(Follow._booleanLiteral_in_reservedWord1807);
				booleanLiteral9=booleanLiteral();
				PopFollow();

				adaptor.AddChild(root_0, booleanLiteral9.Tree);

				}
				break;

			}
			retval.Stop = (IToken)input.LT(-1);

			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);

		}
		 
		finally
		{
			TraceOut("reservedWord", 2);
			LeaveRule("reservedWord", 2);
			LeaveRule_reservedWord();
		}
		DebugLocation(320, 1);
		} finally { DebugExitRule(GrammarFileName, "reservedWord"); }
		return retval;

	}
	// $ANTLR end "reservedWord"

	partial void EnterRule_keyword();
	partial void LeaveRule_keyword();
	// $ANTLR start "keyword"
	// JavaScript.g:326:1: keyword : ( BREAK | CASE | CATCH | CONTINUE | DEFAULT | DELETE | DO | ELSE | FINALLY | FOR | FUNCTION | IF | IN | INSTANCEOF | NEW | RETURN | SWITCH | THIS | THROW | TRY | TYPEOF | VAR | VOID | WHILE | WITH );
	[GrammarRule("keyword")]
	private AstParserRuleReturnScope<object, IToken> keyword()
	{
		EnterRule_keyword();
		EnterRule("keyword", 3);
		TraceIn("keyword", 3);
		AstParserRuleReturnScope<object, IToken> retval = new AstParserRuleReturnScope<object, IToken>();
		retval.Start = (IToken)input.LT(1);

		object root_0 = default(object);

		IToken set10 = default(IToken);

		object set10_tree = default(object);
		try { DebugEnterRule(GrammarFileName, "keyword");
		DebugLocation(326, 1);
		try
		{
			// JavaScript.g:327:2: ( BREAK | CASE | CATCH | CONTINUE | DEFAULT | DELETE | DO | ELSE | FINALLY | FOR | FUNCTION | IF | IN | INSTANCEOF | NEW | RETURN | SWITCH | THIS | THROW | TRY | TYPEOF | VAR | VOID | WHILE | WITH )
			DebugEnterAlt(1);
			// JavaScript.g:
			{
			root_0 = (object)adaptor.Nil();

			DebugLocation(327, 2);

			set10=(IToken)input.LT(1);
			if (input.LA(1)==BREAK||(input.LA(1)>=CASE && input.LA(1)<=CATCH)||input.LA(1)==CONTINUE||(input.LA(1)>=DEFAULT && input.LA(1)<=DELETE)||input.LA(1)==DO||input.LA(1)==ELSE||input.LA(1)==FINALLY||input.LA(1)==FOR||input.LA(1)==FUNCTION||input.LA(1)==IF||input.LA(1)==IN||input.LA(1)==INSTANCEOF||input.LA(1)==NEW||input.LA(1)==RETURN||input.LA(1)==SWITCH||(input.LA(1)>=THIS && input.LA(1)<=THROW)||(input.LA(1)>=TRY && input.LA(1)<=TYPEOF)||(input.LA(1)>=VAR && input.LA(1)<=VOID)||(input.LA(1)>=WHILE && input.LA(1)<=WITH))
			{
				input.Consume();
				adaptor.AddChild(root_0, (object)adaptor.Create(set10));
				state.errorRecovery=false;
			}
			else
			{
				MismatchedSetException mse = new MismatchedSetException(null,input);
				DebugRecognitionException(mse);
				throw mse;
			}


			}

			retval.Stop = (IToken)input.LT(-1);

			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);

		}
		 
		finally
		{
			TraceOut("keyword", 3);
			LeaveRule("keyword", 3);
			LeaveRule_keyword();
		}
		DebugLocation(352, 1);
		} finally { DebugExitRule(GrammarFileName, "keyword"); }
		return retval;

	}
	// $ANTLR end "keyword"

	partial void EnterRule_futureReservedWord();
	partial void LeaveRule_futureReservedWord();
	// $ANTLR start "futureReservedWord"
	// JavaScript.g:358:1: futureReservedWord : ( ABSTRACT | BOOLEAN | BYTE | CHAR | CLASS | CONST | DEBUGGER | DOUBLE | ENUM | EXPORT | EXTENDS | FINAL | FLOAT | GOTO | IMPLEMENTS | IMPORT | INT | INTERFACE | LONG | NATIVE | PACKAGE | PRIVATE | PROTECTED | PUBLIC | SHORT | STATIC | SUPER | SYNCHRONIZED | THROWS | TRANSIENT | VOLATILE );
	[GrammarRule("futureReservedWord")]
	private AstParserRuleReturnScope<object, IToken> futureReservedWord()
	{
		EnterRule_futureReservedWord();
		EnterRule("futureReservedWord", 4);
		TraceIn("futureReservedWord", 4);
		AstParserRuleReturnScope<object, IToken> retval = new AstParserRuleReturnScope<object, IToken>();
		retval.Start = (IToken)input.LT(1);

		object root_0 = default(object);

		IToken set11 = default(IToken);

		object set11_tree = default(object);
		try { DebugEnterRule(GrammarFileName, "futureReservedWord");
		DebugLocation(358, 1);
		try
		{
			// JavaScript.g:359:2: ( ABSTRACT | BOOLEAN | BYTE | CHAR | CLASS | CONST | DEBUGGER | DOUBLE | ENUM | EXPORT | EXTENDS | FINAL | FLOAT | GOTO | IMPLEMENTS | IMPORT | INT | INTERFACE | LONG | NATIVE | PACKAGE | PRIVATE | PROTECTED | PUBLIC | SHORT | STATIC | SUPER | SYNCHRONIZED | THROWS | TRANSIENT | VOLATILE )
			DebugEnterAlt(1);
			// JavaScript.g:
			{
			root_0 = (object)adaptor.Nil();

			DebugLocation(359, 2);

			set11=(IToken)input.LT(1);
			if (input.LA(1)==ABSTRACT||input.LA(1)==BOOLEAN||input.LA(1)==BYTE||(input.LA(1)>=CHAR && input.LA(1)<=CLASS)||input.LA(1)==CONST||input.LA(1)==DEBUGGER||input.LA(1)==DOUBLE||input.LA(1)==ENUM||input.LA(1)==EXPORT||input.LA(1)==EXTENDS||input.LA(1)==FINAL||input.LA(1)==FLOAT||input.LA(1)==GOTO||(input.LA(1)>=IMPLEMENTS && input.LA(1)<=IMPORT)||(input.LA(1)>=INT && input.LA(1)<=INTERFACE)||input.LA(1)==LONG||input.LA(1)==NATIVE||input.LA(1)==PACKAGE||(input.LA(1)>=PRIVATE && input.LA(1)<=PROTECTED)||input.LA(1)==PUBLIC||input.LA(1)==SHORT||input.LA(1)==STATIC||input.LA(1)==SUPER||input.LA(1)==SYNCHRONIZED||(input.LA(1)>=THROWS && input.LA(1)<=TRANSIENT)||input.LA(1)==VOLATILE)
			{
				input.Consume();
				adaptor.AddChild(root_0, (object)adaptor.Create(set11));
				state.errorRecovery=false;
			}
			else
			{
				MismatchedSetException mse = new MismatchedSetException(null,input);
				DebugRecognitionException(mse);
				throw mse;
			}


			}

			retval.Stop = (IToken)input.LT(-1);

			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);

		}
		 
		finally
		{
			TraceOut("futureReservedWord", 4);
			LeaveRule("futureReservedWord", 4);
			LeaveRule_futureReservedWord();
		}
		DebugLocation(390, 1);
		} finally { DebugExitRule(GrammarFileName, "futureReservedWord"); }
		return retval;

	}
	// $ANTLR end "futureReservedWord"

	partial void EnterRule_punctuator();
	partial void LeaveRule_punctuator();
	// $ANTLR start "punctuator"
	// JavaScript.g:436:1: punctuator : ( LBRACE | RBRACE | LPAREN | RPAREN | LBRACK | RBRACK | DOT | SEMIC | COMMA | LT | GT | LTE | GTE | EQ | NEQ | SAME | NSAME | ADD | SUB | MUL | MOD | INC | DEC | SHL | SHR | SHU | AND | OR | XOR | NOT | INV | LAND | LOR | QUE | COLON | ASSIGN | ADDASS | SUBASS | MULASS | MODASS | SHLASS | SHRASS | SHUASS | ANDASS | ORASS | XORASS | DIV | DIVASS );
	[GrammarRule("punctuator")]
	private AstParserRuleReturnScope<object, IToken> punctuator()
	{
		EnterRule_punctuator();
		EnterRule("punctuator", 5);
		TraceIn("punctuator", 5);
		AstParserRuleReturnScope<object, IToken> retval = new AstParserRuleReturnScope<object, IToken>();
		retval.Start = (IToken)input.LT(1);

		object root_0 = default(object);

		IToken set12 = default(IToken);

		object set12_tree = default(object);
		try { DebugEnterRule(GrammarFileName, "punctuator");
		DebugLocation(436, 1);
		try
		{
			// JavaScript.g:437:2: ( LBRACE | RBRACE | LPAREN | RPAREN | LBRACK | RBRACK | DOT | SEMIC | COMMA | LT | GT | LTE | GTE | EQ | NEQ | SAME | NSAME | ADD | SUB | MUL | MOD | INC | DEC | SHL | SHR | SHU | AND | OR | XOR | NOT | INV | LAND | LOR | QUE | COLON | ASSIGN | ADDASS | SUBASS | MULASS | MODASS | SHLASS | SHRASS | SHUASS | ANDASS | ORASS | XORASS | DIV | DIVASS )
			DebugEnterAlt(1);
			// JavaScript.g:
			{
			root_0 = (object)adaptor.Nil();

			DebugLocation(437, 2);

			set12=(IToken)input.LT(1);
			if ((input.LA(1)>=ADD && input.LA(1)<=ANDASS)||input.LA(1)==ASSIGN||(input.LA(1)>=COLON && input.LA(1)<=COMMA)||input.LA(1)==DEC||(input.LA(1)>=DIV && input.LA(1)<=DIVASS)||input.LA(1)==DOT||input.LA(1)==EQ||(input.LA(1)>=GT && input.LA(1)<=GTE)||input.LA(1)==INC||input.LA(1)==INV||(input.LA(1)>=LAND && input.LA(1)<=LBRACK)||(input.LA(1)>=LOR && input.LA(1)<=LPAREN)||(input.LA(1)>=LT && input.LA(1)<=LTE)||(input.LA(1)>=MOD && input.LA(1)<=MULASS)||input.LA(1)==NEQ||(input.LA(1)>=NOT && input.LA(1)<=NSAME)||(input.LA(1)>=OR && input.LA(1)<=ORASS)||(input.LA(1)>=QUE && input.LA(1)<=RBRACK)||input.LA(1)==RPAREN||(input.LA(1)>=SAME && input.LA(1)<=SHLASS)||(input.LA(1)>=SHR && input.LA(1)<=SHUASS)||(input.LA(1)>=SUB && input.LA(1)<=SUBASS)||(input.LA(1)>=XOR && input.LA(1)<=XORASS))
			{
				input.Consume();
				adaptor.AddChild(root_0, (object)adaptor.Create(set12));
				state.errorRecovery=false;
			}
			else
			{
				MismatchedSetException mse = new MismatchedSetException(null,input);
				DebugRecognitionException(mse);
				throw mse;
			}


			}

			retval.Stop = (IToken)input.LT(-1);

			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);

		}
		 
		finally
		{
			TraceOut("punctuator", 5);
			LeaveRule("punctuator", 5);
			LeaveRule_punctuator();
		}
		DebugLocation(485, 1);
		} finally { DebugExitRule(GrammarFileName, "punctuator"); }
		return retval;

	}
	// $ANTLR end "punctuator"

	partial void EnterRule_literal();
	partial void LeaveRule_literal();
	// $ANTLR start "literal"
	// JavaScript.g:491:1: literal : ( NULL | booleanLiteral | numericLiteral | StringLiteral | RegularExpressionLiteral );
	[GrammarRule("literal")]
	private AstParserRuleReturnScope<object, IToken> literal()
	{
		EnterRule_literal();
		EnterRule("literal", 6);
		TraceIn("literal", 6);
		AstParserRuleReturnScope<object, IToken> retval = new AstParserRuleReturnScope<object, IToken>();
		retval.Start = (IToken)input.LT(1);

		object root_0 = default(object);

		IToken NULL13 = default(IToken);
		IToken StringLiteral16 = default(IToken);
		IToken RegularExpressionLiteral17 = default(IToken);
		AstParserRuleReturnScope<object, IToken> booleanLiteral14 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> numericLiteral15 = default(AstParserRuleReturnScope<object, IToken>);

		object NULL13_tree = default(object);
		object StringLiteral16_tree = default(object);
		object RegularExpressionLiteral17_tree = default(object);
		try { DebugEnterRule(GrammarFileName, "literal");
		DebugLocation(491, 1);
		try
		{
			// JavaScript.g:492:2: ( NULL | booleanLiteral | numericLiteral | StringLiteral | RegularExpressionLiteral )
			int alt3=5;
			try { DebugEnterDecision(3, false);
			switch (input.LA(1))
			{
			case NULL:
				{
				alt3 = 1;
				}
				break;
			case FALSE:
			case TRUE:
				{
				alt3 = 2;
				}
				break;
			case DecimalLiteral:
			case HexIntegerLiteral:
			case OctalIntegerLiteral:
				{
				alt3 = 3;
				}
				break;
			case StringLiteral:
				{
				alt3 = 4;
				}
				break;
			case RegularExpressionLiteral:
				{
				alt3 = 5;
				}
				break;
			default:
				{
					NoViableAltException nvae = new NoViableAltException("", 3, 0, input, 1);
					DebugRecognitionException(nvae);
					throw nvae;
				}
			}

			} finally { DebugExitDecision(3); }
			switch (alt3)
			{
			case 1:
				DebugEnterAlt(1);
				// JavaScript.g:492:4: NULL
				{
				root_0 = (object)adaptor.Nil();

				DebugLocation(492, 4);
				NULL13=(IToken)Match(input,NULL,Follow._NULL_in_literal2488); 
				NULL13_tree = (object)adaptor.Create(NULL13);
				adaptor.AddChild(root_0, NULL13_tree);

				}
				break;
			case 2:
				DebugEnterAlt(2);
				// JavaScript.g:493:4: booleanLiteral
				{
				root_0 = (object)adaptor.Nil();

				DebugLocation(493, 4);
				PushFollow(Follow._booleanLiteral_in_literal2493);
				booleanLiteral14=booleanLiteral();
				PopFollow();

				adaptor.AddChild(root_0, booleanLiteral14.Tree);

				}
				break;
			case 3:
				DebugEnterAlt(3);
				// JavaScript.g:494:4: numericLiteral
				{
				root_0 = (object)adaptor.Nil();

				DebugLocation(494, 4);
				PushFollow(Follow._numericLiteral_in_literal2498);
				numericLiteral15=numericLiteral();
				PopFollow();

				adaptor.AddChild(root_0, numericLiteral15.Tree);

				}
				break;
			case 4:
				DebugEnterAlt(4);
				// JavaScript.g:495:4: StringLiteral
				{
				root_0 = (object)adaptor.Nil();

				DebugLocation(495, 4);
				StringLiteral16=(IToken)Match(input,StringLiteral,Follow._StringLiteral_in_literal2503); 
				StringLiteral16_tree = (object)adaptor.Create(StringLiteral16);
				adaptor.AddChild(root_0, StringLiteral16_tree);

				}
				break;
			case 5:
				DebugEnterAlt(5);
				// JavaScript.g:496:4: RegularExpressionLiteral
				{
				root_0 = (object)adaptor.Nil();

				DebugLocation(496, 4);
				RegularExpressionLiteral17=(IToken)Match(input,RegularExpressionLiteral,Follow._RegularExpressionLiteral_in_literal2508); 
				RegularExpressionLiteral17_tree = (object)adaptor.Create(RegularExpressionLiteral17);
				adaptor.AddChild(root_0, RegularExpressionLiteral17_tree);

				}
				break;

			}
			retval.Stop = (IToken)input.LT(-1);

			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);

		}
		 
		finally
		{
			TraceOut("literal", 6);
			LeaveRule("literal", 6);
			LeaveRule_literal();
		}
		DebugLocation(497, 1);
		} finally { DebugExitRule(GrammarFileName, "literal"); }
		return retval;

	}
	// $ANTLR end "literal"

	partial void EnterRule_booleanLiteral();
	partial void LeaveRule_booleanLiteral();
	// $ANTLR start "booleanLiteral"
	// JavaScript.g:499:1: booleanLiteral : ( TRUE | FALSE );
	[GrammarRule("booleanLiteral")]
	private AstParserRuleReturnScope<object, IToken> booleanLiteral()
	{
		EnterRule_booleanLiteral();
		EnterRule("booleanLiteral", 7);
		TraceIn("booleanLiteral", 7);
		AstParserRuleReturnScope<object, IToken> retval = new AstParserRuleReturnScope<object, IToken>();
		retval.Start = (IToken)input.LT(1);

		object root_0 = default(object);

		IToken set18 = default(IToken);

		object set18_tree = default(object);
		try { DebugEnterRule(GrammarFileName, "booleanLiteral");
		DebugLocation(499, 1);
		try
		{
			// JavaScript.g:500:2: ( TRUE | FALSE )
			DebugEnterAlt(1);
			// JavaScript.g:
			{
			root_0 = (object)adaptor.Nil();

			DebugLocation(500, 2);

			set18=(IToken)input.LT(1);
			if (input.LA(1)==FALSE||input.LA(1)==TRUE)
			{
				input.Consume();
				adaptor.AddChild(root_0, (object)adaptor.Create(set18));
				state.errorRecovery=false;
			}
			else
			{
				MismatchedSetException mse = new MismatchedSetException(null,input);
				DebugRecognitionException(mse);
				throw mse;
			}


			}

			retval.Stop = (IToken)input.LT(-1);

			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);

		}
		 
		finally
		{
			TraceOut("booleanLiteral", 7);
			LeaveRule("booleanLiteral", 7);
			LeaveRule_booleanLiteral();
		}
		DebugLocation(502, 1);
		} finally { DebugExitRule(GrammarFileName, "booleanLiteral"); }
		return retval;

	}
	// $ANTLR end "booleanLiteral"

	partial void EnterRule_numericLiteral();
	partial void LeaveRule_numericLiteral();
	// $ANTLR start "numericLiteral"
	// JavaScript.g:546:1: numericLiteral : ( DecimalLiteral | OctalIntegerLiteral | HexIntegerLiteral );
	[GrammarRule("numericLiteral")]
	private AstParserRuleReturnScope<object, IToken> numericLiteral()
	{
		EnterRule_numericLiteral();
		EnterRule("numericLiteral", 8);
		TraceIn("numericLiteral", 8);
		AstParserRuleReturnScope<object, IToken> retval = new AstParserRuleReturnScope<object, IToken>();
		retval.Start = (IToken)input.LT(1);

		object root_0 = default(object);

		IToken set19 = default(IToken);

		object set19_tree = default(object);
		try { DebugEnterRule(GrammarFileName, "numericLiteral");
		DebugLocation(546, 1);
		try
		{
			// JavaScript.g:547:2: ( DecimalLiteral | OctalIntegerLiteral | HexIntegerLiteral )
			DebugEnterAlt(1);
			// JavaScript.g:
			{
			root_0 = (object)adaptor.Nil();

			DebugLocation(547, 2);

			set19=(IToken)input.LT(1);
			if (input.LA(1)==DecimalLiteral||input.LA(1)==HexIntegerLiteral||input.LA(1)==OctalIntegerLiteral)
			{
				input.Consume();
				adaptor.AddChild(root_0, (object)adaptor.Create(set19));
				state.errorRecovery=false;
			}
			else
			{
				MismatchedSetException mse = new MismatchedSetException(null,input);
				DebugRecognitionException(mse);
				throw mse;
			}


			}

			retval.Stop = (IToken)input.LT(-1);

			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);

		}
		 
		finally
		{
			TraceOut("numericLiteral", 8);
			LeaveRule("numericLiteral", 8);
			LeaveRule_numericLiteral();
		}
		DebugLocation(550, 1);
		} finally { DebugExitRule(GrammarFileName, "numericLiteral"); }
		return retval;

	}
	// $ANTLR end "numericLiteral"

	partial void EnterRule_primaryExpression();
	partial void LeaveRule_primaryExpression();
	// $ANTLR start "primaryExpression"
	// JavaScript.g:634:1: primaryExpression : ( THIS | Identifier | literal | arrayLiteral | objectLiteral |lpar= LPAREN expression RPAREN -> ^( PAREXPR[$lpar, \"PAREXPR\"] expression ) );
	[GrammarRule("primaryExpression")]
	private AstParserRuleReturnScope<object, IToken> primaryExpression()
	{
		EnterRule_primaryExpression();
		EnterRule("primaryExpression", 9);
		TraceIn("primaryExpression", 9);
		AstParserRuleReturnScope<object, IToken> retval = new AstParserRuleReturnScope<object, IToken>();
		retval.Start = (IToken)input.LT(1);

		object root_0 = default(object);

		IToken lpar = default(IToken);
		IToken THIS20 = default(IToken);
		IToken Identifier21 = default(IToken);
		IToken RPAREN26 = default(IToken);
		AstParserRuleReturnScope<object, IToken> literal22 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> arrayLiteral23 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> objectLiteral24 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> expression25 = default(AstParserRuleReturnScope<object, IToken>);

		object lpar_tree = default(object);
		object THIS20_tree = default(object);
		object Identifier21_tree = default(object);
		object RPAREN26_tree = default(object);
		RewriteRuleITokenStream stream_LPAREN=new RewriteRuleITokenStream(adaptor,"token LPAREN");
		RewriteRuleITokenStream stream_RPAREN=new RewriteRuleITokenStream(adaptor,"token RPAREN");
		RewriteRuleSubtreeStream stream_expression=new RewriteRuleSubtreeStream(adaptor,"rule expression");
		try { DebugEnterRule(GrammarFileName, "primaryExpression");
		DebugLocation(634, 1);
		try
		{
			// JavaScript.g:635:2: ( THIS | Identifier | literal | arrayLiteral | objectLiteral |lpar= LPAREN expression RPAREN -> ^( PAREXPR[$lpar, \"PAREXPR\"] expression ) )
			int alt4=6;
			try { DebugEnterDecision(4, false);
			switch (input.LA(1))
			{
			case THIS:
				{
				alt4 = 1;
				}
				break;
			case Identifier:
				{
				alt4 = 2;
				}
				break;
			case DecimalLiteral:
			case FALSE:
			case HexIntegerLiteral:
			case NULL:
			case OctalIntegerLiteral:
			case RegularExpressionLiteral:
			case StringLiteral:
			case TRUE:
				{
				alt4 = 3;
				}
				break;
			case LBRACK:
				{
				alt4 = 4;
				}
				break;
			case LBRACE:
				{
				alt4 = 5;
				}
				break;
			case LPAREN:
				{
				alt4 = 6;
				}
				break;
			default:
				{
					NoViableAltException nvae = new NoViableAltException("", 4, 0, input, 1);
					DebugRecognitionException(nvae);
					throw nvae;
				}
			}

			} finally { DebugExitDecision(4); }
			switch (alt4)
			{
			case 1:
				DebugEnterAlt(1);
				// JavaScript.g:635:4: THIS
				{
				root_0 = (object)adaptor.Nil();

				DebugLocation(635, 4);
				THIS20=(IToken)Match(input,THIS,Follow._THIS_in_primaryExpression3121); 
				THIS20_tree = (object)adaptor.Create(THIS20);
				adaptor.AddChild(root_0, THIS20_tree);

				}
				break;
			case 2:
				DebugEnterAlt(2);
				// JavaScript.g:636:4: Identifier
				{
				root_0 = (object)adaptor.Nil();

				DebugLocation(636, 4);
				Identifier21=(IToken)Match(input,Identifier,Follow._Identifier_in_primaryExpression3126); 
				Identifier21_tree = (object)adaptor.Create(Identifier21);
				adaptor.AddChild(root_0, Identifier21_tree);

				}
				break;
			case 3:
				DebugEnterAlt(3);
				// JavaScript.g:637:4: literal
				{
				root_0 = (object)adaptor.Nil();

				DebugLocation(637, 4);
				PushFollow(Follow._literal_in_primaryExpression3131);
				literal22=literal();
				PopFollow();

				adaptor.AddChild(root_0, literal22.Tree);

				}
				break;
			case 4:
				DebugEnterAlt(4);
				// JavaScript.g:638:4: arrayLiteral
				{
				root_0 = (object)adaptor.Nil();

				DebugLocation(638, 4);
				PushFollow(Follow._arrayLiteral_in_primaryExpression3136);
				arrayLiteral23=arrayLiteral();
				PopFollow();

				adaptor.AddChild(root_0, arrayLiteral23.Tree);

				}
				break;
			case 5:
				DebugEnterAlt(5);
				// JavaScript.g:639:4: objectLiteral
				{
				root_0 = (object)adaptor.Nil();

				DebugLocation(639, 4);
				PushFollow(Follow._objectLiteral_in_primaryExpression3141);
				objectLiteral24=objectLiteral();
				PopFollow();

				adaptor.AddChild(root_0, objectLiteral24.Tree);

				}
				break;
			case 6:
				DebugEnterAlt(6);
				// JavaScript.g:640:4: lpar= LPAREN expression RPAREN
				{
				DebugLocation(640, 8);
				lpar=(IToken)Match(input,LPAREN,Follow._LPAREN_in_primaryExpression3148);  
				stream_LPAREN.Add(lpar);

				DebugLocation(640, 16);
				PushFollow(Follow._expression_in_primaryExpression3150);
				expression25=expression();
				PopFollow();

				stream_expression.Add(expression25.Tree);
				DebugLocation(640, 27);
				RPAREN26=(IToken)Match(input,RPAREN,Follow._RPAREN_in_primaryExpression3152);  
				stream_RPAREN.Add(RPAREN26);



				{
				// AST REWRITE
				// elements: expression
				// token labels: 
				// rule labels: retval
				// token list labels: 
				// rule list labels: 
				// wildcard labels: 
				retval.Tree = root_0;
				RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

				root_0 = (object)adaptor.Nil();
				// 640:34: -> ^( PAREXPR[$lpar, \"PAREXPR\"] expression )
				{
					DebugLocation(640, 37);
					// JavaScript.g:640:37: ^( PAREXPR[$lpar, \"PAREXPR\"] expression )
					{
					object root_1 = (object)adaptor.Nil();
					DebugLocation(640, 40);
					root_1 = (object)adaptor.BecomeRoot((object)adaptor.Create(PAREXPR, lpar, "PAREXPR"), root_1);

					DebugLocation(640, 66);
					adaptor.AddChild(root_1, stream_expression.NextTree());

					adaptor.AddChild(root_0, root_1);
					}

				}

				retval.Tree = root_0;
				}

				}
				break;

			}
			retval.Stop = (IToken)input.LT(-1);

			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);

		}
		 
		finally
		{
			TraceOut("primaryExpression", 9);
			LeaveRule("primaryExpression", 9);
			LeaveRule_primaryExpression();
		}
		DebugLocation(641, 1);
		} finally { DebugExitRule(GrammarFileName, "primaryExpression"); }
		return retval;

	}
	// $ANTLR end "primaryExpression"

	partial void EnterRule_arrayLiteral();
	partial void LeaveRule_arrayLiteral();
	// $ANTLR start "arrayLiteral"
	// JavaScript.g:643:1: arrayLiteral : lb= LBRACK ( arrayItem ( COMMA arrayItem )* )? RBRACK -> ^( ARRAY[$lb, \"ARRAY\"] ( arrayItem )* ) ;
	[GrammarRule("arrayLiteral")]
	private AstParserRuleReturnScope<object, IToken> arrayLiteral()
	{
		EnterRule_arrayLiteral();
		EnterRule("arrayLiteral", 10);
		TraceIn("arrayLiteral", 10);
		AstParserRuleReturnScope<object, IToken> retval = new AstParserRuleReturnScope<object, IToken>();
		retval.Start = (IToken)input.LT(1);

		object root_0 = default(object);

		IToken lb = default(IToken);
		IToken COMMA28 = default(IToken);
		IToken RBRACK30 = default(IToken);
		AstParserRuleReturnScope<object, IToken> arrayItem27 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> arrayItem29 = default(AstParserRuleReturnScope<object, IToken>);

		object lb_tree = default(object);
		object COMMA28_tree = default(object);
		object RBRACK30_tree = default(object);
		RewriteRuleITokenStream stream_LBRACK=new RewriteRuleITokenStream(adaptor,"token LBRACK");
		RewriteRuleITokenStream stream_COMMA=new RewriteRuleITokenStream(adaptor,"token COMMA");
		RewriteRuleITokenStream stream_RBRACK=new RewriteRuleITokenStream(adaptor,"token RBRACK");
		RewriteRuleSubtreeStream stream_arrayItem=new RewriteRuleSubtreeStream(adaptor,"rule arrayItem");
		try { DebugEnterRule(GrammarFileName, "arrayLiteral");
		DebugLocation(643, 1);
		try
		{
			// JavaScript.g:644:2: (lb= LBRACK ( arrayItem ( COMMA arrayItem )* )? RBRACK -> ^( ARRAY[$lb, \"ARRAY\"] ( arrayItem )* ) )
			DebugEnterAlt(1);
			// JavaScript.g:644:4: lb= LBRACK ( arrayItem ( COMMA arrayItem )* )? RBRACK
			{
			DebugLocation(644, 6);
			lb=(IToken)Match(input,LBRACK,Follow._LBRACK_in_arrayLiteral3176);  
			stream_LBRACK.Add(lb);

			DebugLocation(644, 14);
			// JavaScript.g:644:14: ( arrayItem ( COMMA arrayItem )* )?
			int alt6=2;
			try { DebugEnterSubRule(6);
			try { DebugEnterDecision(6, false);
			int LA6_1 = input.LA(1);

			if ((LA6_1==ADD||LA6_1==COMMA||LA6_1==DEC||LA6_1==DELETE||LA6_1==DecimalLiteral||LA6_1==FALSE||LA6_1==FUNCTION||LA6_1==HexIntegerLiteral||LA6_1==INC||LA6_1==INV||LA6_1==Identifier||(LA6_1>=LBRACE && LA6_1<=LBRACK)||LA6_1==LPAREN||(LA6_1>=NEW && LA6_1<=NOT)||LA6_1==NULL||LA6_1==OctalIntegerLiteral||LA6_1==RegularExpressionLiteral||LA6_1==SUB||LA6_1==StringLiteral||LA6_1==THIS||LA6_1==TRUE||LA6_1==TYPEOF||LA6_1==VOID))
			{
				alt6 = 1;
			}
			else if ((LA6_1==RBRACK))
			{
				int LA6_2 = input.LA(2);

				if ((( input.LA(1) == COMMA )))
				{
					alt6 = 1;
				}
			}
			} finally { DebugExitDecision(6); }
			switch (alt6)
			{
			case 1:
				DebugEnterAlt(1);
				// JavaScript.g:644:16: arrayItem ( COMMA arrayItem )*
				{
				DebugLocation(644, 16);
				PushFollow(Follow._arrayItem_in_arrayLiteral3180);
				arrayItem27=arrayItem();
				PopFollow();

				stream_arrayItem.Add(arrayItem27.Tree);
				DebugLocation(644, 26);
				// JavaScript.g:644:26: ( COMMA arrayItem )*
				try { DebugEnterSubRule(5);
				while (true)
				{
					int alt5=2;
					try { DebugEnterDecision(5, false);
					int LA5_1 = input.LA(1);

					if ((LA5_1==COMMA))
					{
						alt5 = 1;
					}


					} finally { DebugExitDecision(5); }
					switch ( alt5 )
					{
					case 1:
						DebugEnterAlt(1);
						// JavaScript.g:644:28: COMMA arrayItem
						{
						DebugLocation(644, 28);
						COMMA28=(IToken)Match(input,COMMA,Follow._COMMA_in_arrayLiteral3184);  
						stream_COMMA.Add(COMMA28);

						DebugLocation(644, 34);
						PushFollow(Follow._arrayItem_in_arrayLiteral3186);
						arrayItem29=arrayItem();
						PopFollow();

						stream_arrayItem.Add(arrayItem29.Tree);

						}
						break;

					default:
						goto loop5;
					}
				}

				loop5:
					;

				} finally { DebugExitSubRule(5); }


				}
				break;

			}
			} finally { DebugExitSubRule(6); }

			DebugLocation(644, 50);
			RBRACK30=(IToken)Match(input,RBRACK,Follow._RBRACK_in_arrayLiteral3194);  
			stream_RBRACK.Add(RBRACK30);



			{
			// AST REWRITE
			// elements: arrayItem
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			retval.Tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

			root_0 = (object)adaptor.Nil();
			// 645:2: -> ^( ARRAY[$lb, \"ARRAY\"] ( arrayItem )* )
			{
				DebugLocation(645, 5);
				// JavaScript.g:645:5: ^( ARRAY[$lb, \"ARRAY\"] ( arrayItem )* )
				{
				object root_1 = (object)adaptor.Nil();
				DebugLocation(645, 8);
				root_1 = (object)adaptor.BecomeRoot((object)adaptor.Create(ARRAY, lb, "ARRAY"), root_1);

				DebugLocation(645, 28);
				// JavaScript.g:645:28: ( arrayItem )*
				while ( stream_arrayItem.HasNext )
				{
					DebugLocation(645, 28);
					adaptor.AddChild(root_1, stream_arrayItem.NextTree());

				}
				stream_arrayItem.Reset();

				adaptor.AddChild(root_0, root_1);
				}

			}

			retval.Tree = root_0;
			}

			}

			retval.Stop = (IToken)input.LT(-1);

			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);

		}
		 
		finally
		{
			TraceOut("arrayLiteral", 10);
			LeaveRule("arrayLiteral", 10);
			LeaveRule_arrayLiteral();
		}
		DebugLocation(646, 1);
		} finally { DebugExitRule(GrammarFileName, "arrayLiteral"); }
		return retval;

	}
	// $ANTLR end "arrayLiteral"

	partial void EnterRule_arrayItem();
	partial void LeaveRule_arrayItem();
	// $ANTLR start "arrayItem"
	// JavaScript.g:648:1: arrayItem : (expr= assignmentExpression |{...}?) -> ^( ITEM ( $expr)? ) ;
	[GrammarRule("arrayItem")]
	private AstParserRuleReturnScope<object, IToken> arrayItem()
	{
		EnterRule_arrayItem();
		EnterRule("arrayItem", 11);
		TraceIn("arrayItem", 11);
		AstParserRuleReturnScope<object, IToken> retval = new AstParserRuleReturnScope<object, IToken>();
		retval.Start = (IToken)input.LT(1);

		object root_0 = default(object);

		AstParserRuleReturnScope<object, IToken> expr = default(AstParserRuleReturnScope<object, IToken>);

		RewriteRuleSubtreeStream stream_assignmentExpression=new RewriteRuleSubtreeStream(adaptor,"rule assignmentExpression");
		try { DebugEnterRule(GrammarFileName, "arrayItem");
		DebugLocation(648, 1);
		try
		{
			// JavaScript.g:649:2: ( (expr= assignmentExpression |{...}?) -> ^( ITEM ( $expr)? ) )
			DebugEnterAlt(1);
			// JavaScript.g:649:4: (expr= assignmentExpression |{...}?)
			{
			DebugLocation(649, 4);
			// JavaScript.g:649:4: (expr= assignmentExpression |{...}?)
			int alt7=2;
			try { DebugEnterSubRule(7);
			try { DebugEnterDecision(7, false);
			int LA7_1 = input.LA(1);

			if ((LA7_1==ADD||LA7_1==DEC||LA7_1==DELETE||LA7_1==DecimalLiteral||LA7_1==FALSE||LA7_1==FUNCTION||LA7_1==HexIntegerLiteral||LA7_1==INC||LA7_1==INV||LA7_1==Identifier||(LA7_1>=LBRACE && LA7_1<=LBRACK)||LA7_1==LPAREN||(LA7_1>=NEW && LA7_1<=NOT)||LA7_1==NULL||LA7_1==OctalIntegerLiteral||LA7_1==RegularExpressionLiteral||LA7_1==SUB||LA7_1==StringLiteral||LA7_1==THIS||LA7_1==TRUE||LA7_1==TYPEOF||LA7_1==VOID))
			{
				alt7 = 1;
			}
			else if ((LA7_1==COMMA||LA7_1==RBRACK))
			{
				alt7 = 2;
			}
			else
			{
				NoViableAltException nvae = new NoViableAltException("", 7, 0, input, 1);
				DebugRecognitionException(nvae);
				throw nvae;
			}
			} finally { DebugExitDecision(7); }
			switch (alt7)
			{
			case 1:
				DebugEnterAlt(1);
				// JavaScript.g:649:6: expr= assignmentExpression
				{
				DebugLocation(649, 10);
				PushFollow(Follow._assignmentExpression_in_arrayItem3222);
				expr=assignmentExpression();
				PopFollow();

				stream_assignmentExpression.Add(expr.Tree);

				}
				break;
			case 2:
				DebugEnterAlt(2);
				// JavaScript.g:649:34: {...}?
				{
				DebugLocation(649, 34);
				if (!(( input.LA(1) == COMMA )))
				{
					throw new FailedPredicateException(input, "arrayItem", " input.LA(1) == COMMA ");
				}

				}
				break;

			}
			} finally { DebugExitSubRule(7); }



			{
			// AST REWRITE
			// elements: expr
			// token labels: 
			// rule labels: expr, retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			retval.Tree = root_0;
			RewriteRuleSubtreeStream stream_expr=new RewriteRuleSubtreeStream(adaptor,"rule expr",expr!=null?expr.Tree:null);
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

			root_0 = (object)adaptor.Nil();
			// 650:2: -> ^( ITEM ( $expr)? )
			{
				DebugLocation(650, 5);
				// JavaScript.g:650:5: ^( ITEM ( $expr)? )
				{
				object root_1 = (object)adaptor.Nil();
				DebugLocation(650, 8);
				root_1 = (object)adaptor.BecomeRoot((object)adaptor.Create(ITEM, "ITEM"), root_1);

				DebugLocation(650, 14);
				// JavaScript.g:650:14: ( $expr)?
				if (stream_expr.HasNext)
				{
					DebugLocation(650, 14);
					adaptor.AddChild(root_1, stream_expr.NextTree());

				}
				stream_expr.Reset();

				adaptor.AddChild(root_0, root_1);
				}

			}

			retval.Tree = root_0;
			}

			}

			retval.Stop = (IToken)input.LT(-1);

			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);

		}
		 
		finally
		{
			TraceOut("arrayItem", 11);
			LeaveRule("arrayItem", 11);
			LeaveRule_arrayItem();
		}
		DebugLocation(651, 1);
		} finally { DebugExitRule(GrammarFileName, "arrayItem"); }
		return retval;

	}
	// $ANTLR end "arrayItem"

	partial void EnterRule_objectLiteral();
	partial void LeaveRule_objectLiteral();
	// $ANTLR start "objectLiteral"
	// JavaScript.g:653:1: objectLiteral : lb= LBRACE ( nameValuePair ( COMMA nameValuePair )* )? RBRACE -> ^( OBJECT[$lb, \"OBJECT\"] ( nameValuePair )* ) ;
	[GrammarRule("objectLiteral")]
	private AstParserRuleReturnScope<object, IToken> objectLiteral()
	{
		EnterRule_objectLiteral();
		EnterRule("objectLiteral", 12);
		TraceIn("objectLiteral", 12);
		AstParserRuleReturnScope<object, IToken> retval = new AstParserRuleReturnScope<object, IToken>();
		retval.Start = (IToken)input.LT(1);

		object root_0 = default(object);

		IToken lb = default(IToken);
		IToken COMMA32 = default(IToken);
		IToken RBRACE34 = default(IToken);
		AstParserRuleReturnScope<object, IToken> nameValuePair31 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> nameValuePair33 = default(AstParserRuleReturnScope<object, IToken>);

		object lb_tree = default(object);
		object COMMA32_tree = default(object);
		object RBRACE34_tree = default(object);
		RewriteRuleITokenStream stream_LBRACE=new RewriteRuleITokenStream(adaptor,"token LBRACE");
		RewriteRuleITokenStream stream_COMMA=new RewriteRuleITokenStream(adaptor,"token COMMA");
		RewriteRuleITokenStream stream_RBRACE=new RewriteRuleITokenStream(adaptor,"token RBRACE");
		RewriteRuleSubtreeStream stream_nameValuePair=new RewriteRuleSubtreeStream(adaptor,"rule nameValuePair");
		try { DebugEnterRule(GrammarFileName, "objectLiteral");
		DebugLocation(653, 1);
		try
		{
			// JavaScript.g:654:2: (lb= LBRACE ( nameValuePair ( COMMA nameValuePair )* )? RBRACE -> ^( OBJECT[$lb, \"OBJECT\"] ( nameValuePair )* ) )
			DebugEnterAlt(1);
			// JavaScript.g:654:4: lb= LBRACE ( nameValuePair ( COMMA nameValuePair )* )? RBRACE
			{
			DebugLocation(654, 6);
			lb=(IToken)Match(input,LBRACE,Follow._LBRACE_in_objectLiteral3254);  
			stream_LBRACE.Add(lb);

			DebugLocation(654, 14);
			// JavaScript.g:654:14: ( nameValuePair ( COMMA nameValuePair )* )?
			int alt9=2;
			try { DebugEnterSubRule(9);
			try { DebugEnterDecision(9, false);
			int LA9_1 = input.LA(1);

			if ((LA9_1==DecimalLiteral||LA9_1==HexIntegerLiteral||LA9_1==Identifier||LA9_1==OctalIntegerLiteral||LA9_1==StringLiteral))
			{
				alt9 = 1;
			}
			} finally { DebugExitDecision(9); }
			switch (alt9)
			{
			case 1:
				DebugEnterAlt(1);
				// JavaScript.g:654:16: nameValuePair ( COMMA nameValuePair )*
				{
				DebugLocation(654, 16);
				PushFollow(Follow._nameValuePair_in_objectLiteral3258);
				nameValuePair31=nameValuePair();
				PopFollow();

				stream_nameValuePair.Add(nameValuePair31.Tree);
				DebugLocation(654, 30);
				// JavaScript.g:654:30: ( COMMA nameValuePair )*
				try { DebugEnterSubRule(8);
				while (true)
				{
					int alt8=2;
					try { DebugEnterDecision(8, false);
					int LA8_1 = input.LA(1);

					if ((LA8_1==COMMA))
					{
						alt8 = 1;
					}


					} finally { DebugExitDecision(8); }
					switch ( alt8 )
					{
					case 1:
						DebugEnterAlt(1);
						// JavaScript.g:654:32: COMMA nameValuePair
						{
						DebugLocation(654, 32);
						COMMA32=(IToken)Match(input,COMMA,Follow._COMMA_in_objectLiteral3262);  
						stream_COMMA.Add(COMMA32);

						DebugLocation(654, 38);
						PushFollow(Follow._nameValuePair_in_objectLiteral3264);
						nameValuePair33=nameValuePair();
						PopFollow();

						stream_nameValuePair.Add(nameValuePair33.Tree);

						}
						break;

					default:
						goto loop8;
					}
				}

				loop8:
					;

				} finally { DebugExitSubRule(8); }


				}
				break;

			}
			} finally { DebugExitSubRule(9); }

			DebugLocation(654, 58);
			RBRACE34=(IToken)Match(input,RBRACE,Follow._RBRACE_in_objectLiteral3272);  
			stream_RBRACE.Add(RBRACE34);



			{
			// AST REWRITE
			// elements: nameValuePair
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			retval.Tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

			root_0 = (object)adaptor.Nil();
			// 655:2: -> ^( OBJECT[$lb, \"OBJECT\"] ( nameValuePair )* )
			{
				DebugLocation(655, 5);
				// JavaScript.g:655:5: ^( OBJECT[$lb, \"OBJECT\"] ( nameValuePair )* )
				{
				object root_1 = (object)adaptor.Nil();
				DebugLocation(655, 8);
				root_1 = (object)adaptor.BecomeRoot((object)adaptor.Create(OBJECT, lb, "OBJECT"), root_1);

				DebugLocation(655, 30);
				// JavaScript.g:655:30: ( nameValuePair )*
				while ( stream_nameValuePair.HasNext )
				{
					DebugLocation(655, 30);
					adaptor.AddChild(root_1, stream_nameValuePair.NextTree());

				}
				stream_nameValuePair.Reset();

				adaptor.AddChild(root_0, root_1);
				}

			}

			retval.Tree = root_0;
			}

			}

			retval.Stop = (IToken)input.LT(-1);

			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);

		}
		 
		finally
		{
			TraceOut("objectLiteral", 12);
			LeaveRule("objectLiteral", 12);
			LeaveRule_objectLiteral();
		}
		DebugLocation(656, 1);
		} finally { DebugExitRule(GrammarFileName, "objectLiteral"); }
		return retval;

	}
	// $ANTLR end "objectLiteral"

	partial void EnterRule_nameValuePair();
	partial void LeaveRule_nameValuePair();
	// $ANTLR start "nameValuePair"
	// JavaScript.g:658:1: nameValuePair : propertyName COLON assignmentExpression -> ^( NAMEDVALUE propertyName assignmentExpression ) ;
	[GrammarRule("nameValuePair")]
	private AstParserRuleReturnScope<object, IToken> nameValuePair()
	{
		EnterRule_nameValuePair();
		EnterRule("nameValuePair", 13);
		TraceIn("nameValuePair", 13);
		AstParserRuleReturnScope<object, IToken> retval = new AstParserRuleReturnScope<object, IToken>();
		retval.Start = (IToken)input.LT(1);

		object root_0 = default(object);

		IToken COLON36 = default(IToken);
		AstParserRuleReturnScope<object, IToken> propertyName35 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> assignmentExpression37 = default(AstParserRuleReturnScope<object, IToken>);

		object COLON36_tree = default(object);
		RewriteRuleITokenStream stream_COLON=new RewriteRuleITokenStream(adaptor,"token COLON");
		RewriteRuleSubtreeStream stream_propertyName=new RewriteRuleSubtreeStream(adaptor,"rule propertyName");
		RewriteRuleSubtreeStream stream_assignmentExpression=new RewriteRuleSubtreeStream(adaptor,"rule assignmentExpression");
		try { DebugEnterRule(GrammarFileName, "nameValuePair");
		DebugLocation(658, 1);
		try
		{
			// JavaScript.g:659:2: ( propertyName COLON assignmentExpression -> ^( NAMEDVALUE propertyName assignmentExpression ) )
			DebugEnterAlt(1);
			// JavaScript.g:659:4: propertyName COLON assignmentExpression
			{
			DebugLocation(659, 4);
			PushFollow(Follow._propertyName_in_nameValuePair3297);
			propertyName35=propertyName();
			PopFollow();

			stream_propertyName.Add(propertyName35.Tree);
			DebugLocation(659, 17);
			COLON36=(IToken)Match(input,COLON,Follow._COLON_in_nameValuePair3299);  
			stream_COLON.Add(COLON36);

			DebugLocation(659, 23);
			PushFollow(Follow._assignmentExpression_in_nameValuePair3301);
			assignmentExpression37=assignmentExpression();
			PopFollow();

			stream_assignmentExpression.Add(assignmentExpression37.Tree);


			{
			// AST REWRITE
			// elements: propertyName, assignmentExpression
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			retval.Tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

			root_0 = (object)adaptor.Nil();
			// 660:2: -> ^( NAMEDVALUE propertyName assignmentExpression )
			{
				DebugLocation(660, 5);
				// JavaScript.g:660:5: ^( NAMEDVALUE propertyName assignmentExpression )
				{
				object root_1 = (object)adaptor.Nil();
				DebugLocation(660, 8);
				root_1 = (object)adaptor.BecomeRoot((object)adaptor.Create(NAMEDVALUE, "NAMEDVALUE"), root_1);

				DebugLocation(660, 19);
				adaptor.AddChild(root_1, stream_propertyName.NextTree());
				DebugLocation(660, 32);
				adaptor.AddChild(root_1, stream_assignmentExpression.NextTree());

				adaptor.AddChild(root_0, root_1);
				}

			}

			retval.Tree = root_0;
			}

			}

			retval.Stop = (IToken)input.LT(-1);

			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);

		}
		 
		finally
		{
			TraceOut("nameValuePair", 13);
			LeaveRule("nameValuePair", 13);
			LeaveRule_nameValuePair();
		}
		DebugLocation(661, 1);
		} finally { DebugExitRule(GrammarFileName, "nameValuePair"); }
		return retval;

	}
	// $ANTLR end "nameValuePair"

	partial void EnterRule_propertyName();
	partial void LeaveRule_propertyName();
	// $ANTLR start "propertyName"
	// JavaScript.g:663:1: propertyName : ( Identifier | StringLiteral | numericLiteral );
	[GrammarRule("propertyName")]
	private AstParserRuleReturnScope<object, IToken> propertyName()
	{
		EnterRule_propertyName();
		EnterRule("propertyName", 14);
		TraceIn("propertyName", 14);
		AstParserRuleReturnScope<object, IToken> retval = new AstParserRuleReturnScope<object, IToken>();
		retval.Start = (IToken)input.LT(1);

		object root_0 = default(object);

		IToken Identifier38 = default(IToken);
		IToken StringLiteral39 = default(IToken);
		AstParserRuleReturnScope<object, IToken> numericLiteral40 = default(AstParserRuleReturnScope<object, IToken>);

		object Identifier38_tree = default(object);
		object StringLiteral39_tree = default(object);
		try { DebugEnterRule(GrammarFileName, "propertyName");
		DebugLocation(663, 1);
		try
		{
			// JavaScript.g:664:2: ( Identifier | StringLiteral | numericLiteral )
			int alt10=3;
			try { DebugEnterDecision(10, false);
			switch (input.LA(1))
			{
			case Identifier:
				{
				alt10 = 1;
				}
				break;
			case StringLiteral:
				{
				alt10 = 2;
				}
				break;
			case DecimalLiteral:
			case HexIntegerLiteral:
			case OctalIntegerLiteral:
				{
				alt10 = 3;
				}
				break;
			default:
				{
					NoViableAltException nvae = new NoViableAltException("", 10, 0, input, 1);
					DebugRecognitionException(nvae);
					throw nvae;
				}
			}

			} finally { DebugExitDecision(10); }
			switch (alt10)
			{
			case 1:
				DebugEnterAlt(1);
				// JavaScript.g:664:4: Identifier
				{
				root_0 = (object)adaptor.Nil();

				DebugLocation(664, 4);
				Identifier38=(IToken)Match(input,Identifier,Follow._Identifier_in_propertyName3325); 
				Identifier38_tree = (object)adaptor.Create(Identifier38);
				adaptor.AddChild(root_0, Identifier38_tree);

				}
				break;
			case 2:
				DebugEnterAlt(2);
				// JavaScript.g:665:4: StringLiteral
				{
				root_0 = (object)adaptor.Nil();

				DebugLocation(665, 4);
				StringLiteral39=(IToken)Match(input,StringLiteral,Follow._StringLiteral_in_propertyName3330); 
				StringLiteral39_tree = (object)adaptor.Create(StringLiteral39);
				adaptor.AddChild(root_0, StringLiteral39_tree);

				}
				break;
			case 3:
				DebugEnterAlt(3);
				// JavaScript.g:666:4: numericLiteral
				{
				root_0 = (object)adaptor.Nil();

				DebugLocation(666, 4);
				PushFollow(Follow._numericLiteral_in_propertyName3335);
				numericLiteral40=numericLiteral();
				PopFollow();

				adaptor.AddChild(root_0, numericLiteral40.Tree);

				}
				break;

			}
			retval.Stop = (IToken)input.LT(-1);

			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);

		}
		 
		finally
		{
			TraceOut("propertyName", 14);
			LeaveRule("propertyName", 14);
			LeaveRule_propertyName();
		}
		DebugLocation(667, 1);
		} finally { DebugExitRule(GrammarFileName, "propertyName"); }
		return retval;

	}
	// $ANTLR end "propertyName"

	partial void EnterRule_memberExpression();
	partial void LeaveRule_memberExpression();
	// $ANTLR start "memberExpression"
	// JavaScript.g:678:1: memberExpression : ( primaryExpression | functionExpression | newExpression );
	[GrammarRule("memberExpression")]
	private AstParserRuleReturnScope<object, IToken> memberExpression()
	{
		EnterRule_memberExpression();
		EnterRule("memberExpression", 15);
		TraceIn("memberExpression", 15);
		AstParserRuleReturnScope<object, IToken> retval = new AstParserRuleReturnScope<object, IToken>();
		retval.Start = (IToken)input.LT(1);

		object root_0 = default(object);

		AstParserRuleReturnScope<object, IToken> primaryExpression41 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> functionExpression42 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> newExpression43 = default(AstParserRuleReturnScope<object, IToken>);

		try { DebugEnterRule(GrammarFileName, "memberExpression");
		DebugLocation(678, 1);
		try
		{
			// JavaScript.g:679:2: ( primaryExpression | functionExpression | newExpression )
			int alt11=3;
			try { DebugEnterDecision(11, false);
			switch (input.LA(1))
			{
			case DecimalLiteral:
			case FALSE:
			case HexIntegerLiteral:
			case Identifier:
			case LBRACE:
			case LBRACK:
			case LPAREN:
			case NULL:
			case OctalIntegerLiteral:
			case RegularExpressionLiteral:
			case StringLiteral:
			case THIS:
			case TRUE:
				{
				alt11 = 1;
				}
				break;
			case FUNCTION:
				{
				alt11 = 2;
				}
				break;
			case NEW:
				{
				alt11 = 3;
				}
				break;
			default:
				{
					NoViableAltException nvae = new NoViableAltException("", 11, 0, input, 1);
					DebugRecognitionException(nvae);
					throw nvae;
				}
			}

			} finally { DebugExitDecision(11); }
			switch (alt11)
			{
			case 1:
				DebugEnterAlt(1);
				// JavaScript.g:679:4: primaryExpression
				{
				root_0 = (object)adaptor.Nil();

				DebugLocation(679, 4);
				PushFollow(Follow._primaryExpression_in_memberExpression3353);
				primaryExpression41=primaryExpression();
				PopFollow();

				adaptor.AddChild(root_0, primaryExpression41.Tree);

				}
				break;
			case 2:
				DebugEnterAlt(2);
				// JavaScript.g:680:4: functionExpression
				{
				root_0 = (object)adaptor.Nil();

				DebugLocation(680, 4);
				PushFollow(Follow._functionExpression_in_memberExpression3358);
				functionExpression42=functionExpression();
				PopFollow();

				adaptor.AddChild(root_0, functionExpression42.Tree);

				}
				break;
			case 3:
				DebugEnterAlt(3);
				// JavaScript.g:681:4: newExpression
				{
				root_0 = (object)adaptor.Nil();

				DebugLocation(681, 4);
				PushFollow(Follow._newExpression_in_memberExpression3363);
				newExpression43=newExpression();
				PopFollow();

				adaptor.AddChild(root_0, newExpression43.Tree);

				}
				break;

			}
			retval.Stop = (IToken)input.LT(-1);

			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);

		}
		 
		finally
		{
			TraceOut("memberExpression", 15);
			LeaveRule("memberExpression", 15);
			LeaveRule_memberExpression();
		}
		DebugLocation(682, 1);
		} finally { DebugExitRule(GrammarFileName, "memberExpression"); }
		return retval;

	}
	// $ANTLR end "memberExpression"

	partial void EnterRule_newExpression();
	partial void LeaveRule_newExpression();
	// $ANTLR start "newExpression"
	// JavaScript.g:684:1: newExpression : NEW ^ primaryExpression ;
	[GrammarRule("newExpression")]
	private AstParserRuleReturnScope<object, IToken> newExpression()
	{
		EnterRule_newExpression();
		EnterRule("newExpression", 16);
		TraceIn("newExpression", 16);
		AstParserRuleReturnScope<object, IToken> retval = new AstParserRuleReturnScope<object, IToken>();
		retval.Start = (IToken)input.LT(1);

		object root_0 = default(object);

		IToken NEW44 = default(IToken);
		AstParserRuleReturnScope<object, IToken> primaryExpression45 = default(AstParserRuleReturnScope<object, IToken>);

		object NEW44_tree = default(object);
		try { DebugEnterRule(GrammarFileName, "newExpression");
		DebugLocation(684, 1);
		try
		{
			// JavaScript.g:685:2: ( NEW ^ primaryExpression )
			DebugEnterAlt(1);
			// JavaScript.g:685:4: NEW ^ primaryExpression
			{
			root_0 = (object)adaptor.Nil();

			DebugLocation(685, 7);
			NEW44=(IToken)Match(input,NEW,Follow._NEW_in_newExpression3374); 
			NEW44_tree = (object)adaptor.Create(NEW44);
			root_0 = (object)adaptor.BecomeRoot(NEW44_tree, root_0);
			DebugLocation(685, 9);
			PushFollow(Follow._primaryExpression_in_newExpression3377);
			primaryExpression45=primaryExpression();
			PopFollow();

			adaptor.AddChild(root_0, primaryExpression45.Tree);

			}

			retval.Stop = (IToken)input.LT(-1);

			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);

		}
		 
		finally
		{
			TraceOut("newExpression", 16);
			LeaveRule("newExpression", 16);
			LeaveRule_newExpression();
		}
		DebugLocation(686, 1);
		} finally { DebugExitRule(GrammarFileName, "newExpression"); }
		return retval;

	}
	// $ANTLR end "newExpression"

	partial void EnterRule_arguments();
	partial void LeaveRule_arguments();
	// $ANTLR start "arguments"
	// JavaScript.g:689:1: arguments : LPAREN ( assignmentExpression ( COMMA assignmentExpression )* )? RPAREN -> ^( ARGS ( assignmentExpression )* ) ;
	[GrammarRule("arguments")]
	private AstParserRuleReturnScope<object, IToken> arguments()
	{
		EnterRule_arguments();
		EnterRule("arguments", 17);
		TraceIn("arguments", 17);
		AstParserRuleReturnScope<object, IToken> retval = new AstParserRuleReturnScope<object, IToken>();
		retval.Start = (IToken)input.LT(1);

		object root_0 = default(object);

		IToken LPAREN46 = default(IToken);
		IToken COMMA48 = default(IToken);
		IToken RPAREN50 = default(IToken);
		AstParserRuleReturnScope<object, IToken> assignmentExpression47 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> assignmentExpression49 = default(AstParserRuleReturnScope<object, IToken>);

		object LPAREN46_tree = default(object);
		object COMMA48_tree = default(object);
		object RPAREN50_tree = default(object);
		RewriteRuleITokenStream stream_LPAREN=new RewriteRuleITokenStream(adaptor,"token LPAREN");
		RewriteRuleITokenStream stream_COMMA=new RewriteRuleITokenStream(adaptor,"token COMMA");
		RewriteRuleITokenStream stream_RPAREN=new RewriteRuleITokenStream(adaptor,"token RPAREN");
		RewriteRuleSubtreeStream stream_assignmentExpression=new RewriteRuleSubtreeStream(adaptor,"rule assignmentExpression");
		try { DebugEnterRule(GrammarFileName, "arguments");
		DebugLocation(689, 1);
		try
		{
			// JavaScript.g:690:2: ( LPAREN ( assignmentExpression ( COMMA assignmentExpression )* )? RPAREN -> ^( ARGS ( assignmentExpression )* ) )
			DebugEnterAlt(1);
			// JavaScript.g:690:4: LPAREN ( assignmentExpression ( COMMA assignmentExpression )* )? RPAREN
			{
			DebugLocation(690, 4);
			LPAREN46=(IToken)Match(input,LPAREN,Follow._LPAREN_in_arguments3390);  
			stream_LPAREN.Add(LPAREN46);

			DebugLocation(690, 11);
			// JavaScript.g:690:11: ( assignmentExpression ( COMMA assignmentExpression )* )?
			int alt13=2;
			try { DebugEnterSubRule(13);
			try { DebugEnterDecision(13, false);
			int LA13_1 = input.LA(1);

			if ((LA13_1==ADD||LA13_1==DEC||LA13_1==DELETE||LA13_1==DecimalLiteral||LA13_1==FALSE||LA13_1==FUNCTION||LA13_1==HexIntegerLiteral||LA13_1==INC||LA13_1==INV||LA13_1==Identifier||(LA13_1>=LBRACE && LA13_1<=LBRACK)||LA13_1==LPAREN||(LA13_1>=NEW && LA13_1<=NOT)||LA13_1==NULL||LA13_1==OctalIntegerLiteral||LA13_1==RegularExpressionLiteral||LA13_1==SUB||LA13_1==StringLiteral||LA13_1==THIS||LA13_1==TRUE||LA13_1==TYPEOF||LA13_1==VOID))
			{
				alt13 = 1;
			}
			} finally { DebugExitDecision(13); }
			switch (alt13)
			{
			case 1:
				DebugEnterAlt(1);
				// JavaScript.g:690:13: assignmentExpression ( COMMA assignmentExpression )*
				{
				DebugLocation(690, 13);
				PushFollow(Follow._assignmentExpression_in_arguments3394);
				assignmentExpression47=assignmentExpression();
				PopFollow();

				stream_assignmentExpression.Add(assignmentExpression47.Tree);
				DebugLocation(690, 34);
				// JavaScript.g:690:34: ( COMMA assignmentExpression )*
				try { DebugEnterSubRule(12);
				while (true)
				{
					int alt12=2;
					try { DebugEnterDecision(12, false);
					int LA12_1 = input.LA(1);

					if ((LA12_1==COMMA))
					{
						alt12 = 1;
					}


					} finally { DebugExitDecision(12); }
					switch ( alt12 )
					{
					case 1:
						DebugEnterAlt(1);
						// JavaScript.g:690:36: COMMA assignmentExpression
						{
						DebugLocation(690, 36);
						COMMA48=(IToken)Match(input,COMMA,Follow._COMMA_in_arguments3398);  
						stream_COMMA.Add(COMMA48);

						DebugLocation(690, 42);
						PushFollow(Follow._assignmentExpression_in_arguments3400);
						assignmentExpression49=assignmentExpression();
						PopFollow();

						stream_assignmentExpression.Add(assignmentExpression49.Tree);

						}
						break;

					default:
						goto loop12;
					}
				}

				loop12:
					;

				} finally { DebugExitSubRule(12); }


				}
				break;

			}
			} finally { DebugExitSubRule(13); }

			DebugLocation(690, 69);
			RPAREN50=(IToken)Match(input,RPAREN,Follow._RPAREN_in_arguments3408);  
			stream_RPAREN.Add(RPAREN50);



			{
			// AST REWRITE
			// elements: assignmentExpression
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			retval.Tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

			root_0 = (object)adaptor.Nil();
			// 691:2: -> ^( ARGS ( assignmentExpression )* )
			{
				DebugLocation(691, 5);
				// JavaScript.g:691:5: ^( ARGS ( assignmentExpression )* )
				{
				object root_1 = (object)adaptor.Nil();
				DebugLocation(691, 8);
				root_1 = (object)adaptor.BecomeRoot((object)adaptor.Create(ARGS, "ARGS"), root_1);

				DebugLocation(691, 13);
				// JavaScript.g:691:13: ( assignmentExpression )*
				while ( stream_assignmentExpression.HasNext )
				{
					DebugLocation(691, 13);
					adaptor.AddChild(root_1, stream_assignmentExpression.NextTree());

				}
				stream_assignmentExpression.Reset();

				adaptor.AddChild(root_0, root_1);
				}

			}

			retval.Tree = root_0;
			}

			}

			retval.Stop = (IToken)input.LT(-1);

			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);

		}
		 
		finally
		{
			TraceOut("arguments", 17);
			LeaveRule("arguments", 17);
			LeaveRule_arguments();
		}
		DebugLocation(692, 1);
		} finally { DebugExitRule(GrammarFileName, "arguments"); }
		return retval;

	}
	// $ANTLR end "arguments"

	partial void EnterRule_leftHandSideExpression();
	partial void LeaveRule_leftHandSideExpression();
	// $ANTLR start "leftHandSideExpression"
	// JavaScript.g:694:1: leftHandSideExpression : ( memberExpression -> memberExpression ) ( arguments -> ^( CALL $leftHandSideExpression arguments ) | LBRACK expression RBRACK -> ^( BYINDEX $leftHandSideExpression expression ) | DOT Identifier -> ^( BYFIELD $leftHandSideExpression Identifier ) )* ;
	[GrammarRule("leftHandSideExpression")]
	private AstParserRuleReturnScope<object, IToken> leftHandSideExpression()
	{
		EnterRule_leftHandSideExpression();
		EnterRule("leftHandSideExpression", 18);
		TraceIn("leftHandSideExpression", 18);
		AstParserRuleReturnScope<object, IToken> retval = new AstParserRuleReturnScope<object, IToken>();
		retval.Start = (IToken)input.LT(1);

		object root_0 = default(object);

		IToken LBRACK53 = default(IToken);
		IToken RBRACK55 = default(IToken);
		IToken DOT56 = default(IToken);
		IToken Identifier57 = default(IToken);
		AstParserRuleReturnScope<object, IToken> memberExpression51 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> arguments52 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> expression54 = default(AstParserRuleReturnScope<object, IToken>);

		object LBRACK53_tree = default(object);
		object RBRACK55_tree = default(object);
		object DOT56_tree = default(object);
		object Identifier57_tree = default(object);
		RewriteRuleITokenStream stream_LBRACK=new RewriteRuleITokenStream(adaptor,"token LBRACK");
		RewriteRuleITokenStream stream_RBRACK=new RewriteRuleITokenStream(adaptor,"token RBRACK");
		RewriteRuleITokenStream stream_DOT=new RewriteRuleITokenStream(adaptor,"token DOT");
		RewriteRuleITokenStream stream_Identifier=new RewriteRuleITokenStream(adaptor,"token Identifier");
		RewriteRuleSubtreeStream stream_memberExpression=new RewriteRuleSubtreeStream(adaptor,"rule memberExpression");
		RewriteRuleSubtreeStream stream_arguments=new RewriteRuleSubtreeStream(adaptor,"rule arguments");
		RewriteRuleSubtreeStream stream_expression=new RewriteRuleSubtreeStream(adaptor,"rule expression");
		try { DebugEnterRule(GrammarFileName, "leftHandSideExpression");
		DebugLocation(694, 1);
		try
		{
			// JavaScript.g:695:2: ( ( memberExpression -> memberExpression ) ( arguments -> ^( CALL $leftHandSideExpression arguments ) | LBRACK expression RBRACK -> ^( BYINDEX $leftHandSideExpression expression ) | DOT Identifier -> ^( BYFIELD $leftHandSideExpression Identifier ) )* )
			DebugEnterAlt(1);
			// JavaScript.g:696:2: ( memberExpression -> memberExpression ) ( arguments -> ^( CALL $leftHandSideExpression arguments ) | LBRACK expression RBRACK -> ^( BYINDEX $leftHandSideExpression expression ) | DOT Identifier -> ^( BYFIELD $leftHandSideExpression Identifier ) )*
			{
			DebugLocation(696, 2);
			// JavaScript.g:696:2: ( memberExpression -> memberExpression )
			DebugEnterAlt(1);
			// JavaScript.g:697:3: memberExpression
			{
			DebugLocation(697, 3);
			PushFollow(Follow._memberExpression_in_leftHandSideExpression3437);
			memberExpression51=memberExpression();
			PopFollow();

			stream_memberExpression.Add(memberExpression51.Tree);


			{
			// AST REWRITE
			// elements: memberExpression
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			retval.Tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

			root_0 = (object)adaptor.Nil();
			// 697:22: -> memberExpression
			{
				DebugLocation(697, 25);
				adaptor.AddChild(root_0, stream_memberExpression.NextTree());

			}

			retval.Tree = root_0;
			}

			}

			DebugLocation(699, 2);
			// JavaScript.g:699:2: ( arguments -> ^( CALL $leftHandSideExpression arguments ) | LBRACK expression RBRACK -> ^( BYINDEX $leftHandSideExpression expression ) | DOT Identifier -> ^( BYFIELD $leftHandSideExpression Identifier ) )*
			try { DebugEnterSubRule(14);
			while (true)
			{
				int alt14=4;
				try { DebugEnterDecision(14, false);
				switch (input.LA(1))
				{
				case LPAREN:
					{
					alt14 = 1;
					}
					break;
				case LBRACK:
					{
					alt14 = 2;
					}
					break;
				case DOT:
					{
					alt14 = 3;
					}
					break;
				}

				} finally { DebugExitDecision(14); }
				switch ( alt14 )
				{
				case 1:
					DebugEnterAlt(1);
					// JavaScript.g:700:3: arguments
					{
					DebugLocation(700, 3);
					PushFollow(Follow._arguments_in_leftHandSideExpression3453);
					arguments52=arguments();
					PopFollow();

					stream_arguments.Add(arguments52.Tree);


					{
					// AST REWRITE
					// elements: leftHandSideExpression, arguments
					// token labels: 
					// rule labels: retval
					// token list labels: 
					// rule list labels: 
					// wildcard labels: 
					retval.Tree = root_0;
					RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

					root_0 = (object)adaptor.Nil();
					// 700:15: -> ^( CALL $leftHandSideExpression arguments )
					{
						DebugLocation(700, 18);
						// JavaScript.g:700:18: ^( CALL $leftHandSideExpression arguments )
						{
						object root_1 = (object)adaptor.Nil();
						DebugLocation(700, 21);
						root_1 = (object)adaptor.BecomeRoot((object)adaptor.Create(CALL, "CALL"), root_1);

						DebugLocation(700, 27);
						adaptor.AddChild(root_1, stream_retval.NextTree());
						DebugLocation(700, 50);
						adaptor.AddChild(root_1, stream_arguments.NextTree());

						adaptor.AddChild(root_0, root_1);
						}

					}

					retval.Tree = root_0;
					}

					}
					break;
				case 2:
					DebugEnterAlt(2);
					// JavaScript.g:701:5: LBRACK expression RBRACK
					{
					DebugLocation(701, 5);
					LBRACK53=(IToken)Match(input,LBRACK,Follow._LBRACK_in_leftHandSideExpression3474);  
					stream_LBRACK.Add(LBRACK53);

					DebugLocation(701, 12);
					PushFollow(Follow._expression_in_leftHandSideExpression3476);
					expression54=expression();
					PopFollow();

					stream_expression.Add(expression54.Tree);
					DebugLocation(701, 23);
					RBRACK55=(IToken)Match(input,RBRACK,Follow._RBRACK_in_leftHandSideExpression3478);  
					stream_RBRACK.Add(RBRACK55);



					{
					// AST REWRITE
					// elements: leftHandSideExpression, expression
					// token labels: 
					// rule labels: retval
					// token list labels: 
					// rule list labels: 
					// wildcard labels: 
					retval.Tree = root_0;
					RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

					root_0 = (object)adaptor.Nil();
					// 701:30: -> ^( BYINDEX $leftHandSideExpression expression )
					{
						DebugLocation(701, 33);
						// JavaScript.g:701:33: ^( BYINDEX $leftHandSideExpression expression )
						{
						object root_1 = (object)adaptor.Nil();
						DebugLocation(701, 36);
						root_1 = (object)adaptor.BecomeRoot((object)adaptor.Create(BYINDEX, "BYINDEX"), root_1);

						DebugLocation(701, 45);
						adaptor.AddChild(root_1, stream_retval.NextTree());
						DebugLocation(701, 68);
						adaptor.AddChild(root_1, stream_expression.NextTree());

						adaptor.AddChild(root_0, root_1);
						}

					}

					retval.Tree = root_0;
					}

					}
					break;
				case 3:
					DebugEnterAlt(3);
					// JavaScript.g:702:5: DOT Identifier
					{
					DebugLocation(702, 5);
					DOT56=(IToken)Match(input,DOT,Follow._DOT_in_leftHandSideExpression3497);  
					stream_DOT.Add(DOT56);

					DebugLocation(702, 9);
					Identifier57=(IToken)Match(input,Identifier,Follow._Identifier_in_leftHandSideExpression3499);  
					stream_Identifier.Add(Identifier57);



					{
					// AST REWRITE
					// elements: leftHandSideExpression, Identifier
					// token labels: 
					// rule labels: retval
					// token list labels: 
					// rule list labels: 
					// wildcard labels: 
					retval.Tree = root_0;
					RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

					root_0 = (object)adaptor.Nil();
					// 702:21: -> ^( BYFIELD $leftHandSideExpression Identifier )
					{
						DebugLocation(702, 24);
						// JavaScript.g:702:24: ^( BYFIELD $leftHandSideExpression Identifier )
						{
						object root_1 = (object)adaptor.Nil();
						DebugLocation(702, 27);
						root_1 = (object)adaptor.BecomeRoot((object)adaptor.Create(BYFIELD, "BYFIELD"), root_1);

						DebugLocation(702, 36);
						adaptor.AddChild(root_1, stream_retval.NextTree());
						DebugLocation(702, 59);
						adaptor.AddChild(root_1, stream_Identifier.NextNode());

						adaptor.AddChild(root_0, root_1);
						}

					}

					retval.Tree = root_0;
					}

					}
					break;

				default:
					goto loop14;
				}
			}

			loop14:
				;

			} finally { DebugExitSubRule(14); }


			}

			retval.Stop = (IToken)input.LT(-1);

			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);

		}
		 
		finally
		{
			TraceOut("leftHandSideExpression", 18);
			LeaveRule("leftHandSideExpression", 18);
			LeaveRule_leftHandSideExpression();
		}
		DebugLocation(704, 1);
		} finally { DebugExitRule(GrammarFileName, "leftHandSideExpression"); }
		return retval;

	}
	// $ANTLR end "leftHandSideExpression"

	partial void EnterRule_postfixExpression();
	partial void LeaveRule_postfixExpression();
	// $ANTLR start "postfixExpression"
	// JavaScript.g:716:1: postfixExpression : leftHandSideExpression ( postfixOperator ^)? ;
	[GrammarRule("postfixExpression")]
	private AstParserRuleReturnScope<object, IToken> postfixExpression()
	{
		EnterRule_postfixExpression();
		EnterRule("postfixExpression", 19);
		TraceIn("postfixExpression", 19);
		AstParserRuleReturnScope<object, IToken> retval = new AstParserRuleReturnScope<object, IToken>();
		retval.Start = (IToken)input.LT(1);

		object root_0 = default(object);

		AstParserRuleReturnScope<object, IToken> leftHandSideExpression58 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> postfixOperator59 = default(AstParserRuleReturnScope<object, IToken>);

		try { DebugEnterRule(GrammarFileName, "postfixExpression");
		DebugLocation(716, 1);
		try
		{
			// JavaScript.g:717:2: ( leftHandSideExpression ( postfixOperator ^)? )
			DebugEnterAlt(1);
			// JavaScript.g:717:4: leftHandSideExpression ( postfixOperator ^)?
			{
			root_0 = (object)adaptor.Nil();

			DebugLocation(717, 4);
			PushFollow(Follow._leftHandSideExpression_in_postfixExpression3534);
			leftHandSideExpression58=leftHandSideExpression();
			PopFollow();

			adaptor.AddChild(root_0, leftHandSideExpression58.Tree);
			DebugLocation(717, 27);
			 if (input.LA(1) == INC || input.LA(1) == DEC) PromoteEol(null); 
			DebugLocation(717, 95);
			// JavaScript.g:717:95: ( postfixOperator ^)?
			int alt15=2;
			try { DebugEnterSubRule(15);
			try { DebugEnterDecision(15, false);
			int LA15_1 = input.LA(1);

			if ((LA15_1==DEC||LA15_1==INC))
			{
				alt15 = 1;
			}
			} finally { DebugExitDecision(15); }
			switch (alt15)
			{
			case 1:
				DebugEnterAlt(1);
				// JavaScript.g:717:97: postfixOperator ^
				{
				DebugLocation(717, 112);
				PushFollow(Follow._postfixOperator_in_postfixExpression3540);
				postfixOperator59=postfixOperator();
				PopFollow();

				root_0 = (object)adaptor.BecomeRoot(postfixOperator59.Tree, root_0);

				}
				break;

			}
			} finally { DebugExitSubRule(15); }


			}

			retval.Stop = (IToken)input.LT(-1);

			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);

		}
		 
		finally
		{
			TraceOut("postfixExpression", 19);
			LeaveRule("postfixExpression", 19);
			LeaveRule_postfixExpression();
		}
		DebugLocation(718, 1);
		} finally { DebugExitRule(GrammarFileName, "postfixExpression"); }
		return retval;

	}
	// $ANTLR end "postfixExpression"

	partial void EnterRule_postfixOperator();
	partial void LeaveRule_postfixOperator();
	// $ANTLR start "postfixOperator"
	// JavaScript.g:720:1: postfixOperator : (op= INC |op= DEC );
	[GrammarRule("postfixOperator")]
	private AstParserRuleReturnScope<object, IToken> postfixOperator()
	{
		EnterRule_postfixOperator();
		EnterRule("postfixOperator", 20);
		TraceIn("postfixOperator", 20);
		AstParserRuleReturnScope<object, IToken> retval = new AstParserRuleReturnScope<object, IToken>();
		retval.Start = (IToken)input.LT(1);

		object root_0 = default(object);

		IToken op = default(IToken);

		object op_tree = default(object);
		try { DebugEnterRule(GrammarFileName, "postfixOperator");
		DebugLocation(720, 1);
		try
		{
			// JavaScript.g:721:2: (op= INC |op= DEC )
			int alt16=2;
			try { DebugEnterDecision(16, false);
			int LA16_1 = input.LA(1);

			if ((LA16_1==INC))
			{
				alt16 = 1;
			}
			else if ((LA16_1==DEC))
			{
				alt16 = 2;
			}
			else
			{
				NoViableAltException nvae = new NoViableAltException("", 16, 0, input, 1);
				DebugRecognitionException(nvae);
				throw nvae;
			}
			} finally { DebugExitDecision(16); }
			switch (alt16)
			{
			case 1:
				DebugEnterAlt(1);
				// JavaScript.g:721:4: op= INC
				{
				root_0 = (object)adaptor.Nil();

				DebugLocation(721, 6);
				op=(IToken)Match(input,INC,Follow._INC_in_postfixOperator3558); 
				op_tree = (object)adaptor.Create(op);
				adaptor.AddChild(root_0, op_tree);
				DebugLocation(721, 11);
				 op.Type = PINC; 

				}
				break;
			case 2:
				DebugEnterAlt(2);
				// JavaScript.g:722:4: op= DEC
				{
				root_0 = (object)adaptor.Nil();

				DebugLocation(722, 6);
				op=(IToken)Match(input,DEC,Follow._DEC_in_postfixOperator3567); 
				op_tree = (object)adaptor.Create(op);
				adaptor.AddChild(root_0, op_tree);
				DebugLocation(722, 11);
				 op.Type = PDEC; 

				}
				break;

			}
			retval.Stop = (IToken)input.LT(-1);

			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);

		}
		 
		finally
		{
			TraceOut("postfixOperator", 20);
			LeaveRule("postfixOperator", 20);
			LeaveRule_postfixOperator();
		}
		DebugLocation(723, 1);
		} finally { DebugExitRule(GrammarFileName, "postfixOperator"); }
		return retval;

	}
	// $ANTLR end "postfixOperator"

	partial void EnterRule_unaryExpression();
	partial void LeaveRule_unaryExpression();
	// $ANTLR start "unaryExpression"
	// JavaScript.g:729:1: unaryExpression : ( postfixExpression | unaryOperator ^ unaryExpression );
	[GrammarRule("unaryExpression")]
	private AstParserRuleReturnScope<object, IToken> unaryExpression()
	{
		EnterRule_unaryExpression();
		EnterRule("unaryExpression", 21);
		TraceIn("unaryExpression", 21);
		AstParserRuleReturnScope<object, IToken> retval = new AstParserRuleReturnScope<object, IToken>();
		retval.Start = (IToken)input.LT(1);

		object root_0 = default(object);

		AstParserRuleReturnScope<object, IToken> postfixExpression60 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> unaryOperator61 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> unaryExpression62 = default(AstParserRuleReturnScope<object, IToken>);

		try { DebugEnterRule(GrammarFileName, "unaryExpression");
		DebugLocation(729, 1);
		try
		{
			// JavaScript.g:730:2: ( postfixExpression | unaryOperator ^ unaryExpression )
			int alt17=2;
			try { DebugEnterDecision(17, false);
			int LA17_1 = input.LA(1);

			if ((LA17_1==DecimalLiteral||LA17_1==FALSE||LA17_1==FUNCTION||LA17_1==HexIntegerLiteral||LA17_1==Identifier||(LA17_1>=LBRACE && LA17_1<=LBRACK)||LA17_1==LPAREN||LA17_1==NEW||LA17_1==NULL||LA17_1==OctalIntegerLiteral||LA17_1==RegularExpressionLiteral||LA17_1==StringLiteral||LA17_1==THIS||LA17_1==TRUE))
			{
				alt17 = 1;
			}
			else if ((LA17_1==ADD||LA17_1==DEC||LA17_1==DELETE||LA17_1==INC||LA17_1==INV||LA17_1==NOT||LA17_1==SUB||LA17_1==TYPEOF||LA17_1==VOID))
			{
				alt17 = 2;
			}
			else
			{
				NoViableAltException nvae = new NoViableAltException("", 17, 0, input, 1);
				DebugRecognitionException(nvae);
				throw nvae;
			}
			} finally { DebugExitDecision(17); }
			switch (alt17)
			{
			case 1:
				DebugEnterAlt(1);
				// JavaScript.g:730:4: postfixExpression
				{
				root_0 = (object)adaptor.Nil();

				DebugLocation(730, 4);
				PushFollow(Follow._postfixExpression_in_unaryExpression3584);
				postfixExpression60=postfixExpression();
				PopFollow();

				adaptor.AddChild(root_0, postfixExpression60.Tree);

				}
				break;
			case 2:
				DebugEnterAlt(2);
				// JavaScript.g:731:4: unaryOperator ^ unaryExpression
				{
				root_0 = (object)adaptor.Nil();

				DebugLocation(731, 17);
				PushFollow(Follow._unaryOperator_in_unaryExpression3589);
				unaryOperator61=unaryOperator();
				PopFollow();

				root_0 = (object)adaptor.BecomeRoot(unaryOperator61.Tree, root_0);
				DebugLocation(731, 19);
				PushFollow(Follow._unaryExpression_in_unaryExpression3592);
				unaryExpression62=unaryExpression();
				PopFollow();

				adaptor.AddChild(root_0, unaryExpression62.Tree);

				}
				break;

			}
			retval.Stop = (IToken)input.LT(-1);

			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);

		}
		 
		finally
		{
			TraceOut("unaryExpression", 21);
			LeaveRule("unaryExpression", 21);
			LeaveRule_unaryExpression();
		}
		DebugLocation(732, 1);
		} finally { DebugExitRule(GrammarFileName, "unaryExpression"); }
		return retval;

	}
	// $ANTLR end "unaryExpression"

	partial void EnterRule_unaryOperator();
	partial void LeaveRule_unaryOperator();
	// $ANTLR start "unaryOperator"
	// JavaScript.g:734:1: unaryOperator : ( DELETE | VOID | TYPEOF | INC | DEC |op= ADD |op= SUB | INV | NOT );
	[GrammarRule("unaryOperator")]
	private AstParserRuleReturnScope<object, IToken> unaryOperator()
	{
		EnterRule_unaryOperator();
		EnterRule("unaryOperator", 22);
		TraceIn("unaryOperator", 22);
		AstParserRuleReturnScope<object, IToken> retval = new AstParserRuleReturnScope<object, IToken>();
		retval.Start = (IToken)input.LT(1);

		object root_0 = default(object);

		IToken op = default(IToken);
		IToken DELETE63 = default(IToken);
		IToken VOID64 = default(IToken);
		IToken TYPEOF65 = default(IToken);
		IToken INC66 = default(IToken);
		IToken DEC67 = default(IToken);
		IToken INV68 = default(IToken);
		IToken NOT69 = default(IToken);

		object op_tree = default(object);
		object DELETE63_tree = default(object);
		object VOID64_tree = default(object);
		object TYPEOF65_tree = default(object);
		object INC66_tree = default(object);
		object DEC67_tree = default(object);
		object INV68_tree = default(object);
		object NOT69_tree = default(object);
		try { DebugEnterRule(GrammarFileName, "unaryOperator");
		DebugLocation(734, 1);
		try
		{
			// JavaScript.g:735:2: ( DELETE | VOID | TYPEOF | INC | DEC |op= ADD |op= SUB | INV | NOT )
			int alt18=9;
			try { DebugEnterDecision(18, false);
			switch (input.LA(1))
			{
			case DELETE:
				{
				alt18 = 1;
				}
				break;
			case VOID:
				{
				alt18 = 2;
				}
				break;
			case TYPEOF:
				{
				alt18 = 3;
				}
				break;
			case INC:
				{
				alt18 = 4;
				}
				break;
			case DEC:
				{
				alt18 = 5;
				}
				break;
			case ADD:
				{
				alt18 = 6;
				}
				break;
			case SUB:
				{
				alt18 = 7;
				}
				break;
			case INV:
				{
				alt18 = 8;
				}
				break;
			case NOT:
				{
				alt18 = 9;
				}
				break;
			default:
				{
					NoViableAltException nvae = new NoViableAltException("", 18, 0, input, 1);
					DebugRecognitionException(nvae);
					throw nvae;
				}
			}

			} finally { DebugExitDecision(18); }
			switch (alt18)
			{
			case 1:
				DebugEnterAlt(1);
				// JavaScript.g:735:4: DELETE
				{
				root_0 = (object)adaptor.Nil();

				DebugLocation(735, 4);
				DELETE63=(IToken)Match(input,DELETE,Follow._DELETE_in_unaryOperator3604); 
				DELETE63_tree = (object)adaptor.Create(DELETE63);
				adaptor.AddChild(root_0, DELETE63_tree);

				}
				break;
			case 2:
				DebugEnterAlt(2);
				// JavaScript.g:736:4: VOID
				{
				root_0 = (object)adaptor.Nil();

				DebugLocation(736, 4);
				VOID64=(IToken)Match(input,VOID,Follow._VOID_in_unaryOperator3609); 
				VOID64_tree = (object)adaptor.Create(VOID64);
				adaptor.AddChild(root_0, VOID64_tree);

				}
				break;
			case 3:
				DebugEnterAlt(3);
				// JavaScript.g:737:4: TYPEOF
				{
				root_0 = (object)adaptor.Nil();

				DebugLocation(737, 4);
				TYPEOF65=(IToken)Match(input,TYPEOF,Follow._TYPEOF_in_unaryOperator3614); 
				TYPEOF65_tree = (object)adaptor.Create(TYPEOF65);
				adaptor.AddChild(root_0, TYPEOF65_tree);

				}
				break;
			case 4:
				DebugEnterAlt(4);
				// JavaScript.g:738:4: INC
				{
				root_0 = (object)adaptor.Nil();

				DebugLocation(738, 4);
				INC66=(IToken)Match(input,INC,Follow._INC_in_unaryOperator3619); 
				INC66_tree = (object)adaptor.Create(INC66);
				adaptor.AddChild(root_0, INC66_tree);

				}
				break;
			case 5:
				DebugEnterAlt(5);
				// JavaScript.g:739:4: DEC
				{
				root_0 = (object)adaptor.Nil();

				DebugLocation(739, 4);
				DEC67=(IToken)Match(input,DEC,Follow._DEC_in_unaryOperator3624); 
				DEC67_tree = (object)adaptor.Create(DEC67);
				adaptor.AddChild(root_0, DEC67_tree);

				}
				break;
			case 6:
				DebugEnterAlt(6);
				// JavaScript.g:740:4: op= ADD
				{
				root_0 = (object)adaptor.Nil();

				DebugLocation(740, 6);
				op=(IToken)Match(input,ADD,Follow._ADD_in_unaryOperator3631); 
				op_tree = (object)adaptor.Create(op);
				adaptor.AddChild(root_0, op_tree);
				DebugLocation(740, 11);
				 op.Type = POS; 

				}
				break;
			case 7:
				DebugEnterAlt(7);
				// JavaScript.g:741:4: op= SUB
				{
				root_0 = (object)adaptor.Nil();

				DebugLocation(741, 6);
				op=(IToken)Match(input,SUB,Follow._SUB_in_unaryOperator3640); 
				op_tree = (object)adaptor.Create(op);
				adaptor.AddChild(root_0, op_tree);
				DebugLocation(741, 11);
				 op.Type = NEG; 

				}
				break;
			case 8:
				DebugEnterAlt(8);
				// JavaScript.g:742:4: INV
				{
				root_0 = (object)adaptor.Nil();

				DebugLocation(742, 4);
				INV68=(IToken)Match(input,INV,Follow._INV_in_unaryOperator3647); 
				INV68_tree = (object)adaptor.Create(INV68);
				adaptor.AddChild(root_0, INV68_tree);

				}
				break;
			case 9:
				DebugEnterAlt(9);
				// JavaScript.g:743:4: NOT
				{
				root_0 = (object)adaptor.Nil();

				DebugLocation(743, 4);
				NOT69=(IToken)Match(input,NOT,Follow._NOT_in_unaryOperator3652); 
				NOT69_tree = (object)adaptor.Create(NOT69);
				adaptor.AddChild(root_0, NOT69_tree);

				}
				break;

			}
			retval.Stop = (IToken)input.LT(-1);

			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);

		}
		 
		finally
		{
			TraceOut("unaryOperator", 22);
			LeaveRule("unaryOperator", 22);
			LeaveRule_unaryOperator();
		}
		DebugLocation(744, 1);
		} finally { DebugExitRule(GrammarFileName, "unaryOperator"); }
		return retval;

	}
	// $ANTLR end "unaryOperator"

	partial void EnterRule_multiplicativeExpression();
	partial void LeaveRule_multiplicativeExpression();
	// $ANTLR start "multiplicativeExpression"
	// JavaScript.g:750:1: multiplicativeExpression : unaryExpression ( ( MUL | DIV | MOD ) ^ unaryExpression )* ;
	[GrammarRule("multiplicativeExpression")]
	private AstParserRuleReturnScope<object, IToken> multiplicativeExpression()
	{
		EnterRule_multiplicativeExpression();
		EnterRule("multiplicativeExpression", 23);
		TraceIn("multiplicativeExpression", 23);
		AstParserRuleReturnScope<object, IToken> retval = new AstParserRuleReturnScope<object, IToken>();
		retval.Start = (IToken)input.LT(1);

		object root_0 = default(object);

		IToken set71 = default(IToken);
		AstParserRuleReturnScope<object, IToken> unaryExpression70 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> unaryExpression72 = default(AstParserRuleReturnScope<object, IToken>);

		object set71_tree = default(object);
		try { DebugEnterRule(GrammarFileName, "multiplicativeExpression");
		DebugLocation(750, 1);
		try
		{
			// JavaScript.g:751:2: ( unaryExpression ( ( MUL | DIV | MOD ) ^ unaryExpression )* )
			DebugEnterAlt(1);
			// JavaScript.g:751:4: unaryExpression ( ( MUL | DIV | MOD ) ^ unaryExpression )*
			{
			root_0 = (object)adaptor.Nil();

			DebugLocation(751, 4);
			PushFollow(Follow._unaryExpression_in_multiplicativeExpression3667);
			unaryExpression70=unaryExpression();
			PopFollow();

			adaptor.AddChild(root_0, unaryExpression70.Tree);
			DebugLocation(751, 20);
			// JavaScript.g:751:20: ( ( MUL | DIV | MOD ) ^ unaryExpression )*
			try { DebugEnterSubRule(19);
			while (true)
			{
				int alt19=2;
				try { DebugEnterDecision(19, false);
				int LA19_1 = input.LA(1);

				if ((LA19_1==DIV||LA19_1==MOD||LA19_1==MUL))
				{
					alt19 = 1;
				}


				} finally { DebugExitDecision(19); }
				switch ( alt19 )
				{
				case 1:
					DebugEnterAlt(1);
					// JavaScript.g:751:22: ( MUL | DIV | MOD ) ^ unaryExpression
					{
					DebugLocation(751, 41);

					set71=(IToken)input.LT(1);
					set71=(IToken)input.LT(1);
					if (input.LA(1)==DIV||input.LA(1)==MOD||input.LA(1)==MUL)
					{
						input.Consume();
						root_0 = (object)adaptor.BecomeRoot((object)adaptor.Create(set71), root_0);
						state.errorRecovery=false;
					}
					else
					{
						MismatchedSetException mse = new MismatchedSetException(null,input);
						DebugRecognitionException(mse);
						throw mse;
					}

					DebugLocation(751, 43);
					PushFollow(Follow._unaryExpression_in_multiplicativeExpression3686);
					unaryExpression72=unaryExpression();
					PopFollow();

					adaptor.AddChild(root_0, unaryExpression72.Tree);

					}
					break;

				default:
					goto loop19;
				}
			}

			loop19:
				;

			} finally { DebugExitSubRule(19); }


			}

			retval.Stop = (IToken)input.LT(-1);

			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);

		}
		 
		finally
		{
			TraceOut("multiplicativeExpression", 23);
			LeaveRule("multiplicativeExpression", 23);
			LeaveRule_multiplicativeExpression();
		}
		DebugLocation(752, 1);
		} finally { DebugExitRule(GrammarFileName, "multiplicativeExpression"); }
		return retval;

	}
	// $ANTLR end "multiplicativeExpression"

	partial void EnterRule_additiveExpression();
	partial void LeaveRule_additiveExpression();
	// $ANTLR start "additiveExpression"
	// JavaScript.g:758:1: additiveExpression : multiplicativeExpression ( ( ADD | SUB ) ^ multiplicativeExpression )* ;
	[GrammarRule("additiveExpression")]
	private AstParserRuleReturnScope<object, IToken> additiveExpression()
	{
		EnterRule_additiveExpression();
		EnterRule("additiveExpression", 24);
		TraceIn("additiveExpression", 24);
		AstParserRuleReturnScope<object, IToken> retval = new AstParserRuleReturnScope<object, IToken>();
		retval.Start = (IToken)input.LT(1);

		object root_0 = default(object);

		IToken set74 = default(IToken);
		AstParserRuleReturnScope<object, IToken> multiplicativeExpression73 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> multiplicativeExpression75 = default(AstParserRuleReturnScope<object, IToken>);

		object set74_tree = default(object);
		try { DebugEnterRule(GrammarFileName, "additiveExpression");
		DebugLocation(758, 1);
		try
		{
			// JavaScript.g:759:2: ( multiplicativeExpression ( ( ADD | SUB ) ^ multiplicativeExpression )* )
			DebugEnterAlt(1);
			// JavaScript.g:759:4: multiplicativeExpression ( ( ADD | SUB ) ^ multiplicativeExpression )*
			{
			root_0 = (object)adaptor.Nil();

			DebugLocation(759, 4);
			PushFollow(Follow._multiplicativeExpression_in_additiveExpression3704);
			multiplicativeExpression73=multiplicativeExpression();
			PopFollow();

			adaptor.AddChild(root_0, multiplicativeExpression73.Tree);
			DebugLocation(759, 29);
			// JavaScript.g:759:29: ( ( ADD | SUB ) ^ multiplicativeExpression )*
			try { DebugEnterSubRule(20);
			while (true)
			{
				int alt20=2;
				try { DebugEnterDecision(20, false);
				int LA20_1 = input.LA(1);

				if ((LA20_1==ADD||LA20_1==SUB))
				{
					alt20 = 1;
				}


				} finally { DebugExitDecision(20); }
				switch ( alt20 )
				{
				case 1:
					DebugEnterAlt(1);
					// JavaScript.g:759:31: ( ADD | SUB ) ^ multiplicativeExpression
					{
					DebugLocation(759, 44);

					set74=(IToken)input.LT(1);
					set74=(IToken)input.LT(1);
					if (input.LA(1)==ADD||input.LA(1)==SUB)
					{
						input.Consume();
						root_0 = (object)adaptor.BecomeRoot((object)adaptor.Create(set74), root_0);
						state.errorRecovery=false;
					}
					else
					{
						MismatchedSetException mse = new MismatchedSetException(null,input);
						DebugRecognitionException(mse);
						throw mse;
					}

					DebugLocation(759, 46);
					PushFollow(Follow._multiplicativeExpression_in_additiveExpression3719);
					multiplicativeExpression75=multiplicativeExpression();
					PopFollow();

					adaptor.AddChild(root_0, multiplicativeExpression75.Tree);

					}
					break;

				default:
					goto loop20;
				}
			}

			loop20:
				;

			} finally { DebugExitSubRule(20); }


			}

			retval.Stop = (IToken)input.LT(-1);

			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);

		}
		 
		finally
		{
			TraceOut("additiveExpression", 24);
			LeaveRule("additiveExpression", 24);
			LeaveRule_additiveExpression();
		}
		DebugLocation(760, 1);
		} finally { DebugExitRule(GrammarFileName, "additiveExpression"); }
		return retval;

	}
	// $ANTLR end "additiveExpression"

	partial void EnterRule_shiftExpression();
	partial void LeaveRule_shiftExpression();
	// $ANTLR start "shiftExpression"
	// JavaScript.g:766:1: shiftExpression : additiveExpression ( ( SHL | SHR | SHU ) ^ additiveExpression )* ;
	[GrammarRule("shiftExpression")]
	private AstParserRuleReturnScope<object, IToken> shiftExpression()
	{
		EnterRule_shiftExpression();
		EnterRule("shiftExpression", 25);
		TraceIn("shiftExpression", 25);
		AstParserRuleReturnScope<object, IToken> retval = new AstParserRuleReturnScope<object, IToken>();
		retval.Start = (IToken)input.LT(1);

		object root_0 = default(object);

		IToken set77 = default(IToken);
		AstParserRuleReturnScope<object, IToken> additiveExpression76 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> additiveExpression78 = default(AstParserRuleReturnScope<object, IToken>);

		object set77_tree = default(object);
		try { DebugEnterRule(GrammarFileName, "shiftExpression");
		DebugLocation(766, 1);
		try
		{
			// JavaScript.g:767:2: ( additiveExpression ( ( SHL | SHR | SHU ) ^ additiveExpression )* )
			DebugEnterAlt(1);
			// JavaScript.g:767:4: additiveExpression ( ( SHL | SHR | SHU ) ^ additiveExpression )*
			{
			root_0 = (object)adaptor.Nil();

			DebugLocation(767, 4);
			PushFollow(Follow._additiveExpression_in_shiftExpression3738);
			additiveExpression76=additiveExpression();
			PopFollow();

			adaptor.AddChild(root_0, additiveExpression76.Tree);
			DebugLocation(767, 23);
			// JavaScript.g:767:23: ( ( SHL | SHR | SHU ) ^ additiveExpression )*
			try { DebugEnterSubRule(21);
			while (true)
			{
				int alt21=2;
				try { DebugEnterDecision(21, false);
				int LA21_1 = input.LA(1);

				if ((LA21_1==SHL||LA21_1==SHR||LA21_1==SHU))
				{
					alt21 = 1;
				}


				} finally { DebugExitDecision(21); }
				switch ( alt21 )
				{
				case 1:
					DebugEnterAlt(1);
					// JavaScript.g:767:25: ( SHL | SHR | SHU ) ^ additiveExpression
					{
					DebugLocation(767, 44);

					set77=(IToken)input.LT(1);
					set77=(IToken)input.LT(1);
					if (input.LA(1)==SHL||input.LA(1)==SHR||input.LA(1)==SHU)
					{
						input.Consume();
						root_0 = (object)adaptor.BecomeRoot((object)adaptor.Create(set77), root_0);
						state.errorRecovery=false;
					}
					else
					{
						MismatchedSetException mse = new MismatchedSetException(null,input);
						DebugRecognitionException(mse);
						throw mse;
					}

					DebugLocation(767, 46);
					PushFollow(Follow._additiveExpression_in_shiftExpression3757);
					additiveExpression78=additiveExpression();
					PopFollow();

					adaptor.AddChild(root_0, additiveExpression78.Tree);

					}
					break;

				default:
					goto loop21;
				}
			}

			loop21:
				;

			} finally { DebugExitSubRule(21); }


			}

			retval.Stop = (IToken)input.LT(-1);

			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);

		}
		 
		finally
		{
			TraceOut("shiftExpression", 25);
			LeaveRule("shiftExpression", 25);
			LeaveRule_shiftExpression();
		}
		DebugLocation(768, 1);
		} finally { DebugExitRule(GrammarFileName, "shiftExpression"); }
		return retval;

	}
	// $ANTLR end "shiftExpression"

	partial void EnterRule_relationalExpression();
	partial void LeaveRule_relationalExpression();
	// $ANTLR start "relationalExpression"
	// JavaScript.g:774:1: relationalExpression : shiftExpression ( ( LT | GT | LTE | GTE | INSTANCEOF | IN ) ^ shiftExpression )* ;
	[GrammarRule("relationalExpression")]
	private AstParserRuleReturnScope<object, IToken> relationalExpression()
	{
		EnterRule_relationalExpression();
		EnterRule("relationalExpression", 26);
		TraceIn("relationalExpression", 26);
		AstParserRuleReturnScope<object, IToken> retval = new AstParserRuleReturnScope<object, IToken>();
		retval.Start = (IToken)input.LT(1);

		object root_0 = default(object);

		IToken set80 = default(IToken);
		AstParserRuleReturnScope<object, IToken> shiftExpression79 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> shiftExpression81 = default(AstParserRuleReturnScope<object, IToken>);

		object set80_tree = default(object);
		try { DebugEnterRule(GrammarFileName, "relationalExpression");
		DebugLocation(774, 1);
		try
		{
			// JavaScript.g:775:2: ( shiftExpression ( ( LT | GT | LTE | GTE | INSTANCEOF | IN ) ^ shiftExpression )* )
			DebugEnterAlt(1);
			// JavaScript.g:775:4: shiftExpression ( ( LT | GT | LTE | GTE | INSTANCEOF | IN ) ^ shiftExpression )*
			{
			root_0 = (object)adaptor.Nil();

			DebugLocation(775, 4);
			PushFollow(Follow._shiftExpression_in_relationalExpression3776);
			shiftExpression79=shiftExpression();
			PopFollow();

			adaptor.AddChild(root_0, shiftExpression79.Tree);
			DebugLocation(775, 20);
			// JavaScript.g:775:20: ( ( LT | GT | LTE | GTE | INSTANCEOF | IN ) ^ shiftExpression )*
			try { DebugEnterSubRule(22);
			while (true)
			{
				int alt22=2;
				try { DebugEnterDecision(22, false);
				int LA22_1 = input.LA(1);

				if (((LA22_1>=GT && LA22_1<=GTE)||LA22_1==IN||LA22_1==INSTANCEOF||(LA22_1>=LT && LA22_1<=LTE)))
				{
					alt22 = 1;
				}


				} finally { DebugExitDecision(22); }
				switch ( alt22 )
				{
				case 1:
					DebugEnterAlt(1);
					// JavaScript.g:775:22: ( LT | GT | LTE | GTE | INSTANCEOF | IN ) ^ shiftExpression
					{
					DebugLocation(775, 63);

					set80=(IToken)input.LT(1);
					set80=(IToken)input.LT(1);
					if ((input.LA(1)>=GT && input.LA(1)<=GTE)||input.LA(1)==IN||input.LA(1)==INSTANCEOF||(input.LA(1)>=LT && input.LA(1)<=LTE))
					{
						input.Consume();
						root_0 = (object)adaptor.BecomeRoot((object)adaptor.Create(set80), root_0);
						state.errorRecovery=false;
					}
					else
					{
						MismatchedSetException mse = new MismatchedSetException(null,input);
						DebugRecognitionException(mse);
						throw mse;
					}

					DebugLocation(775, 65);
					PushFollow(Follow._shiftExpression_in_relationalExpression3807);
					shiftExpression81=shiftExpression();
					PopFollow();

					adaptor.AddChild(root_0, shiftExpression81.Tree);

					}
					break;

				default:
					goto loop22;
				}
			}

			loop22:
				;

			} finally { DebugExitSubRule(22); }


			}

			retval.Stop = (IToken)input.LT(-1);

			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);

		}
		 
		finally
		{
			TraceOut("relationalExpression", 26);
			LeaveRule("relationalExpression", 26);
			LeaveRule_relationalExpression();
		}
		DebugLocation(776, 1);
		} finally { DebugExitRule(GrammarFileName, "relationalExpression"); }
		return retval;

	}
	// $ANTLR end "relationalExpression"

	partial void EnterRule_relationalExpressionNoIn();
	partial void LeaveRule_relationalExpressionNoIn();
	// $ANTLR start "relationalExpressionNoIn"
	// JavaScript.g:778:1: relationalExpressionNoIn : shiftExpression ( ( LT | GT | LTE | GTE | INSTANCEOF ) ^ shiftExpression )* ;
	[GrammarRule("relationalExpressionNoIn")]
	private AstParserRuleReturnScope<object, IToken> relationalExpressionNoIn()
	{
		EnterRule_relationalExpressionNoIn();
		EnterRule("relationalExpressionNoIn", 27);
		TraceIn("relationalExpressionNoIn", 27);
		AstParserRuleReturnScope<object, IToken> retval = new AstParserRuleReturnScope<object, IToken>();
		retval.Start = (IToken)input.LT(1);

		object root_0 = default(object);

		IToken set83 = default(IToken);
		AstParserRuleReturnScope<object, IToken> shiftExpression82 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> shiftExpression84 = default(AstParserRuleReturnScope<object, IToken>);

		object set83_tree = default(object);
		try { DebugEnterRule(GrammarFileName, "relationalExpressionNoIn");
		DebugLocation(778, 1);
		try
		{
			// JavaScript.g:779:2: ( shiftExpression ( ( LT | GT | LTE | GTE | INSTANCEOF ) ^ shiftExpression )* )
			DebugEnterAlt(1);
			// JavaScript.g:779:4: shiftExpression ( ( LT | GT | LTE | GTE | INSTANCEOF ) ^ shiftExpression )*
			{
			root_0 = (object)adaptor.Nil();

			DebugLocation(779, 4);
			PushFollow(Follow._shiftExpression_in_relationalExpressionNoIn3821);
			shiftExpression82=shiftExpression();
			PopFollow();

			adaptor.AddChild(root_0, shiftExpression82.Tree);
			DebugLocation(779, 20);
			// JavaScript.g:779:20: ( ( LT | GT | LTE | GTE | INSTANCEOF ) ^ shiftExpression )*
			try { DebugEnterSubRule(23);
			while (true)
			{
				int alt23=2;
				try { DebugEnterDecision(23, false);
				int LA23_1 = input.LA(1);

				if (((LA23_1>=GT && LA23_1<=GTE)||LA23_1==INSTANCEOF||(LA23_1>=LT && LA23_1<=LTE)))
				{
					alt23 = 1;
				}


				} finally { DebugExitDecision(23); }
				switch ( alt23 )
				{
				case 1:
					DebugEnterAlt(1);
					// JavaScript.g:779:22: ( LT | GT | LTE | GTE | INSTANCEOF ) ^ shiftExpression
					{
					DebugLocation(779, 58);

					set83=(IToken)input.LT(1);
					set83=(IToken)input.LT(1);
					if ((input.LA(1)>=GT && input.LA(1)<=GTE)||input.LA(1)==INSTANCEOF||(input.LA(1)>=LT && input.LA(1)<=LTE))
					{
						input.Consume();
						root_0 = (object)adaptor.BecomeRoot((object)adaptor.Create(set83), root_0);
						state.errorRecovery=false;
					}
					else
					{
						MismatchedSetException mse = new MismatchedSetException(null,input);
						DebugRecognitionException(mse);
						throw mse;
					}

					DebugLocation(779, 60);
					PushFollow(Follow._shiftExpression_in_relationalExpressionNoIn3848);
					shiftExpression84=shiftExpression();
					PopFollow();

					adaptor.AddChild(root_0, shiftExpression84.Tree);

					}
					break;

				default:
					goto loop23;
				}
			}

			loop23:
				;

			} finally { DebugExitSubRule(23); }


			}

			retval.Stop = (IToken)input.LT(-1);

			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);

		}
		 
		finally
		{
			TraceOut("relationalExpressionNoIn", 27);
			LeaveRule("relationalExpressionNoIn", 27);
			LeaveRule_relationalExpressionNoIn();
		}
		DebugLocation(780, 1);
		} finally { DebugExitRule(GrammarFileName, "relationalExpressionNoIn"); }
		return retval;

	}
	// $ANTLR end "relationalExpressionNoIn"

	partial void EnterRule_equalityExpression();
	partial void LeaveRule_equalityExpression();
	// $ANTLR start "equalityExpression"
	// JavaScript.g:786:1: equalityExpression : relationalExpression ( ( EQ | NEQ | SAME | NSAME ) ^ relationalExpression )* ;
	[GrammarRule("equalityExpression")]
	private AstParserRuleReturnScope<object, IToken> equalityExpression()
	{
		EnterRule_equalityExpression();
		EnterRule("equalityExpression", 28);
		TraceIn("equalityExpression", 28);
		AstParserRuleReturnScope<object, IToken> retval = new AstParserRuleReturnScope<object, IToken>();
		retval.Start = (IToken)input.LT(1);

		object root_0 = default(object);

		IToken set86 = default(IToken);
		AstParserRuleReturnScope<object, IToken> relationalExpression85 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> relationalExpression87 = default(AstParserRuleReturnScope<object, IToken>);

		object set86_tree = default(object);
		try { DebugEnterRule(GrammarFileName, "equalityExpression");
		DebugLocation(786, 1);
		try
		{
			// JavaScript.g:787:2: ( relationalExpression ( ( EQ | NEQ | SAME | NSAME ) ^ relationalExpression )* )
			DebugEnterAlt(1);
			// JavaScript.g:787:4: relationalExpression ( ( EQ | NEQ | SAME | NSAME ) ^ relationalExpression )*
			{
			root_0 = (object)adaptor.Nil();

			DebugLocation(787, 4);
			PushFollow(Follow._relationalExpression_in_equalityExpression3867);
			relationalExpression85=relationalExpression();
			PopFollow();

			adaptor.AddChild(root_0, relationalExpression85.Tree);
			DebugLocation(787, 25);
			// JavaScript.g:787:25: ( ( EQ | NEQ | SAME | NSAME ) ^ relationalExpression )*
			try { DebugEnterSubRule(24);
			while (true)
			{
				int alt24=2;
				try { DebugEnterDecision(24, false);
				int LA24_1 = input.LA(1);

				if ((LA24_1==EQ||LA24_1==NEQ||LA24_1==NSAME||LA24_1==SAME))
				{
					alt24 = 1;
				}


				} finally { DebugExitDecision(24); }
				switch ( alt24 )
				{
				case 1:
					DebugEnterAlt(1);
					// JavaScript.g:787:27: ( EQ | NEQ | SAME | NSAME ) ^ relationalExpression
					{
					DebugLocation(787, 54);

					set86=(IToken)input.LT(1);
					set86=(IToken)input.LT(1);
					if (input.LA(1)==EQ||input.LA(1)==NEQ||input.LA(1)==NSAME||input.LA(1)==SAME)
					{
						input.Consume();
						root_0 = (object)adaptor.BecomeRoot((object)adaptor.Create(set86), root_0);
						state.errorRecovery=false;
					}
					else
					{
						MismatchedSetException mse = new MismatchedSetException(null,input);
						DebugRecognitionException(mse);
						throw mse;
					}

					DebugLocation(787, 56);
					PushFollow(Follow._relationalExpression_in_equalityExpression3890);
					relationalExpression87=relationalExpression();
					PopFollow();

					adaptor.AddChild(root_0, relationalExpression87.Tree);

					}
					break;

				default:
					goto loop24;
				}
			}

			loop24:
				;

			} finally { DebugExitSubRule(24); }


			}

			retval.Stop = (IToken)input.LT(-1);

			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);

		}
		 
		finally
		{
			TraceOut("equalityExpression", 28);
			LeaveRule("equalityExpression", 28);
			LeaveRule_equalityExpression();
		}
		DebugLocation(788, 1);
		} finally { DebugExitRule(GrammarFileName, "equalityExpression"); }
		return retval;

	}
	// $ANTLR end "equalityExpression"

	partial void EnterRule_equalityExpressionNoIn();
	partial void LeaveRule_equalityExpressionNoIn();
	// $ANTLR start "equalityExpressionNoIn"
	// JavaScript.g:790:1: equalityExpressionNoIn : relationalExpressionNoIn ( ( EQ | NEQ | SAME | NSAME ) ^ relationalExpressionNoIn )* ;
	[GrammarRule("equalityExpressionNoIn")]
	private AstParserRuleReturnScope<object, IToken> equalityExpressionNoIn()
	{
		EnterRule_equalityExpressionNoIn();
		EnterRule("equalityExpressionNoIn", 29);
		TraceIn("equalityExpressionNoIn", 29);
		AstParserRuleReturnScope<object, IToken> retval = new AstParserRuleReturnScope<object, IToken>();
		retval.Start = (IToken)input.LT(1);

		object root_0 = default(object);

		IToken set89 = default(IToken);
		AstParserRuleReturnScope<object, IToken> relationalExpressionNoIn88 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> relationalExpressionNoIn90 = default(AstParserRuleReturnScope<object, IToken>);

		object set89_tree = default(object);
		try { DebugEnterRule(GrammarFileName, "equalityExpressionNoIn");
		DebugLocation(790, 1);
		try
		{
			// JavaScript.g:791:2: ( relationalExpressionNoIn ( ( EQ | NEQ | SAME | NSAME ) ^ relationalExpressionNoIn )* )
			DebugEnterAlt(1);
			// JavaScript.g:791:4: relationalExpressionNoIn ( ( EQ | NEQ | SAME | NSAME ) ^ relationalExpressionNoIn )*
			{
			root_0 = (object)adaptor.Nil();

			DebugLocation(791, 4);
			PushFollow(Follow._relationalExpressionNoIn_in_equalityExpressionNoIn3904);
			relationalExpressionNoIn88=relationalExpressionNoIn();
			PopFollow();

			adaptor.AddChild(root_0, relationalExpressionNoIn88.Tree);
			DebugLocation(791, 29);
			// JavaScript.g:791:29: ( ( EQ | NEQ | SAME | NSAME ) ^ relationalExpressionNoIn )*
			try { DebugEnterSubRule(25);
			while (true)
			{
				int alt25=2;
				try { DebugEnterDecision(25, false);
				int LA25_1 = input.LA(1);

				if ((LA25_1==EQ||LA25_1==NEQ||LA25_1==NSAME||LA25_1==SAME))
				{
					alt25 = 1;
				}


				} finally { DebugExitDecision(25); }
				switch ( alt25 )
				{
				case 1:
					DebugEnterAlt(1);
					// JavaScript.g:791:31: ( EQ | NEQ | SAME | NSAME ) ^ relationalExpressionNoIn
					{
					DebugLocation(791, 58);

					set89=(IToken)input.LT(1);
					set89=(IToken)input.LT(1);
					if (input.LA(1)==EQ||input.LA(1)==NEQ||input.LA(1)==NSAME||input.LA(1)==SAME)
					{
						input.Consume();
						root_0 = (object)adaptor.BecomeRoot((object)adaptor.Create(set89), root_0);
						state.errorRecovery=false;
					}
					else
					{
						MismatchedSetException mse = new MismatchedSetException(null,input);
						DebugRecognitionException(mse);
						throw mse;
					}

					DebugLocation(791, 60);
					PushFollow(Follow._relationalExpressionNoIn_in_equalityExpressionNoIn3927);
					relationalExpressionNoIn90=relationalExpressionNoIn();
					PopFollow();

					adaptor.AddChild(root_0, relationalExpressionNoIn90.Tree);

					}
					break;

				default:
					goto loop25;
				}
			}

			loop25:
				;

			} finally { DebugExitSubRule(25); }


			}

			retval.Stop = (IToken)input.LT(-1);

			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);

		}
		 
		finally
		{
			TraceOut("equalityExpressionNoIn", 29);
			LeaveRule("equalityExpressionNoIn", 29);
			LeaveRule_equalityExpressionNoIn();
		}
		DebugLocation(792, 1);
		} finally { DebugExitRule(GrammarFileName, "equalityExpressionNoIn"); }
		return retval;

	}
	// $ANTLR end "equalityExpressionNoIn"

	partial void EnterRule_bitwiseANDExpression();
	partial void LeaveRule_bitwiseANDExpression();
	// $ANTLR start "bitwiseANDExpression"
	// JavaScript.g:798:1: bitwiseANDExpression : equalityExpression ( AND ^ equalityExpression )* ;
	[GrammarRule("bitwiseANDExpression")]
	private AstParserRuleReturnScope<object, IToken> bitwiseANDExpression()
	{
		EnterRule_bitwiseANDExpression();
		EnterRule("bitwiseANDExpression", 30);
		TraceIn("bitwiseANDExpression", 30);
		AstParserRuleReturnScope<object, IToken> retval = new AstParserRuleReturnScope<object, IToken>();
		retval.Start = (IToken)input.LT(1);

		object root_0 = default(object);

		IToken AND92 = default(IToken);
		AstParserRuleReturnScope<object, IToken> equalityExpression91 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> equalityExpression93 = default(AstParserRuleReturnScope<object, IToken>);

		object AND92_tree = default(object);
		try { DebugEnterRule(GrammarFileName, "bitwiseANDExpression");
		DebugLocation(798, 1);
		try
		{
			// JavaScript.g:799:2: ( equalityExpression ( AND ^ equalityExpression )* )
			DebugEnterAlt(1);
			// JavaScript.g:799:4: equalityExpression ( AND ^ equalityExpression )*
			{
			root_0 = (object)adaptor.Nil();

			DebugLocation(799, 4);
			PushFollow(Follow._equalityExpression_in_bitwiseANDExpression3947);
			equalityExpression91=equalityExpression();
			PopFollow();

			adaptor.AddChild(root_0, equalityExpression91.Tree);
			DebugLocation(799, 23);
			// JavaScript.g:799:23: ( AND ^ equalityExpression )*
			try { DebugEnterSubRule(26);
			while (true)
			{
				int alt26=2;
				try { DebugEnterDecision(26, false);
				int LA26_1 = input.LA(1);

				if ((LA26_1==AND))
				{
					alt26 = 1;
				}


				} finally { DebugExitDecision(26); }
				switch ( alt26 )
				{
				case 1:
					DebugEnterAlt(1);
					// JavaScript.g:799:25: AND ^ equalityExpression
					{
					DebugLocation(799, 28);
					AND92=(IToken)Match(input,AND,Follow._AND_in_bitwiseANDExpression3951); 
					AND92_tree = (object)adaptor.Create(AND92);
					root_0 = (object)adaptor.BecomeRoot(AND92_tree, root_0);
					DebugLocation(799, 30);
					PushFollow(Follow._equalityExpression_in_bitwiseANDExpression3954);
					equalityExpression93=equalityExpression();
					PopFollow();

					adaptor.AddChild(root_0, equalityExpression93.Tree);

					}
					break;

				default:
					goto loop26;
				}
			}

			loop26:
				;

			} finally { DebugExitSubRule(26); }


			}

			retval.Stop = (IToken)input.LT(-1);

			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);

		}
		 
		finally
		{
			TraceOut("bitwiseANDExpression", 30);
			LeaveRule("bitwiseANDExpression", 30);
			LeaveRule_bitwiseANDExpression();
		}
		DebugLocation(800, 1);
		} finally { DebugExitRule(GrammarFileName, "bitwiseANDExpression"); }
		return retval;

	}
	// $ANTLR end "bitwiseANDExpression"

	partial void EnterRule_bitwiseANDExpressionNoIn();
	partial void LeaveRule_bitwiseANDExpressionNoIn();
	// $ANTLR start "bitwiseANDExpressionNoIn"
	// JavaScript.g:802:1: bitwiseANDExpressionNoIn : equalityExpressionNoIn ( AND ^ equalityExpressionNoIn )* ;
	[GrammarRule("bitwiseANDExpressionNoIn")]
	private AstParserRuleReturnScope<object, IToken> bitwiseANDExpressionNoIn()
	{
		EnterRule_bitwiseANDExpressionNoIn();
		EnterRule("bitwiseANDExpressionNoIn", 31);
		TraceIn("bitwiseANDExpressionNoIn", 31);
		AstParserRuleReturnScope<object, IToken> retval = new AstParserRuleReturnScope<object, IToken>();
		retval.Start = (IToken)input.LT(1);

		object root_0 = default(object);

		IToken AND95 = default(IToken);
		AstParserRuleReturnScope<object, IToken> equalityExpressionNoIn94 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> equalityExpressionNoIn96 = default(AstParserRuleReturnScope<object, IToken>);

		object AND95_tree = default(object);
		try { DebugEnterRule(GrammarFileName, "bitwiseANDExpressionNoIn");
		DebugLocation(802, 1);
		try
		{
			// JavaScript.g:803:2: ( equalityExpressionNoIn ( AND ^ equalityExpressionNoIn )* )
			DebugEnterAlt(1);
			// JavaScript.g:803:4: equalityExpressionNoIn ( AND ^ equalityExpressionNoIn )*
			{
			root_0 = (object)adaptor.Nil();

			DebugLocation(803, 4);
			PushFollow(Follow._equalityExpressionNoIn_in_bitwiseANDExpressionNoIn3968);
			equalityExpressionNoIn94=equalityExpressionNoIn();
			PopFollow();

			adaptor.AddChild(root_0, equalityExpressionNoIn94.Tree);
			DebugLocation(803, 27);
			// JavaScript.g:803:27: ( AND ^ equalityExpressionNoIn )*
			try { DebugEnterSubRule(27);
			while (true)
			{
				int alt27=2;
				try { DebugEnterDecision(27, false);
				int LA27_1 = input.LA(1);

				if ((LA27_1==AND))
				{
					alt27 = 1;
				}


				} finally { DebugExitDecision(27); }
				switch ( alt27 )
				{
				case 1:
					DebugEnterAlt(1);
					// JavaScript.g:803:29: AND ^ equalityExpressionNoIn
					{
					DebugLocation(803, 32);
					AND95=(IToken)Match(input,AND,Follow._AND_in_bitwiseANDExpressionNoIn3972); 
					AND95_tree = (object)adaptor.Create(AND95);
					root_0 = (object)adaptor.BecomeRoot(AND95_tree, root_0);
					DebugLocation(803, 34);
					PushFollow(Follow._equalityExpressionNoIn_in_bitwiseANDExpressionNoIn3975);
					equalityExpressionNoIn96=equalityExpressionNoIn();
					PopFollow();

					adaptor.AddChild(root_0, equalityExpressionNoIn96.Tree);

					}
					break;

				default:
					goto loop27;
				}
			}

			loop27:
				;

			} finally { DebugExitSubRule(27); }


			}

			retval.Stop = (IToken)input.LT(-1);

			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);

		}
		 
		finally
		{
			TraceOut("bitwiseANDExpressionNoIn", 31);
			LeaveRule("bitwiseANDExpressionNoIn", 31);
			LeaveRule_bitwiseANDExpressionNoIn();
		}
		DebugLocation(804, 1);
		} finally { DebugExitRule(GrammarFileName, "bitwiseANDExpressionNoIn"); }
		return retval;

	}
	// $ANTLR end "bitwiseANDExpressionNoIn"

	partial void EnterRule_bitwiseXORExpression();
	partial void LeaveRule_bitwiseXORExpression();
	// $ANTLR start "bitwiseXORExpression"
	// JavaScript.g:806:1: bitwiseXORExpression : bitwiseANDExpression ( XOR ^ bitwiseANDExpression )* ;
	[GrammarRule("bitwiseXORExpression")]
	private AstParserRuleReturnScope<object, IToken> bitwiseXORExpression()
	{
		EnterRule_bitwiseXORExpression();
		EnterRule("bitwiseXORExpression", 32);
		TraceIn("bitwiseXORExpression", 32);
		AstParserRuleReturnScope<object, IToken> retval = new AstParserRuleReturnScope<object, IToken>();
		retval.Start = (IToken)input.LT(1);

		object root_0 = default(object);

		IToken XOR98 = default(IToken);
		AstParserRuleReturnScope<object, IToken> bitwiseANDExpression97 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> bitwiseANDExpression99 = default(AstParserRuleReturnScope<object, IToken>);

		object XOR98_tree = default(object);
		try { DebugEnterRule(GrammarFileName, "bitwiseXORExpression");
		DebugLocation(806, 1);
		try
		{
			// JavaScript.g:807:2: ( bitwiseANDExpression ( XOR ^ bitwiseANDExpression )* )
			DebugEnterAlt(1);
			// JavaScript.g:807:4: bitwiseANDExpression ( XOR ^ bitwiseANDExpression )*
			{
			root_0 = (object)adaptor.Nil();

			DebugLocation(807, 4);
			PushFollow(Follow._bitwiseANDExpression_in_bitwiseXORExpression3991);
			bitwiseANDExpression97=bitwiseANDExpression();
			PopFollow();

			adaptor.AddChild(root_0, bitwiseANDExpression97.Tree);
			DebugLocation(807, 25);
			// JavaScript.g:807:25: ( XOR ^ bitwiseANDExpression )*
			try { DebugEnterSubRule(28);
			while (true)
			{
				int alt28=2;
				try { DebugEnterDecision(28, false);
				int LA28_1 = input.LA(1);

				if ((LA28_1==XOR))
				{
					alt28 = 1;
				}


				} finally { DebugExitDecision(28); }
				switch ( alt28 )
				{
				case 1:
					DebugEnterAlt(1);
					// JavaScript.g:807:27: XOR ^ bitwiseANDExpression
					{
					DebugLocation(807, 30);
					XOR98=(IToken)Match(input,XOR,Follow._XOR_in_bitwiseXORExpression3995); 
					XOR98_tree = (object)adaptor.Create(XOR98);
					root_0 = (object)adaptor.BecomeRoot(XOR98_tree, root_0);
					DebugLocation(807, 32);
					PushFollow(Follow._bitwiseANDExpression_in_bitwiseXORExpression3998);
					bitwiseANDExpression99=bitwiseANDExpression();
					PopFollow();

					adaptor.AddChild(root_0, bitwiseANDExpression99.Tree);

					}
					break;

				default:
					goto loop28;
				}
			}

			loop28:
				;

			} finally { DebugExitSubRule(28); }


			}

			retval.Stop = (IToken)input.LT(-1);

			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);

		}
		 
		finally
		{
			TraceOut("bitwiseXORExpression", 32);
			LeaveRule("bitwiseXORExpression", 32);
			LeaveRule_bitwiseXORExpression();
		}
		DebugLocation(808, 1);
		} finally { DebugExitRule(GrammarFileName, "bitwiseXORExpression"); }
		return retval;

	}
	// $ANTLR end "bitwiseXORExpression"

	partial void EnterRule_bitwiseXORExpressionNoIn();
	partial void LeaveRule_bitwiseXORExpressionNoIn();
	// $ANTLR start "bitwiseXORExpressionNoIn"
	// JavaScript.g:810:1: bitwiseXORExpressionNoIn : bitwiseANDExpressionNoIn ( XOR ^ bitwiseANDExpressionNoIn )* ;
	[GrammarRule("bitwiseXORExpressionNoIn")]
	private AstParserRuleReturnScope<object, IToken> bitwiseXORExpressionNoIn()
	{
		EnterRule_bitwiseXORExpressionNoIn();
		EnterRule("bitwiseXORExpressionNoIn", 33);
		TraceIn("bitwiseXORExpressionNoIn", 33);
		AstParserRuleReturnScope<object, IToken> retval = new AstParserRuleReturnScope<object, IToken>();
		retval.Start = (IToken)input.LT(1);

		object root_0 = default(object);

		IToken XOR101 = default(IToken);
		AstParserRuleReturnScope<object, IToken> bitwiseANDExpressionNoIn100 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> bitwiseANDExpressionNoIn102 = default(AstParserRuleReturnScope<object, IToken>);

		object XOR101_tree = default(object);
		try { DebugEnterRule(GrammarFileName, "bitwiseXORExpressionNoIn");
		DebugLocation(810, 1);
		try
		{
			// JavaScript.g:811:2: ( bitwiseANDExpressionNoIn ( XOR ^ bitwiseANDExpressionNoIn )* )
			DebugEnterAlt(1);
			// JavaScript.g:811:4: bitwiseANDExpressionNoIn ( XOR ^ bitwiseANDExpressionNoIn )*
			{
			root_0 = (object)adaptor.Nil();

			DebugLocation(811, 4);
			PushFollow(Follow._bitwiseANDExpressionNoIn_in_bitwiseXORExpressionNoIn4014);
			bitwiseANDExpressionNoIn100=bitwiseANDExpressionNoIn();
			PopFollow();

			adaptor.AddChild(root_0, bitwiseANDExpressionNoIn100.Tree);
			DebugLocation(811, 29);
			// JavaScript.g:811:29: ( XOR ^ bitwiseANDExpressionNoIn )*
			try { DebugEnterSubRule(29);
			while (true)
			{
				int alt29=2;
				try { DebugEnterDecision(29, false);
				int LA29_1 = input.LA(1);

				if ((LA29_1==XOR))
				{
					alt29 = 1;
				}


				} finally { DebugExitDecision(29); }
				switch ( alt29 )
				{
				case 1:
					DebugEnterAlt(1);
					// JavaScript.g:811:31: XOR ^ bitwiseANDExpressionNoIn
					{
					DebugLocation(811, 34);
					XOR101=(IToken)Match(input,XOR,Follow._XOR_in_bitwiseXORExpressionNoIn4018); 
					XOR101_tree = (object)adaptor.Create(XOR101);
					root_0 = (object)adaptor.BecomeRoot(XOR101_tree, root_0);
					DebugLocation(811, 36);
					PushFollow(Follow._bitwiseANDExpressionNoIn_in_bitwiseXORExpressionNoIn4021);
					bitwiseANDExpressionNoIn102=bitwiseANDExpressionNoIn();
					PopFollow();

					adaptor.AddChild(root_0, bitwiseANDExpressionNoIn102.Tree);

					}
					break;

				default:
					goto loop29;
				}
			}

			loop29:
				;

			} finally { DebugExitSubRule(29); }


			}

			retval.Stop = (IToken)input.LT(-1);

			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);

		}
		 
		finally
		{
			TraceOut("bitwiseXORExpressionNoIn", 33);
			LeaveRule("bitwiseXORExpressionNoIn", 33);
			LeaveRule_bitwiseXORExpressionNoIn();
		}
		DebugLocation(812, 1);
		} finally { DebugExitRule(GrammarFileName, "bitwiseXORExpressionNoIn"); }
		return retval;

	}
	// $ANTLR end "bitwiseXORExpressionNoIn"

	partial void EnterRule_bitwiseORExpression();
	partial void LeaveRule_bitwiseORExpression();
	// $ANTLR start "bitwiseORExpression"
	// JavaScript.g:814:1: bitwiseORExpression : bitwiseXORExpression ( OR ^ bitwiseXORExpression )* ;
	[GrammarRule("bitwiseORExpression")]
	private AstParserRuleReturnScope<object, IToken> bitwiseORExpression()
	{
		EnterRule_bitwiseORExpression();
		EnterRule("bitwiseORExpression", 34);
		TraceIn("bitwiseORExpression", 34);
		AstParserRuleReturnScope<object, IToken> retval = new AstParserRuleReturnScope<object, IToken>();
		retval.Start = (IToken)input.LT(1);

		object root_0 = default(object);

		IToken OR104 = default(IToken);
		AstParserRuleReturnScope<object, IToken> bitwiseXORExpression103 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> bitwiseXORExpression105 = default(AstParserRuleReturnScope<object, IToken>);

		object OR104_tree = default(object);
		try { DebugEnterRule(GrammarFileName, "bitwiseORExpression");
		DebugLocation(814, 1);
		try
		{
			// JavaScript.g:815:2: ( bitwiseXORExpression ( OR ^ bitwiseXORExpression )* )
			DebugEnterAlt(1);
			// JavaScript.g:815:4: bitwiseXORExpression ( OR ^ bitwiseXORExpression )*
			{
			root_0 = (object)adaptor.Nil();

			DebugLocation(815, 4);
			PushFollow(Follow._bitwiseXORExpression_in_bitwiseORExpression4036);
			bitwiseXORExpression103=bitwiseXORExpression();
			PopFollow();

			adaptor.AddChild(root_0, bitwiseXORExpression103.Tree);
			DebugLocation(815, 25);
			// JavaScript.g:815:25: ( OR ^ bitwiseXORExpression )*
			try { DebugEnterSubRule(30);
			while (true)
			{
				int alt30=2;
				try { DebugEnterDecision(30, false);
				int LA30_1 = input.LA(1);

				if ((LA30_1==OR))
				{
					alt30 = 1;
				}


				} finally { DebugExitDecision(30); }
				switch ( alt30 )
				{
				case 1:
					DebugEnterAlt(1);
					// JavaScript.g:815:27: OR ^ bitwiseXORExpression
					{
					DebugLocation(815, 29);
					OR104=(IToken)Match(input,OR,Follow._OR_in_bitwiseORExpression4040); 
					OR104_tree = (object)adaptor.Create(OR104);
					root_0 = (object)adaptor.BecomeRoot(OR104_tree, root_0);
					DebugLocation(815, 31);
					PushFollow(Follow._bitwiseXORExpression_in_bitwiseORExpression4043);
					bitwiseXORExpression105=bitwiseXORExpression();
					PopFollow();

					adaptor.AddChild(root_0, bitwiseXORExpression105.Tree);

					}
					break;

				default:
					goto loop30;
				}
			}

			loop30:
				;

			} finally { DebugExitSubRule(30); }


			}

			retval.Stop = (IToken)input.LT(-1);

			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);

		}
		 
		finally
		{
			TraceOut("bitwiseORExpression", 34);
			LeaveRule("bitwiseORExpression", 34);
			LeaveRule_bitwiseORExpression();
		}
		DebugLocation(816, 1);
		} finally { DebugExitRule(GrammarFileName, "bitwiseORExpression"); }
		return retval;

	}
	// $ANTLR end "bitwiseORExpression"

	partial void EnterRule_bitwiseORExpressionNoIn();
	partial void LeaveRule_bitwiseORExpressionNoIn();
	// $ANTLR start "bitwiseORExpressionNoIn"
	// JavaScript.g:818:1: bitwiseORExpressionNoIn : bitwiseXORExpressionNoIn ( OR ^ bitwiseXORExpressionNoIn )* ;
	[GrammarRule("bitwiseORExpressionNoIn")]
	private AstParserRuleReturnScope<object, IToken> bitwiseORExpressionNoIn()
	{
		EnterRule_bitwiseORExpressionNoIn();
		EnterRule("bitwiseORExpressionNoIn", 35);
		TraceIn("bitwiseORExpressionNoIn", 35);
		AstParserRuleReturnScope<object, IToken> retval = new AstParserRuleReturnScope<object, IToken>();
		retval.Start = (IToken)input.LT(1);

		object root_0 = default(object);

		IToken OR107 = default(IToken);
		AstParserRuleReturnScope<object, IToken> bitwiseXORExpressionNoIn106 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> bitwiseXORExpressionNoIn108 = default(AstParserRuleReturnScope<object, IToken>);

		object OR107_tree = default(object);
		try { DebugEnterRule(GrammarFileName, "bitwiseORExpressionNoIn");
		DebugLocation(818, 1);
		try
		{
			// JavaScript.g:819:2: ( bitwiseXORExpressionNoIn ( OR ^ bitwiseXORExpressionNoIn )* )
			DebugEnterAlt(1);
			// JavaScript.g:819:4: bitwiseXORExpressionNoIn ( OR ^ bitwiseXORExpressionNoIn )*
			{
			root_0 = (object)adaptor.Nil();

			DebugLocation(819, 4);
			PushFollow(Follow._bitwiseXORExpressionNoIn_in_bitwiseORExpressionNoIn4058);
			bitwiseXORExpressionNoIn106=bitwiseXORExpressionNoIn();
			PopFollow();

			adaptor.AddChild(root_0, bitwiseXORExpressionNoIn106.Tree);
			DebugLocation(819, 29);
			// JavaScript.g:819:29: ( OR ^ bitwiseXORExpressionNoIn )*
			try { DebugEnterSubRule(31);
			while (true)
			{
				int alt31=2;
				try { DebugEnterDecision(31, false);
				int LA31_1 = input.LA(1);

				if ((LA31_1==OR))
				{
					alt31 = 1;
				}


				} finally { DebugExitDecision(31); }
				switch ( alt31 )
				{
				case 1:
					DebugEnterAlt(1);
					// JavaScript.g:819:31: OR ^ bitwiseXORExpressionNoIn
					{
					DebugLocation(819, 33);
					OR107=(IToken)Match(input,OR,Follow._OR_in_bitwiseORExpressionNoIn4062); 
					OR107_tree = (object)adaptor.Create(OR107);
					root_0 = (object)adaptor.BecomeRoot(OR107_tree, root_0);
					DebugLocation(819, 35);
					PushFollow(Follow._bitwiseXORExpressionNoIn_in_bitwiseORExpressionNoIn4065);
					bitwiseXORExpressionNoIn108=bitwiseXORExpressionNoIn();
					PopFollow();

					adaptor.AddChild(root_0, bitwiseXORExpressionNoIn108.Tree);

					}
					break;

				default:
					goto loop31;
				}
			}

			loop31:
				;

			} finally { DebugExitSubRule(31); }


			}

			retval.Stop = (IToken)input.LT(-1);

			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);

		}
		 
		finally
		{
			TraceOut("bitwiseORExpressionNoIn", 35);
			LeaveRule("bitwiseORExpressionNoIn", 35);
			LeaveRule_bitwiseORExpressionNoIn();
		}
		DebugLocation(820, 1);
		} finally { DebugExitRule(GrammarFileName, "bitwiseORExpressionNoIn"); }
		return retval;

	}
	// $ANTLR end "bitwiseORExpressionNoIn"

	partial void EnterRule_logicalANDExpression();
	partial void LeaveRule_logicalANDExpression();
	// $ANTLR start "logicalANDExpression"
	// JavaScript.g:826:1: logicalANDExpression : bitwiseORExpression ( LAND ^ bitwiseORExpression )* ;
	[GrammarRule("logicalANDExpression")]
	private AstParserRuleReturnScope<object, IToken> logicalANDExpression()
	{
		EnterRule_logicalANDExpression();
		EnterRule("logicalANDExpression", 36);
		TraceIn("logicalANDExpression", 36);
		AstParserRuleReturnScope<object, IToken> retval = new AstParserRuleReturnScope<object, IToken>();
		retval.Start = (IToken)input.LT(1);

		object root_0 = default(object);

		IToken LAND110 = default(IToken);
		AstParserRuleReturnScope<object, IToken> bitwiseORExpression109 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> bitwiseORExpression111 = default(AstParserRuleReturnScope<object, IToken>);

		object LAND110_tree = default(object);
		try { DebugEnterRule(GrammarFileName, "logicalANDExpression");
		DebugLocation(826, 1);
		try
		{
			// JavaScript.g:827:2: ( bitwiseORExpression ( LAND ^ bitwiseORExpression )* )
			DebugEnterAlt(1);
			// JavaScript.g:827:4: bitwiseORExpression ( LAND ^ bitwiseORExpression )*
			{
			root_0 = (object)adaptor.Nil();

			DebugLocation(827, 4);
			PushFollow(Follow._bitwiseORExpression_in_logicalANDExpression4084);
			bitwiseORExpression109=bitwiseORExpression();
			PopFollow();

			adaptor.AddChild(root_0, bitwiseORExpression109.Tree);
			DebugLocation(827, 24);
			// JavaScript.g:827:24: ( LAND ^ bitwiseORExpression )*
			try { DebugEnterSubRule(32);
			while (true)
			{
				int alt32=2;
				try { DebugEnterDecision(32, false);
				int LA32_1 = input.LA(1);

				if ((LA32_1==LAND))
				{
					alt32 = 1;
				}


				} finally { DebugExitDecision(32); }
				switch ( alt32 )
				{
				case 1:
					DebugEnterAlt(1);
					// JavaScript.g:827:26: LAND ^ bitwiseORExpression
					{
					DebugLocation(827, 30);
					LAND110=(IToken)Match(input,LAND,Follow._LAND_in_logicalANDExpression4088); 
					LAND110_tree = (object)adaptor.Create(LAND110);
					root_0 = (object)adaptor.BecomeRoot(LAND110_tree, root_0);
					DebugLocation(827, 32);
					PushFollow(Follow._bitwiseORExpression_in_logicalANDExpression4091);
					bitwiseORExpression111=bitwiseORExpression();
					PopFollow();

					adaptor.AddChild(root_0, bitwiseORExpression111.Tree);

					}
					break;

				default:
					goto loop32;
				}
			}

			loop32:
				;

			} finally { DebugExitSubRule(32); }


			}

			retval.Stop = (IToken)input.LT(-1);

			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);

		}
		 
		finally
		{
			TraceOut("logicalANDExpression", 36);
			LeaveRule("logicalANDExpression", 36);
			LeaveRule_logicalANDExpression();
		}
		DebugLocation(828, 1);
		} finally { DebugExitRule(GrammarFileName, "logicalANDExpression"); }
		return retval;

	}
	// $ANTLR end "logicalANDExpression"

	partial void EnterRule_logicalANDExpressionNoIn();
	partial void LeaveRule_logicalANDExpressionNoIn();
	// $ANTLR start "logicalANDExpressionNoIn"
	// JavaScript.g:830:1: logicalANDExpressionNoIn : bitwiseORExpressionNoIn ( LAND ^ bitwiseORExpressionNoIn )* ;
	[GrammarRule("logicalANDExpressionNoIn")]
	private AstParserRuleReturnScope<object, IToken> logicalANDExpressionNoIn()
	{
		EnterRule_logicalANDExpressionNoIn();
		EnterRule("logicalANDExpressionNoIn", 37);
		TraceIn("logicalANDExpressionNoIn", 37);
		AstParserRuleReturnScope<object, IToken> retval = new AstParserRuleReturnScope<object, IToken>();
		retval.Start = (IToken)input.LT(1);

		object root_0 = default(object);

		IToken LAND113 = default(IToken);
		AstParserRuleReturnScope<object, IToken> bitwiseORExpressionNoIn112 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> bitwiseORExpressionNoIn114 = default(AstParserRuleReturnScope<object, IToken>);

		object LAND113_tree = default(object);
		try { DebugEnterRule(GrammarFileName, "logicalANDExpressionNoIn");
		DebugLocation(830, 1);
		try
		{
			// JavaScript.g:831:2: ( bitwiseORExpressionNoIn ( LAND ^ bitwiseORExpressionNoIn )* )
			DebugEnterAlt(1);
			// JavaScript.g:831:4: bitwiseORExpressionNoIn ( LAND ^ bitwiseORExpressionNoIn )*
			{
			root_0 = (object)adaptor.Nil();

			DebugLocation(831, 4);
			PushFollow(Follow._bitwiseORExpressionNoIn_in_logicalANDExpressionNoIn4105);
			bitwiseORExpressionNoIn112=bitwiseORExpressionNoIn();
			PopFollow();

			adaptor.AddChild(root_0, bitwiseORExpressionNoIn112.Tree);
			DebugLocation(831, 28);
			// JavaScript.g:831:28: ( LAND ^ bitwiseORExpressionNoIn )*
			try { DebugEnterSubRule(33);
			while (true)
			{
				int alt33=2;
				try { DebugEnterDecision(33, false);
				int LA33_1 = input.LA(1);

				if ((LA33_1==LAND))
				{
					alt33 = 1;
				}


				} finally { DebugExitDecision(33); }
				switch ( alt33 )
				{
				case 1:
					DebugEnterAlt(1);
					// JavaScript.g:831:30: LAND ^ bitwiseORExpressionNoIn
					{
					DebugLocation(831, 34);
					LAND113=(IToken)Match(input,LAND,Follow._LAND_in_logicalANDExpressionNoIn4109); 
					LAND113_tree = (object)adaptor.Create(LAND113);
					root_0 = (object)adaptor.BecomeRoot(LAND113_tree, root_0);
					DebugLocation(831, 36);
					PushFollow(Follow._bitwiseORExpressionNoIn_in_logicalANDExpressionNoIn4112);
					bitwiseORExpressionNoIn114=bitwiseORExpressionNoIn();
					PopFollow();

					adaptor.AddChild(root_0, bitwiseORExpressionNoIn114.Tree);

					}
					break;

				default:
					goto loop33;
				}
			}

			loop33:
				;

			} finally { DebugExitSubRule(33); }


			}

			retval.Stop = (IToken)input.LT(-1);

			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);

		}
		 
		finally
		{
			TraceOut("logicalANDExpressionNoIn", 37);
			LeaveRule("logicalANDExpressionNoIn", 37);
			LeaveRule_logicalANDExpressionNoIn();
		}
		DebugLocation(832, 1);
		} finally { DebugExitRule(GrammarFileName, "logicalANDExpressionNoIn"); }
		return retval;

	}
	// $ANTLR end "logicalANDExpressionNoIn"

	partial void EnterRule_logicalORExpression();
	partial void LeaveRule_logicalORExpression();
	// $ANTLR start "logicalORExpression"
	// JavaScript.g:834:1: logicalORExpression : logicalANDExpression ( LOR ^ logicalANDExpression )* ;
	[GrammarRule("logicalORExpression")]
	private AstParserRuleReturnScope<object, IToken> logicalORExpression()
	{
		EnterRule_logicalORExpression();
		EnterRule("logicalORExpression", 38);
		TraceIn("logicalORExpression", 38);
		AstParserRuleReturnScope<object, IToken> retval = new AstParserRuleReturnScope<object, IToken>();
		retval.Start = (IToken)input.LT(1);

		object root_0 = default(object);

		IToken LOR116 = default(IToken);
		AstParserRuleReturnScope<object, IToken> logicalANDExpression115 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> logicalANDExpression117 = default(AstParserRuleReturnScope<object, IToken>);

		object LOR116_tree = default(object);
		try { DebugEnterRule(GrammarFileName, "logicalORExpression");
		DebugLocation(834, 1);
		try
		{
			// JavaScript.g:835:2: ( logicalANDExpression ( LOR ^ logicalANDExpression )* )
			DebugEnterAlt(1);
			// JavaScript.g:835:4: logicalANDExpression ( LOR ^ logicalANDExpression )*
			{
			root_0 = (object)adaptor.Nil();

			DebugLocation(835, 4);
			PushFollow(Follow._logicalANDExpression_in_logicalORExpression4127);
			logicalANDExpression115=logicalANDExpression();
			PopFollow();

			adaptor.AddChild(root_0, logicalANDExpression115.Tree);
			DebugLocation(835, 25);
			// JavaScript.g:835:25: ( LOR ^ logicalANDExpression )*
			try { DebugEnterSubRule(34);
			while (true)
			{
				int alt34=2;
				try { DebugEnterDecision(34, false);
				int LA34_1 = input.LA(1);

				if ((LA34_1==LOR))
				{
					alt34 = 1;
				}


				} finally { DebugExitDecision(34); }
				switch ( alt34 )
				{
				case 1:
					DebugEnterAlt(1);
					// JavaScript.g:835:27: LOR ^ logicalANDExpression
					{
					DebugLocation(835, 30);
					LOR116=(IToken)Match(input,LOR,Follow._LOR_in_logicalORExpression4131); 
					LOR116_tree = (object)adaptor.Create(LOR116);
					root_0 = (object)adaptor.BecomeRoot(LOR116_tree, root_0);
					DebugLocation(835, 32);
					PushFollow(Follow._logicalANDExpression_in_logicalORExpression4134);
					logicalANDExpression117=logicalANDExpression();
					PopFollow();

					adaptor.AddChild(root_0, logicalANDExpression117.Tree);

					}
					break;

				default:
					goto loop34;
				}
			}

			loop34:
				;

			} finally { DebugExitSubRule(34); }


			}

			retval.Stop = (IToken)input.LT(-1);

			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);

		}
		 
		finally
		{
			TraceOut("logicalORExpression", 38);
			LeaveRule("logicalORExpression", 38);
			LeaveRule_logicalORExpression();
		}
		DebugLocation(836, 1);
		} finally { DebugExitRule(GrammarFileName, "logicalORExpression"); }
		return retval;

	}
	// $ANTLR end "logicalORExpression"

	partial void EnterRule_logicalORExpressionNoIn();
	partial void LeaveRule_logicalORExpressionNoIn();
	// $ANTLR start "logicalORExpressionNoIn"
	// JavaScript.g:838:1: logicalORExpressionNoIn : logicalANDExpressionNoIn ( LOR ^ logicalANDExpressionNoIn )* ;
	[GrammarRule("logicalORExpressionNoIn")]
	private AstParserRuleReturnScope<object, IToken> logicalORExpressionNoIn()
	{
		EnterRule_logicalORExpressionNoIn();
		EnterRule("logicalORExpressionNoIn", 39);
		TraceIn("logicalORExpressionNoIn", 39);
		AstParserRuleReturnScope<object, IToken> retval = new AstParserRuleReturnScope<object, IToken>();
		retval.Start = (IToken)input.LT(1);

		object root_0 = default(object);

		IToken LOR119 = default(IToken);
		AstParserRuleReturnScope<object, IToken> logicalANDExpressionNoIn118 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> logicalANDExpressionNoIn120 = default(AstParserRuleReturnScope<object, IToken>);

		object LOR119_tree = default(object);
		try { DebugEnterRule(GrammarFileName, "logicalORExpressionNoIn");
		DebugLocation(838, 1);
		try
		{
			// JavaScript.g:839:2: ( logicalANDExpressionNoIn ( LOR ^ logicalANDExpressionNoIn )* )
			DebugEnterAlt(1);
			// JavaScript.g:839:4: logicalANDExpressionNoIn ( LOR ^ logicalANDExpressionNoIn )*
			{
			root_0 = (object)adaptor.Nil();

			DebugLocation(839, 4);
			PushFollow(Follow._logicalANDExpressionNoIn_in_logicalORExpressionNoIn4149);
			logicalANDExpressionNoIn118=logicalANDExpressionNoIn();
			PopFollow();

			adaptor.AddChild(root_0, logicalANDExpressionNoIn118.Tree);
			DebugLocation(839, 29);
			// JavaScript.g:839:29: ( LOR ^ logicalANDExpressionNoIn )*
			try { DebugEnterSubRule(35);
			while (true)
			{
				int alt35=2;
				try { DebugEnterDecision(35, false);
				int LA35_1 = input.LA(1);

				if ((LA35_1==LOR))
				{
					alt35 = 1;
				}


				} finally { DebugExitDecision(35); }
				switch ( alt35 )
				{
				case 1:
					DebugEnterAlt(1);
					// JavaScript.g:839:31: LOR ^ logicalANDExpressionNoIn
					{
					DebugLocation(839, 34);
					LOR119=(IToken)Match(input,LOR,Follow._LOR_in_logicalORExpressionNoIn4153); 
					LOR119_tree = (object)adaptor.Create(LOR119);
					root_0 = (object)adaptor.BecomeRoot(LOR119_tree, root_0);
					DebugLocation(839, 36);
					PushFollow(Follow._logicalANDExpressionNoIn_in_logicalORExpressionNoIn4156);
					logicalANDExpressionNoIn120=logicalANDExpressionNoIn();
					PopFollow();

					adaptor.AddChild(root_0, logicalANDExpressionNoIn120.Tree);

					}
					break;

				default:
					goto loop35;
				}
			}

			loop35:
				;

			} finally { DebugExitSubRule(35); }


			}

			retval.Stop = (IToken)input.LT(-1);

			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);

		}
		 
		finally
		{
			TraceOut("logicalORExpressionNoIn", 39);
			LeaveRule("logicalORExpressionNoIn", 39);
			LeaveRule_logicalORExpressionNoIn();
		}
		DebugLocation(840, 1);
		} finally { DebugExitRule(GrammarFileName, "logicalORExpressionNoIn"); }
		return retval;

	}
	// $ANTLR end "logicalORExpressionNoIn"

	partial void EnterRule_conditionalExpression();
	partial void LeaveRule_conditionalExpression();
	// $ANTLR start "conditionalExpression"
	// JavaScript.g:846:1: conditionalExpression : logicalORExpression ( QUE ^ assignmentExpression COLON ! assignmentExpression )? ;
	[GrammarRule("conditionalExpression")]
	private AstParserRuleReturnScope<object, IToken> conditionalExpression()
	{
		EnterRule_conditionalExpression();
		EnterRule("conditionalExpression", 40);
		TraceIn("conditionalExpression", 40);
		AstParserRuleReturnScope<object, IToken> retval = new AstParserRuleReturnScope<object, IToken>();
		retval.Start = (IToken)input.LT(1);

		object root_0 = default(object);

		IToken QUE122 = default(IToken);
		IToken COLON124 = default(IToken);
		AstParserRuleReturnScope<object, IToken> logicalORExpression121 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> assignmentExpression123 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> assignmentExpression125 = default(AstParserRuleReturnScope<object, IToken>);

		object QUE122_tree = default(object);
		object COLON124_tree = default(object);
		try { DebugEnterRule(GrammarFileName, "conditionalExpression");
		DebugLocation(846, 1);
		try
		{
			// JavaScript.g:847:2: ( logicalORExpression ( QUE ^ assignmentExpression COLON ! assignmentExpression )? )
			DebugEnterAlt(1);
			// JavaScript.g:847:4: logicalORExpression ( QUE ^ assignmentExpression COLON ! assignmentExpression )?
			{
			root_0 = (object)adaptor.Nil();

			DebugLocation(847, 4);
			PushFollow(Follow._logicalORExpression_in_conditionalExpression4175);
			logicalORExpression121=logicalORExpression();
			PopFollow();

			adaptor.AddChild(root_0, logicalORExpression121.Tree);
			DebugLocation(847, 24);
			// JavaScript.g:847:24: ( QUE ^ assignmentExpression COLON ! assignmentExpression )?
			int alt36=2;
			try { DebugEnterSubRule(36);
			try { DebugEnterDecision(36, false);
			int LA36_1 = input.LA(1);

			if ((LA36_1==QUE))
			{
				alt36 = 1;
			}
			} finally { DebugExitDecision(36); }
			switch (alt36)
			{
			case 1:
				DebugEnterAlt(1);
				// JavaScript.g:847:26: QUE ^ assignmentExpression COLON ! assignmentExpression
				{
				DebugLocation(847, 29);
				QUE122=(IToken)Match(input,QUE,Follow._QUE_in_conditionalExpression4179); 
				QUE122_tree = (object)adaptor.Create(QUE122);
				root_0 = (object)adaptor.BecomeRoot(QUE122_tree, root_0);
				DebugLocation(847, 31);
				PushFollow(Follow._assignmentExpression_in_conditionalExpression4182);
				assignmentExpression123=assignmentExpression();
				PopFollow();

				adaptor.AddChild(root_0, assignmentExpression123.Tree);
				DebugLocation(847, 57);
				COLON124=(IToken)Match(input,COLON,Follow._COLON_in_conditionalExpression4184); 
				DebugLocation(847, 59);
				PushFollow(Follow._assignmentExpression_in_conditionalExpression4187);
				assignmentExpression125=assignmentExpression();
				PopFollow();

				adaptor.AddChild(root_0, assignmentExpression125.Tree);

				}
				break;

			}
			} finally { DebugExitSubRule(36); }


			}

			retval.Stop = (IToken)input.LT(-1);

			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);

		}
		 
		finally
		{
			TraceOut("conditionalExpression", 40);
			LeaveRule("conditionalExpression", 40);
			LeaveRule_conditionalExpression();
		}
		DebugLocation(848, 1);
		} finally { DebugExitRule(GrammarFileName, "conditionalExpression"); }
		return retval;

	}
	// $ANTLR end "conditionalExpression"

	partial void EnterRule_conditionalExpressionNoIn();
	partial void LeaveRule_conditionalExpressionNoIn();
	// $ANTLR start "conditionalExpressionNoIn"
	// JavaScript.g:850:1: conditionalExpressionNoIn : logicalORExpressionNoIn ( QUE ^ assignmentExpressionNoIn COLON ! assignmentExpressionNoIn )? ;
	[GrammarRule("conditionalExpressionNoIn")]
	private AstParserRuleReturnScope<object, IToken> conditionalExpressionNoIn()
	{
		EnterRule_conditionalExpressionNoIn();
		EnterRule("conditionalExpressionNoIn", 41);
		TraceIn("conditionalExpressionNoIn", 41);
		AstParserRuleReturnScope<object, IToken> retval = new AstParserRuleReturnScope<object, IToken>();
		retval.Start = (IToken)input.LT(1);

		object root_0 = default(object);

		IToken QUE127 = default(IToken);
		IToken COLON129 = default(IToken);
		AstParserRuleReturnScope<object, IToken> logicalORExpressionNoIn126 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> assignmentExpressionNoIn128 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> assignmentExpressionNoIn130 = default(AstParserRuleReturnScope<object, IToken>);

		object QUE127_tree = default(object);
		object COLON129_tree = default(object);
		try { DebugEnterRule(GrammarFileName, "conditionalExpressionNoIn");
		DebugLocation(850, 1);
		try
		{
			// JavaScript.g:851:2: ( logicalORExpressionNoIn ( QUE ^ assignmentExpressionNoIn COLON ! assignmentExpressionNoIn )? )
			DebugEnterAlt(1);
			// JavaScript.g:851:4: logicalORExpressionNoIn ( QUE ^ assignmentExpressionNoIn COLON ! assignmentExpressionNoIn )?
			{
			root_0 = (object)adaptor.Nil();

			DebugLocation(851, 4);
			PushFollow(Follow._logicalORExpressionNoIn_in_conditionalExpressionNoIn4201);
			logicalORExpressionNoIn126=logicalORExpressionNoIn();
			PopFollow();

			adaptor.AddChild(root_0, logicalORExpressionNoIn126.Tree);
			DebugLocation(851, 28);
			// JavaScript.g:851:28: ( QUE ^ assignmentExpressionNoIn COLON ! assignmentExpressionNoIn )?
			int alt37=2;
			try { DebugEnterSubRule(37);
			try { DebugEnterDecision(37, false);
			int LA37_1 = input.LA(1);

			if ((LA37_1==QUE))
			{
				alt37 = 1;
			}
			} finally { DebugExitDecision(37); }
			switch (alt37)
			{
			case 1:
				DebugEnterAlt(1);
				// JavaScript.g:851:30: QUE ^ assignmentExpressionNoIn COLON ! assignmentExpressionNoIn
				{
				DebugLocation(851, 33);
				QUE127=(IToken)Match(input,QUE,Follow._QUE_in_conditionalExpressionNoIn4205); 
				QUE127_tree = (object)adaptor.Create(QUE127);
				root_0 = (object)adaptor.BecomeRoot(QUE127_tree, root_0);
				DebugLocation(851, 35);
				PushFollow(Follow._assignmentExpressionNoIn_in_conditionalExpressionNoIn4208);
				assignmentExpressionNoIn128=assignmentExpressionNoIn();
				PopFollow();

				adaptor.AddChild(root_0, assignmentExpressionNoIn128.Tree);
				DebugLocation(851, 65);
				COLON129=(IToken)Match(input,COLON,Follow._COLON_in_conditionalExpressionNoIn4210); 
				DebugLocation(851, 67);
				PushFollow(Follow._assignmentExpressionNoIn_in_conditionalExpressionNoIn4213);
				assignmentExpressionNoIn130=assignmentExpressionNoIn();
				PopFollow();

				adaptor.AddChild(root_0, assignmentExpressionNoIn130.Tree);

				}
				break;

			}
			} finally { DebugExitSubRule(37); }


			}

			retval.Stop = (IToken)input.LT(-1);

			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);

		}
		 
		finally
		{
			TraceOut("conditionalExpressionNoIn", 41);
			LeaveRule("conditionalExpressionNoIn", 41);
			LeaveRule_conditionalExpressionNoIn();
		}
		DebugLocation(852, 1);
		} finally { DebugExitRule(GrammarFileName, "conditionalExpressionNoIn"); }
		return retval;

	}
	// $ANTLR end "conditionalExpressionNoIn"

	partial void EnterRule_assignmentExpression();
	partial void LeaveRule_assignmentExpression();
	// $ANTLR start "assignmentExpression"
	// JavaScript.g:880:1: assignmentExpression : lhs= conditionalExpression ({...}? assignmentOperator ^ assignmentExpression )? ;
	[GrammarRule("assignmentExpression")]
	private AstParserRuleReturnScope<object, IToken> assignmentExpression()
	{
		EnterRule_assignmentExpression();
		EnterRule("assignmentExpression", 42);
		TraceIn("assignmentExpression", 42);
		AstParserRuleReturnScope<object, IToken> retval = new AstParserRuleReturnScope<object, IToken>();
		retval.Start = (IToken)input.LT(1);

		object root_0 = default(object);

		AstParserRuleReturnScope<object, IToken> lhs = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> assignmentOperator131 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> assignmentExpression132 = default(AstParserRuleReturnScope<object, IToken>);


			bool? isLhs = null;

		try { DebugEnterRule(GrammarFileName, "assignmentExpression");
		DebugLocation(880, 1);
		try
		{
			// JavaScript.g:885:2: (lhs= conditionalExpression ({...}? assignmentOperator ^ assignmentExpression )? )
			DebugEnterAlt(1);
			// JavaScript.g:885:4: lhs= conditionalExpression ({...}? assignmentOperator ^ assignmentExpression )?
			{
			root_0 = (object)adaptor.Nil();

			DebugLocation(885, 7);
			PushFollow(Follow._conditionalExpression_in_assignmentExpression4241);
			lhs=conditionalExpression();
			PopFollow();

			adaptor.AddChild(root_0, lhs.Tree);
			DebugLocation(886, 2);
			// JavaScript.g:886:2: ({...}? assignmentOperator ^ assignmentExpression )?
			int alt38=2;
			try { DebugEnterSubRule(38);
			try { DebugEnterDecision(38, false);
			int LA38_1 = input.LA(1);

			if ((LA38_1==ADDASS||LA38_1==ANDASS||LA38_1==ASSIGN||LA38_1==DIVASS||LA38_1==MODASS||LA38_1==MULASS||LA38_1==ORASS||LA38_1==SHLASS||LA38_1==SHRASS||LA38_1==SHUASS||LA38_1==SUBASS||LA38_1==XORASS))
			{
				int LA38_2 = input.LA(2);

				if ((( IsLeftHandSideAssign(lhs, ref isLhs) )))
				{
					alt38 = 1;
				}
			}
			} finally { DebugExitDecision(38); }
			switch (alt38)
			{
			case 1:
				DebugEnterAlt(1);
				// JavaScript.g:886:4: {...}? assignmentOperator ^ assignmentExpression
				{
				DebugLocation(886, 4);
				if (!(( IsLeftHandSideAssign(lhs, ref isLhs) )))
				{
					throw new FailedPredicateException(input, "assignmentExpression", " IsLeftHandSideAssign(lhs, ref isLhs) ");
				}
				DebugLocation(886, 64);
				PushFollow(Follow._assignmentOperator_in_assignmentExpression4248);
				assignmentOperator131=assignmentOperator();
				PopFollow();

				root_0 = (object)adaptor.BecomeRoot(assignmentOperator131.Tree, root_0);
				DebugLocation(886, 66);
				PushFollow(Follow._assignmentExpression_in_assignmentExpression4251);
				assignmentExpression132=assignmentExpression();
				PopFollow();

				adaptor.AddChild(root_0, assignmentExpression132.Tree);

				}
				break;

			}
			} finally { DebugExitSubRule(38); }


			}

			retval.Stop = (IToken)input.LT(-1);

			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);

		}
		 
		finally
		{
			TraceOut("assignmentExpression", 42);
			LeaveRule("assignmentExpression", 42);
			LeaveRule_assignmentExpression();
		}
		DebugLocation(887, 1);
		} finally { DebugExitRule(GrammarFileName, "assignmentExpression"); }
		return retval;

	}
	// $ANTLR end "assignmentExpression"

	partial void EnterRule_assignmentOperator();
	partial void LeaveRule_assignmentOperator();
	// $ANTLR start "assignmentOperator"
	// JavaScript.g:889:1: assignmentOperator : ( ASSIGN | MULASS | DIVASS | MODASS | ADDASS | SUBASS | SHLASS | SHRASS | SHUASS | ANDASS | XORASS | ORASS );
	[GrammarRule("assignmentOperator")]
	private AstParserRuleReturnScope<object, IToken> assignmentOperator()
	{
		EnterRule_assignmentOperator();
		EnterRule("assignmentOperator", 43);
		TraceIn("assignmentOperator", 43);
		AstParserRuleReturnScope<object, IToken> retval = new AstParserRuleReturnScope<object, IToken>();
		retval.Start = (IToken)input.LT(1);

		object root_0 = default(object);

		IToken set133 = default(IToken);

		object set133_tree = default(object);
		try { DebugEnterRule(GrammarFileName, "assignmentOperator");
		DebugLocation(889, 1);
		try
		{
			// JavaScript.g:890:2: ( ASSIGN | MULASS | DIVASS | MODASS | ADDASS | SUBASS | SHLASS | SHRASS | SHUASS | ANDASS | XORASS | ORASS )
			DebugEnterAlt(1);
			// JavaScript.g:
			{
			root_0 = (object)adaptor.Nil();

			DebugLocation(890, 2);

			set133=(IToken)input.LT(1);
			if (input.LA(1)==ADDASS||input.LA(1)==ANDASS||input.LA(1)==ASSIGN||input.LA(1)==DIVASS||input.LA(1)==MODASS||input.LA(1)==MULASS||input.LA(1)==ORASS||input.LA(1)==SHLASS||input.LA(1)==SHRASS||input.LA(1)==SHUASS||input.LA(1)==SUBASS||input.LA(1)==XORASS)
			{
				input.Consume();
				adaptor.AddChild(root_0, (object)adaptor.Create(set133));
				state.errorRecovery=false;
			}
			else
			{
				MismatchedSetException mse = new MismatchedSetException(null,input);
				DebugRecognitionException(mse);
				throw mse;
			}


			}

			retval.Stop = (IToken)input.LT(-1);

			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);

		}
		 
		finally
		{
			TraceOut("assignmentOperator", 43);
			LeaveRule("assignmentOperator", 43);
			LeaveRule_assignmentOperator();
		}
		DebugLocation(891, 1);
		} finally { DebugExitRule(GrammarFileName, "assignmentOperator"); }
		return retval;

	}
	// $ANTLR end "assignmentOperator"

	partial void EnterRule_assignmentExpressionNoIn();
	partial void LeaveRule_assignmentExpressionNoIn();
	// $ANTLR start "assignmentExpressionNoIn"
	// JavaScript.g:893:1: assignmentExpressionNoIn : lhs= conditionalExpressionNoIn ({...}? assignmentOperator ^ assignmentExpressionNoIn )? ;
	[GrammarRule("assignmentExpressionNoIn")]
	private AstParserRuleReturnScope<object, IToken> assignmentExpressionNoIn()
	{
		EnterRule_assignmentExpressionNoIn();
		EnterRule("assignmentExpressionNoIn", 44);
		TraceIn("assignmentExpressionNoIn", 44);
		AstParserRuleReturnScope<object, IToken> retval = new AstParserRuleReturnScope<object, IToken>();
		retval.Start = (IToken)input.LT(1);

		object root_0 = default(object);

		AstParserRuleReturnScope<object, IToken> lhs = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> assignmentOperator134 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> assignmentExpressionNoIn135 = default(AstParserRuleReturnScope<object, IToken>);


			bool? isLhs = null;

		try { DebugEnterRule(GrammarFileName, "assignmentExpressionNoIn");
		DebugLocation(893, 1);
		try
		{
			// JavaScript.g:898:2: (lhs= conditionalExpressionNoIn ({...}? assignmentOperator ^ assignmentExpressionNoIn )? )
			DebugEnterAlt(1);
			// JavaScript.g:898:4: lhs= conditionalExpressionNoIn ({...}? assignmentOperator ^ assignmentExpressionNoIn )?
			{
			root_0 = (object)adaptor.Nil();

			DebugLocation(898, 7);
			PushFollow(Follow._conditionalExpressionNoIn_in_assignmentExpressionNoIn4328);
			lhs=conditionalExpressionNoIn();
			PopFollow();

			adaptor.AddChild(root_0, lhs.Tree);
			DebugLocation(899, 2);
			// JavaScript.g:899:2: ({...}? assignmentOperator ^ assignmentExpressionNoIn )?
			int alt39=2;
			try { DebugEnterSubRule(39);
			try { DebugEnterDecision(39, false);
			int LA39_1 = input.LA(1);

			if ((LA39_1==ADDASS||LA39_1==ANDASS||LA39_1==ASSIGN||LA39_1==DIVASS||LA39_1==MODASS||LA39_1==MULASS||LA39_1==ORASS||LA39_1==SHLASS||LA39_1==SHRASS||LA39_1==SHUASS||LA39_1==SUBASS||LA39_1==XORASS))
			{
				int LA39_2 = input.LA(2);

				if ((( IsLeftHandSideAssign(lhs, ref isLhs) )))
				{
					alt39 = 1;
				}
			}
			} finally { DebugExitDecision(39); }
			switch (alt39)
			{
			case 1:
				DebugEnterAlt(1);
				// JavaScript.g:899:4: {...}? assignmentOperator ^ assignmentExpressionNoIn
				{
				DebugLocation(899, 4);
				if (!(( IsLeftHandSideAssign(lhs, ref isLhs) )))
				{
					throw new FailedPredicateException(input, "assignmentExpressionNoIn", " IsLeftHandSideAssign(lhs, ref isLhs) ");
				}
				DebugLocation(899, 64);
				PushFollow(Follow._assignmentOperator_in_assignmentExpressionNoIn4335);
				assignmentOperator134=assignmentOperator();
				PopFollow();

				root_0 = (object)adaptor.BecomeRoot(assignmentOperator134.Tree, root_0);
				DebugLocation(899, 66);
				PushFollow(Follow._assignmentExpressionNoIn_in_assignmentExpressionNoIn4338);
				assignmentExpressionNoIn135=assignmentExpressionNoIn();
				PopFollow();

				adaptor.AddChild(root_0, assignmentExpressionNoIn135.Tree);

				}
				break;

			}
			} finally { DebugExitSubRule(39); }


			}

			retval.Stop = (IToken)input.LT(-1);

			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);

		}
		 
		finally
		{
			TraceOut("assignmentExpressionNoIn", 44);
			LeaveRule("assignmentExpressionNoIn", 44);
			LeaveRule_assignmentExpressionNoIn();
		}
		DebugLocation(900, 1);
		} finally { DebugExitRule(GrammarFileName, "assignmentExpressionNoIn"); }
		return retval;

	}
	// $ANTLR end "assignmentExpressionNoIn"

	partial void EnterRule_expression();
	partial void LeaveRule_expression();
	// $ANTLR start "expression"
	// JavaScript.g:906:1: expression :exprs+= assignmentExpression ( COMMA exprs+= assignmentExpression )* -> { $exprs.Count > 1 }? ^( CEXPR ( $exprs)+ ) -> $exprs;
	[GrammarRule("expression")]
	private AstParserRuleReturnScope<object, IToken> expression()
	{
		EnterRule_expression();
		EnterRule("expression", 45);
		TraceIn("expression", 45);
		AstParserRuleReturnScope<object, IToken> retval = new AstParserRuleReturnScope<object, IToken>();
		retval.Start = (IToken)input.LT(1);

		object root_0 = default(object);

		IToken COMMA136 = default(IToken);
		List<object> list_exprs = null;
		AstParserRuleReturnScope<object, IToken> exprs = default(AstParserRuleReturnScope<object, IToken>);
		object COMMA136_tree = default(object);
		RewriteRuleITokenStream stream_COMMA=new RewriteRuleITokenStream(adaptor,"token COMMA");
		RewriteRuleSubtreeStream stream_assignmentExpression=new RewriteRuleSubtreeStream(adaptor,"rule assignmentExpression");
		try { DebugEnterRule(GrammarFileName, "expression");
		DebugLocation(906, 1);
		try
		{
			// JavaScript.g:907:2: (exprs+= assignmentExpression ( COMMA exprs+= assignmentExpression )* -> { $exprs.Count > 1 }? ^( CEXPR ( $exprs)+ ) -> $exprs)
			DebugEnterAlt(1);
			// JavaScript.g:907:4: exprs+= assignmentExpression ( COMMA exprs+= assignmentExpression )*
			{
			DebugLocation(907, 9);
			PushFollow(Follow._assignmentExpression_in_expression4360);
			exprs=assignmentExpression();
			PopFollow();

			stream_assignmentExpression.Add(exprs.Tree);
			if (list_exprs==null) list_exprs=new List<object>();
			list_exprs.Add(exprs.Tree);

			DebugLocation(907, 32);
			// JavaScript.g:907:32: ( COMMA exprs+= assignmentExpression )*
			try { DebugEnterSubRule(40);
			while (true)
			{
				int alt40=2;
				try { DebugEnterDecision(40, false);
				int LA40_1 = input.LA(1);

				if ((LA40_1==COMMA))
				{
					alt40 = 1;
				}


				} finally { DebugExitDecision(40); }
				switch ( alt40 )
				{
				case 1:
					DebugEnterAlt(1);
					// JavaScript.g:907:34: COMMA exprs+= assignmentExpression
					{
					DebugLocation(907, 34);
					COMMA136=(IToken)Match(input,COMMA,Follow._COMMA_in_expression4364);  
					stream_COMMA.Add(COMMA136);

					DebugLocation(907, 45);
					PushFollow(Follow._assignmentExpression_in_expression4368);
					exprs=assignmentExpression();
					PopFollow();

					stream_assignmentExpression.Add(exprs.Tree);
					if (list_exprs==null) list_exprs=new List<object>();
					list_exprs.Add(exprs.Tree);


					}
					break;

				default:
					goto loop40;
				}
			}

			loop40:
				;

			} finally { DebugExitSubRule(40); }



			{
			// AST REWRITE
			// elements: exprs, exprs
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: exprs
			// wildcard labels: 
			retval.Tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);
			RewriteRuleSubtreeStream stream_exprs=new RewriteRuleSubtreeStream(adaptor,"token exprs",list_exprs);
			root_0 = (object)adaptor.Nil();
			// 908:2: -> { $exprs.Count > 1 }? ^( CEXPR ( $exprs)+ )
			if ( list_exprs.Count > 1 )
			{
				DebugLocation(908, 27);
				// JavaScript.g:908:27: ^( CEXPR ( $exprs)+ )
				{
				object root_1 = (object)adaptor.Nil();
				DebugLocation(908, 30);
				root_1 = (object)adaptor.BecomeRoot((object)adaptor.Create(CEXPR, "CEXPR"), root_1);

				DebugLocation(908, 37);
				if (!(stream_exprs.HasNext))
				{
					throw new RewriteEarlyExitException();
				}
				while ( stream_exprs.HasNext )
				{
					DebugLocation(908, 37);
					adaptor.AddChild(root_1, stream_exprs.NextTree());

				}
				stream_exprs.Reset();

				adaptor.AddChild(root_0, root_1);
				}

			}
			else // 909:2: -> $exprs
			{
				DebugLocation(909, 6);
				adaptor.AddChild(root_0, stream_exprs.NextTree());

			}

			retval.Tree = root_0;
			}

			}

			retval.Stop = (IToken)input.LT(-1);

			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);

		}
		 
		finally
		{
			TraceOut("expression", 45);
			LeaveRule("expression", 45);
			LeaveRule_expression();
		}
		DebugLocation(910, 1);
		} finally { DebugExitRule(GrammarFileName, "expression"); }
		return retval;

	}
	// $ANTLR end "expression"

	partial void EnterRule_expressionNoIn();
	partial void LeaveRule_expressionNoIn();
	// $ANTLR start "expressionNoIn"
	// JavaScript.g:912:1: expressionNoIn :exprs+= assignmentExpressionNoIn ( COMMA exprs+= assignmentExpressionNoIn )* -> { $exprs.Count > 1 }? ^( CEXPR ( $exprs)+ ) -> $exprs;
	[GrammarRule("expressionNoIn")]
	private AstParserRuleReturnScope<object, IToken> expressionNoIn()
	{
		EnterRule_expressionNoIn();
		EnterRule("expressionNoIn", 46);
		TraceIn("expressionNoIn", 46);
		AstParserRuleReturnScope<object, IToken> retval = new AstParserRuleReturnScope<object, IToken>();
		retval.Start = (IToken)input.LT(1);

		object root_0 = default(object);

		IToken COMMA137 = default(IToken);
		List<object> list_exprs = null;
		AstParserRuleReturnScope<object, IToken> exprs = default(AstParserRuleReturnScope<object, IToken>);
		object COMMA137_tree = default(object);
		RewriteRuleITokenStream stream_COMMA=new RewriteRuleITokenStream(adaptor,"token COMMA");
		RewriteRuleSubtreeStream stream_assignmentExpressionNoIn=new RewriteRuleSubtreeStream(adaptor,"rule assignmentExpressionNoIn");
		try { DebugEnterRule(GrammarFileName, "expressionNoIn");
		DebugLocation(912, 1);
		try
		{
			// JavaScript.g:913:2: (exprs+= assignmentExpressionNoIn ( COMMA exprs+= assignmentExpressionNoIn )* -> { $exprs.Count > 1 }? ^( CEXPR ( $exprs)+ ) -> $exprs)
			DebugEnterAlt(1);
			// JavaScript.g:913:4: exprs+= assignmentExpressionNoIn ( COMMA exprs+= assignmentExpressionNoIn )*
			{
			DebugLocation(913, 9);
			PushFollow(Follow._assignmentExpressionNoIn_in_expressionNoIn4405);
			exprs=assignmentExpressionNoIn();
			PopFollow();

			stream_assignmentExpressionNoIn.Add(exprs.Tree);
			if (list_exprs==null) list_exprs=new List<object>();
			list_exprs.Add(exprs.Tree);

			DebugLocation(913, 36);
			// JavaScript.g:913:36: ( COMMA exprs+= assignmentExpressionNoIn )*
			try { DebugEnterSubRule(41);
			while (true)
			{
				int alt41=2;
				try { DebugEnterDecision(41, false);
				int LA41_1 = input.LA(1);

				if ((LA41_1==COMMA))
				{
					alt41 = 1;
				}


				} finally { DebugExitDecision(41); }
				switch ( alt41 )
				{
				case 1:
					DebugEnterAlt(1);
					// JavaScript.g:913:38: COMMA exprs+= assignmentExpressionNoIn
					{
					DebugLocation(913, 38);
					COMMA137=(IToken)Match(input,COMMA,Follow._COMMA_in_expressionNoIn4409);  
					stream_COMMA.Add(COMMA137);

					DebugLocation(913, 49);
					PushFollow(Follow._assignmentExpressionNoIn_in_expressionNoIn4413);
					exprs=assignmentExpressionNoIn();
					PopFollow();

					stream_assignmentExpressionNoIn.Add(exprs.Tree);
					if (list_exprs==null) list_exprs=new List<object>();
					list_exprs.Add(exprs.Tree);


					}
					break;

				default:
					goto loop41;
				}
			}

			loop41:
				;

			} finally { DebugExitSubRule(41); }



			{
			// AST REWRITE
			// elements: exprs, exprs
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: exprs
			// wildcard labels: 
			retval.Tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);
			RewriteRuleSubtreeStream stream_exprs=new RewriteRuleSubtreeStream(adaptor,"token exprs",list_exprs);
			root_0 = (object)adaptor.Nil();
			// 914:2: -> { $exprs.Count > 1 }? ^( CEXPR ( $exprs)+ )
			if ( list_exprs.Count > 1 )
			{
				DebugLocation(914, 27);
				// JavaScript.g:914:27: ^( CEXPR ( $exprs)+ )
				{
				object root_1 = (object)adaptor.Nil();
				DebugLocation(914, 30);
				root_1 = (object)adaptor.BecomeRoot((object)adaptor.Create(CEXPR, "CEXPR"), root_1);

				DebugLocation(914, 37);
				if (!(stream_exprs.HasNext))
				{
					throw new RewriteEarlyExitException();
				}
				while ( stream_exprs.HasNext )
				{
					DebugLocation(914, 37);
					adaptor.AddChild(root_1, stream_exprs.NextTree());

				}
				stream_exprs.Reset();

				adaptor.AddChild(root_0, root_1);
				}

			}
			else // 915:2: -> $exprs
			{
				DebugLocation(915, 6);
				adaptor.AddChild(root_0, stream_exprs.NextTree());

			}

			retval.Tree = root_0;
			}

			}

			retval.Stop = (IToken)input.LT(-1);

			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);

		}
		 
		finally
		{
			TraceOut("expressionNoIn", 46);
			LeaveRule("expressionNoIn", 46);
			LeaveRule_expressionNoIn();
		}
		DebugLocation(916, 1);
		} finally { DebugExitRule(GrammarFileName, "expressionNoIn"); }
		return retval;

	}
	// $ANTLR end "expressionNoIn"

	partial void EnterRule_semic();
	partial void LeaveRule_semic();
	// $ANTLR start "semic"
	// JavaScript.g:940:1: semic : ( SEMIC | EOF | RBRACE | EOL | MultiLineComment );
	[GrammarRule("semic")]
	private AstParserRuleReturnScope<object, IToken> semic()
	{
		EnterRule_semic();
		EnterRule("semic", 47);
		TraceIn("semic", 47);
		AstParserRuleReturnScope<object, IToken> retval = new AstParserRuleReturnScope<object, IToken>();
		retval.Start = (IToken)input.LT(1);

		object root_0 = default(object);

		IToken SEMIC138 = default(IToken);
		IToken EOF139 = default(IToken);
		IToken RBRACE140 = default(IToken);
		IToken EOL141 = default(IToken);
		IToken MultiLineComment142 = default(IToken);

		object SEMIC138_tree = default(object);
		object EOF139_tree = default(object);
		object RBRACE140_tree = default(object);
		object EOL141_tree = default(object);
		object MultiLineComment142_tree = default(object);

			// Mark current position so we can unconsume a RBRACE.
			int marker = input.Mark();
			// Promote EOL if appropriate	
			PromoteEol(retval);

		try { DebugEnterRule(GrammarFileName, "semic");
		DebugLocation(940, 1);
		try
		{
			// JavaScript.g:948:2: ( SEMIC | EOF | RBRACE | EOL | MultiLineComment )
			int alt42=5;
			try { DebugEnterDecision(42, false);
			switch (input.LA(1))
			{
			case SEMIC:
				{
				alt42 = 1;
				}
				break;
			case EOF:
				{
				alt42 = 2;
				}
				break;
			case RBRACE:
				{
				alt42 = 3;
				}
				break;
			case EOL:
				{
				alt42 = 4;
				}
				break;
			case MultiLineComment:
				{
				alt42 = 5;
				}
				break;
			default:
				{
					NoViableAltException nvae = new NoViableAltException("", 42, 0, input, 1);
					DebugRecognitionException(nvae);
					throw nvae;
				}
			}

			} finally { DebugExitDecision(42); }
			switch (alt42)
			{
			case 1:
				DebugEnterAlt(1);
				// JavaScript.g:948:4: SEMIC
				{
				root_0 = (object)adaptor.Nil();

				DebugLocation(948, 4);
				SEMIC138=(IToken)Match(input,SEMIC,Follow._SEMIC_in_semic4464); 
				SEMIC138_tree = (object)adaptor.Create(SEMIC138);
				adaptor.AddChild(root_0, SEMIC138_tree);

				}
				break;
			case 2:
				DebugEnterAlt(2);
				// JavaScript.g:949:4: EOF
				{
				root_0 = (object)adaptor.Nil();

				DebugLocation(949, 4);
				EOF139=(IToken)Match(input,EOF,Follow._EOF_in_semic4469); 
				EOF139_tree = (object)adaptor.Create(EOF139);
				adaptor.AddChild(root_0, EOF139_tree);

				}
				break;
			case 3:
				DebugEnterAlt(3);
				// JavaScript.g:950:4: RBRACE
				{
				root_0 = (object)adaptor.Nil();

				DebugLocation(950, 4);
				RBRACE140=(IToken)Match(input,RBRACE,Follow._RBRACE_in_semic4474); 
				RBRACE140_tree = (object)adaptor.Create(RBRACE140);
				adaptor.AddChild(root_0, RBRACE140_tree);
				DebugLocation(950, 11);
				 input.Rewind(marker); 

				}
				break;
			case 4:
				DebugEnterAlt(4);
				// JavaScript.g:951:4: EOL
				{
				root_0 = (object)adaptor.Nil();

				DebugLocation(951, 4);
				EOL141=(IToken)Match(input,EOL,Follow._EOL_in_semic4481); 
				EOL141_tree = (object)adaptor.Create(EOL141);
				adaptor.AddChild(root_0, EOL141_tree);

				}
				break;
			case 5:
				DebugEnterAlt(5);
				// JavaScript.g:951:10: MultiLineComment
				{
				root_0 = (object)adaptor.Nil();

				DebugLocation(951, 10);
				MultiLineComment142=(IToken)Match(input,MultiLineComment,Follow._MultiLineComment_in_semic4485); 
				MultiLineComment142_tree = (object)adaptor.Create(MultiLineComment142);
				adaptor.AddChild(root_0, MultiLineComment142_tree);

				}
				break;

			}
			retval.Stop = (IToken)input.LT(-1);

			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);

		}
		 
		finally
		{
			TraceOut("semic", 47);
			LeaveRule("semic", 47);
			LeaveRule_semic();
		}
		DebugLocation(952, 1);
		} finally { DebugExitRule(GrammarFileName, "semic"); }
		return retval;

	}
	// $ANTLR end "semic"

	partial void EnterRule_statement();
	partial void LeaveRule_statement();
	// $ANTLR start "statement"
	// JavaScript.g:959:1: statement options {k=1; } : ({...}? block | statementTail );
	[GrammarRule("statement")]
	private AstParserRuleReturnScope<object, IToken> statement()
	{
		EnterRule_statement();
		EnterRule("statement", 48);
		TraceIn("statement", 48);
		AstParserRuleReturnScope<object, IToken> retval = new AstParserRuleReturnScope<object, IToken>();
		retval.Start = (IToken)input.LT(1);

		object root_0 = default(object);

		AstParserRuleReturnScope<object, IToken> block143 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> statementTail144 = default(AstParserRuleReturnScope<object, IToken>);

		try { DebugEnterRule(GrammarFileName, "statement");
		DebugLocation(959, 1);
		try
		{
			// JavaScript.g:964:2: ({...}? block | statementTail )
			int alt43=2;
			try { DebugEnterDecision(43, false);
			int LA43_1 = input.LA(1);

			if ((LA43_1==LBRACE))
			{
				int LA43_2 = input.LA(2);

				if ((( input.LA(1) == LBRACE )))
				{
					alt43 = 1;
				}
				else if ((true))
				{
					alt43 = 2;
				}
				else
				{
					NoViableAltException nvae = new NoViableAltException("", 43, 1, input, 2);
					DebugRecognitionException(nvae);
					throw nvae;
				}
			}
			else if ((LA43_1==ADD||LA43_1==BREAK||LA43_1==CONTINUE||LA43_1==DEC||LA43_1==DELETE||LA43_1==DO||LA43_1==DecimalLiteral||LA43_1==FALSE||LA43_1==FOR||LA43_1==FUNCTION||(LA43_1>=HexIntegerLiteral && LA43_1<=IF)||LA43_1==INC||LA43_1==INV||LA43_1==Identifier||LA43_1==LBRACK||LA43_1==LPAREN||(LA43_1>=NEW && LA43_1<=NOT)||LA43_1==NULL||LA43_1==OctalIntegerLiteral||LA43_1==RETURN||LA43_1==RegularExpressionLiteral||LA43_1==SEMIC||LA43_1==SUB||LA43_1==SWITCH||LA43_1==StringLiteral||(LA43_1>=THIS && LA43_1<=THROW)||(LA43_1>=TRUE && LA43_1<=TYPEOF)||(LA43_1>=VAR && LA43_1<=VOID)||(LA43_1>=WHILE && LA43_1<=WITH)))
			{
				alt43 = 2;
			}
			else
			{
				NoViableAltException nvae = new NoViableAltException("", 43, 0, input, 1);
				DebugRecognitionException(nvae);
				throw nvae;
			}
			} finally { DebugExitDecision(43); }
			switch (alt43)
			{
			case 1:
				DebugEnterAlt(1);
				// JavaScript.g:964:4: {...}? block
				{
				root_0 = (object)adaptor.Nil();

				DebugLocation(964, 4);
				if (!(( input.LA(1) == LBRACE )))
				{
					throw new FailedPredicateException(input, "statement", " input.LA(1) == LBRACE ");
				}
				DebugLocation(964, 31);
				PushFollow(Follow._block_in_statement4514);
				block143=block();
				PopFollow();

				adaptor.AddChild(root_0, block143.Tree);

				}
				break;
			case 2:
				DebugEnterAlt(2);
				// JavaScript.g:965:4: statementTail
				{
				root_0 = (object)adaptor.Nil();

				DebugLocation(965, 4);
				PushFollow(Follow._statementTail_in_statement4519);
				statementTail144=statementTail();
				PopFollow();

				adaptor.AddChild(root_0, statementTail144.Tree);

				}
				break;

			}
			retval.Stop = (IToken)input.LT(-1);

			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);

		}
		 
		finally
		{
			TraceOut("statement", 48);
			LeaveRule("statement", 48);
			LeaveRule_statement();
		}
		DebugLocation(966, 1);
		} finally { DebugExitRule(GrammarFileName, "statement"); }
		return retval;

	}
	// $ANTLR end "statement"

	partial void EnterRule_statementTail();
	partial void LeaveRule_statementTail();
	// $ANTLR start "statementTail"
	// JavaScript.g:968:1: statementTail : ( variableStatement | emptyStatement | expressionStatement | ifStatement | iterationStatement | continueStatement | breakStatement | returnStatement | withStatement | labelledStatement | switchStatement | throwStatement | tryStatement );
	[GrammarRule("statementTail")]
	private AstParserRuleReturnScope<object, IToken> statementTail()
	{
		EnterRule_statementTail();
		EnterRule("statementTail", 49);
		TraceIn("statementTail", 49);
		AstParserRuleReturnScope<object, IToken> retval = new AstParserRuleReturnScope<object, IToken>();
		retval.Start = (IToken)input.LT(1);

		object root_0 = default(object);

		AstParserRuleReturnScope<object, IToken> variableStatement145 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> emptyStatement146 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> expressionStatement147 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> ifStatement148 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> iterationStatement149 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> continueStatement150 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> breakStatement151 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> returnStatement152 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> withStatement153 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> labelledStatement154 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> switchStatement155 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> throwStatement156 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> tryStatement157 = default(AstParserRuleReturnScope<object, IToken>);

		try { DebugEnterRule(GrammarFileName, "statementTail");
		DebugLocation(968, 1);
		try
		{
			// JavaScript.g:969:2: ( variableStatement | emptyStatement | expressionStatement | ifStatement | iterationStatement | continueStatement | breakStatement | returnStatement | withStatement | labelledStatement | switchStatement | throwStatement | tryStatement )
			int alt44=13;
			try { DebugEnterDecision(44, false);
			switch (input.LA(1))
			{
			case VAR:
				{
				alt44 = 1;
				}
				break;
			case SEMIC:
				{
				alt44 = 2;
				}
				break;
			case ADD:
			case DEC:
			case DELETE:
			case DecimalLiteral:
			case FALSE:
			case FUNCTION:
			case HexIntegerLiteral:
			case INC:
			case INV:
			case LBRACE:
			case LBRACK:
			case LPAREN:
			case NEW:
			case NOT:
			case NULL:
			case OctalIntegerLiteral:
			case RegularExpressionLiteral:
			case SUB:
			case StringLiteral:
			case THIS:
			case TRUE:
			case TYPEOF:
			case VOID:
				{
				alt44 = 3;
				}
				break;
			case Identifier:
				{
				int LA44_2 = input.LA(2);

				if ((LA44_2==COLON))
				{
					alt44 = 10;
				}
				else if ((LA44_2==EOF||(LA44_2>=ADD && LA44_2<=ANDASS)||LA44_2==ASSIGN||LA44_2==COMMA||LA44_2==DEC||(LA44_2>=DIV && LA44_2<=DIVASS)||LA44_2==DOT||(LA44_2>=EOL && LA44_2<=EQ)||(LA44_2>=GT && LA44_2<=GTE)||(LA44_2>=IN && LA44_2<=INSTANCEOF)||LA44_2==LAND||LA44_2==LBRACK||(LA44_2>=LOR && LA44_2<=LPAREN)||(LA44_2>=LT && LA44_2<=LTE)||(LA44_2>=MOD && LA44_2<=MultiLineComment)||LA44_2==NEQ||LA44_2==NSAME||(LA44_2>=OR && LA44_2<=ORASS)||(LA44_2>=QUE && LA44_2<=RBRACE)||(LA44_2>=SAME && LA44_2<=SHLASS)||(LA44_2>=SHR && LA44_2<=SHUASS)||(LA44_2>=SUB && LA44_2<=SUBASS)||(LA44_2>=XOR && LA44_2<=XORASS)))
				{
					alt44 = 3;
				}
				else
				{
					NoViableAltException nvae = new NoViableAltException("", 44, 4, input, 2);
					DebugRecognitionException(nvae);
					throw nvae;
				}
				}
				break;
			case IF:
				{
				alt44 = 4;
				}
				break;
			case DO:
			case FOR:
			case WHILE:
				{
				alt44 = 5;
				}
				break;
			case CONTINUE:
				{
				alt44 = 6;
				}
				break;
			case BREAK:
				{
				alt44 = 7;
				}
				break;
			case RETURN:
				{
				alt44 = 8;
				}
				break;
			case WITH:
				{
				alt44 = 9;
				}
				break;
			case SWITCH:
				{
				alt44 = 11;
				}
				break;
			case THROW:
				{
				alt44 = 12;
				}
				break;
			case TRY:
				{
				alt44 = 13;
				}
				break;
			default:
				{
					NoViableAltException nvae = new NoViableAltException("", 44, 0, input, 1);
					DebugRecognitionException(nvae);
					throw nvae;
				}
			}

			} finally { DebugExitDecision(44); }
			switch (alt44)
			{
			case 1:
				DebugEnterAlt(1);
				// JavaScript.g:969:4: variableStatement
				{
				root_0 = (object)adaptor.Nil();

				DebugLocation(969, 4);
				PushFollow(Follow._variableStatement_in_statementTail4531);
				variableStatement145=variableStatement();
				PopFollow();

				adaptor.AddChild(root_0, variableStatement145.Tree);

				}
				break;
			case 2:
				DebugEnterAlt(2);
				// JavaScript.g:970:4: emptyStatement
				{
				root_0 = (object)adaptor.Nil();

				DebugLocation(970, 4);
				PushFollow(Follow._emptyStatement_in_statementTail4536);
				emptyStatement146=emptyStatement();
				PopFollow();

				adaptor.AddChild(root_0, emptyStatement146.Tree);

				}
				break;
			case 3:
				DebugEnterAlt(3);
				// JavaScript.g:971:4: expressionStatement
				{
				root_0 = (object)adaptor.Nil();

				DebugLocation(971, 4);
				PushFollow(Follow._expressionStatement_in_statementTail4541);
				expressionStatement147=expressionStatement();
				PopFollow();

				adaptor.AddChild(root_0, expressionStatement147.Tree);

				}
				break;
			case 4:
				DebugEnterAlt(4);
				// JavaScript.g:972:4: ifStatement
				{
				root_0 = (object)adaptor.Nil();

				DebugLocation(972, 4);
				PushFollow(Follow._ifStatement_in_statementTail4546);
				ifStatement148=ifStatement();
				PopFollow();

				adaptor.AddChild(root_0, ifStatement148.Tree);

				}
				break;
			case 5:
				DebugEnterAlt(5);
				// JavaScript.g:973:4: iterationStatement
				{
				root_0 = (object)adaptor.Nil();

				DebugLocation(973, 4);
				PushFollow(Follow._iterationStatement_in_statementTail4551);
				iterationStatement149=iterationStatement();
				PopFollow();

				adaptor.AddChild(root_0, iterationStatement149.Tree);

				}
				break;
			case 6:
				DebugEnterAlt(6);
				// JavaScript.g:974:4: continueStatement
				{
				root_0 = (object)adaptor.Nil();

				DebugLocation(974, 4);
				PushFollow(Follow._continueStatement_in_statementTail4556);
				continueStatement150=continueStatement();
				PopFollow();

				adaptor.AddChild(root_0, continueStatement150.Tree);

				}
				break;
			case 7:
				DebugEnterAlt(7);
				// JavaScript.g:975:4: breakStatement
				{
				root_0 = (object)adaptor.Nil();

				DebugLocation(975, 4);
				PushFollow(Follow._breakStatement_in_statementTail4561);
				breakStatement151=breakStatement();
				PopFollow();

				adaptor.AddChild(root_0, breakStatement151.Tree);

				}
				break;
			case 8:
				DebugEnterAlt(8);
				// JavaScript.g:976:4: returnStatement
				{
				root_0 = (object)adaptor.Nil();

				DebugLocation(976, 4);
				PushFollow(Follow._returnStatement_in_statementTail4566);
				returnStatement152=returnStatement();
				PopFollow();

				adaptor.AddChild(root_0, returnStatement152.Tree);

				}
				break;
			case 9:
				DebugEnterAlt(9);
				// JavaScript.g:977:4: withStatement
				{
				root_0 = (object)adaptor.Nil();

				DebugLocation(977, 4);
				PushFollow(Follow._withStatement_in_statementTail4571);
				withStatement153=withStatement();
				PopFollow();

				adaptor.AddChild(root_0, withStatement153.Tree);

				}
				break;
			case 10:
				DebugEnterAlt(10);
				// JavaScript.g:978:4: labelledStatement
				{
				root_0 = (object)adaptor.Nil();

				DebugLocation(978, 4);
				PushFollow(Follow._labelledStatement_in_statementTail4576);
				labelledStatement154=labelledStatement();
				PopFollow();

				adaptor.AddChild(root_0, labelledStatement154.Tree);

				}
				break;
			case 11:
				DebugEnterAlt(11);
				// JavaScript.g:979:4: switchStatement
				{
				root_0 = (object)adaptor.Nil();

				DebugLocation(979, 4);
				PushFollow(Follow._switchStatement_in_statementTail4581);
				switchStatement155=switchStatement();
				PopFollow();

				adaptor.AddChild(root_0, switchStatement155.Tree);

				}
				break;
			case 12:
				DebugEnterAlt(12);
				// JavaScript.g:980:4: throwStatement
				{
				root_0 = (object)adaptor.Nil();

				DebugLocation(980, 4);
				PushFollow(Follow._throwStatement_in_statementTail4586);
				throwStatement156=throwStatement();
				PopFollow();

				adaptor.AddChild(root_0, throwStatement156.Tree);

				}
				break;
			case 13:
				DebugEnterAlt(13);
				// JavaScript.g:981:4: tryStatement
				{
				root_0 = (object)adaptor.Nil();

				DebugLocation(981, 4);
				PushFollow(Follow._tryStatement_in_statementTail4591);
				tryStatement157=tryStatement();
				PopFollow();

				adaptor.AddChild(root_0, tryStatement157.Tree);

				}
				break;

			}
			retval.Stop = (IToken)input.LT(-1);

			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);

		}
		 
		finally
		{
			TraceOut("statementTail", 49);
			LeaveRule("statementTail", 49);
			LeaveRule_statementTail();
		}
		DebugLocation(982, 1);
		} finally { DebugExitRule(GrammarFileName, "statementTail"); }
		return retval;

	}
	// $ANTLR end "statementTail"

	partial void EnterRule_block();
	partial void LeaveRule_block();
	// $ANTLR start "block"
	// JavaScript.g:986:1: block : lb= LBRACE ( statement )* RBRACE -> ^( BLOCK[$lb, \"BLOCK\"] ( statement )* ) ;
	[GrammarRule("block")]
	private AstParserRuleReturnScope<object, IToken> block()
	{
		EnterRule_block();
		EnterRule("block", 50);
		TraceIn("block", 50);
		AstParserRuleReturnScope<object, IToken> retval = new AstParserRuleReturnScope<object, IToken>();
		retval.Start = (IToken)input.LT(1);

		object root_0 = default(object);

		IToken lb = default(IToken);
		IToken RBRACE159 = default(IToken);
		AstParserRuleReturnScope<object, IToken> statement158 = default(AstParserRuleReturnScope<object, IToken>);

		object lb_tree = default(object);
		object RBRACE159_tree = default(object);
		RewriteRuleITokenStream stream_LBRACE=new RewriteRuleITokenStream(adaptor,"token LBRACE");
		RewriteRuleITokenStream stream_RBRACE=new RewriteRuleITokenStream(adaptor,"token RBRACE");
		RewriteRuleSubtreeStream stream_statement=new RewriteRuleSubtreeStream(adaptor,"rule statement");
		try { DebugEnterRule(GrammarFileName, "block");
		DebugLocation(986, 1);
		try
		{
			// JavaScript.g:987:2: (lb= LBRACE ( statement )* RBRACE -> ^( BLOCK[$lb, \"BLOCK\"] ( statement )* ) )
			DebugEnterAlt(1);
			// JavaScript.g:987:4: lb= LBRACE ( statement )* RBRACE
			{
			DebugLocation(987, 6);
			lb=(IToken)Match(input,LBRACE,Follow._LBRACE_in_block4606);  
			stream_LBRACE.Add(lb);

			DebugLocation(987, 14);
			// JavaScript.g:987:14: ( statement )*
			try { DebugEnterSubRule(45);
			while (true)
			{
				int alt45=2;
				try { DebugEnterDecision(45, false);
				int LA45_1 = input.LA(1);

				if ((LA45_1==ADD||LA45_1==BREAK||LA45_1==CONTINUE||LA45_1==DEC||LA45_1==DELETE||LA45_1==DO||LA45_1==DecimalLiteral||LA45_1==FALSE||LA45_1==FOR||LA45_1==FUNCTION||(LA45_1>=HexIntegerLiteral && LA45_1<=IF)||LA45_1==INC||LA45_1==INV||LA45_1==Identifier||(LA45_1>=LBRACE && LA45_1<=LBRACK)||LA45_1==LPAREN||(LA45_1>=NEW && LA45_1<=NOT)||LA45_1==NULL||LA45_1==OctalIntegerLiteral||LA45_1==RETURN||LA45_1==RegularExpressionLiteral||LA45_1==SEMIC||LA45_1==SUB||LA45_1==SWITCH||LA45_1==StringLiteral||(LA45_1>=THIS && LA45_1<=THROW)||(LA45_1>=TRUE && LA45_1<=TYPEOF)||(LA45_1>=VAR && LA45_1<=VOID)||(LA45_1>=WHILE && LA45_1<=WITH)))
				{
					alt45 = 1;
				}


				} finally { DebugExitDecision(45); }
				switch ( alt45 )
				{
				case 1:
					DebugEnterAlt(1);
					// JavaScript.g:987:14: statement
					{
					DebugLocation(987, 14);
					PushFollow(Follow._statement_in_block4608);
					statement158=statement();
					PopFollow();

					stream_statement.Add(statement158.Tree);

					}
					break;

				default:
					goto loop45;
				}
			}

			loop45:
				;

			} finally { DebugExitSubRule(45); }

			DebugLocation(987, 25);
			RBRACE159=(IToken)Match(input,RBRACE,Follow._RBRACE_in_block4611);  
			stream_RBRACE.Add(RBRACE159);



			{
			// AST REWRITE
			// elements: statement
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			retval.Tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

			root_0 = (object)adaptor.Nil();
			// 988:2: -> ^( BLOCK[$lb, \"BLOCK\"] ( statement )* )
			{
				DebugLocation(988, 5);
				// JavaScript.g:988:5: ^( BLOCK[$lb, \"BLOCK\"] ( statement )* )
				{
				object root_1 = (object)adaptor.Nil();
				DebugLocation(988, 8);
				root_1 = (object)adaptor.BecomeRoot((object)adaptor.Create(BLOCK, lb, "BLOCK"), root_1);

				DebugLocation(988, 28);
				// JavaScript.g:988:28: ( statement )*
				while ( stream_statement.HasNext )
				{
					DebugLocation(988, 28);
					adaptor.AddChild(root_1, stream_statement.NextTree());

				}
				stream_statement.Reset();

				adaptor.AddChild(root_0, root_1);
				}

			}

			retval.Tree = root_0;
			}

			}

			retval.Stop = (IToken)input.LT(-1);

			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);

		}
		 
		finally
		{
			TraceOut("block", 50);
			LeaveRule("block", 50);
			LeaveRule_block();
		}
		DebugLocation(989, 1);
		} finally { DebugExitRule(GrammarFileName, "block"); }
		return retval;

	}
	// $ANTLR end "block"

	partial void EnterRule_variableStatement();
	partial void LeaveRule_variableStatement();
	// $ANTLR start "variableStatement"
	// JavaScript.g:995:1: variableStatement : VAR variableDeclaration ( COMMA variableDeclaration )* semic -> ^( VAR ( variableDeclaration )+ ) ;
	[GrammarRule("variableStatement")]
	private AstParserRuleReturnScope<object, IToken> variableStatement()
	{
		EnterRule_variableStatement();
		EnterRule("variableStatement", 51);
		TraceIn("variableStatement", 51);
		AstParserRuleReturnScope<object, IToken> retval = new AstParserRuleReturnScope<object, IToken>();
		retval.Start = (IToken)input.LT(1);

		object root_0 = default(object);

		IToken VAR160 = default(IToken);
		IToken COMMA162 = default(IToken);
		AstParserRuleReturnScope<object, IToken> variableDeclaration161 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> variableDeclaration163 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> semic164 = default(AstParserRuleReturnScope<object, IToken>);

		object VAR160_tree = default(object);
		object COMMA162_tree = default(object);
		RewriteRuleITokenStream stream_VAR=new RewriteRuleITokenStream(adaptor,"token VAR");
		RewriteRuleITokenStream stream_COMMA=new RewriteRuleITokenStream(adaptor,"token COMMA");
		RewriteRuleSubtreeStream stream_variableDeclaration=new RewriteRuleSubtreeStream(adaptor,"rule variableDeclaration");
		RewriteRuleSubtreeStream stream_semic=new RewriteRuleSubtreeStream(adaptor,"rule semic");
		try { DebugEnterRule(GrammarFileName, "variableStatement");
		DebugLocation(995, 1);
		try
		{
			// JavaScript.g:996:2: ( VAR variableDeclaration ( COMMA variableDeclaration )* semic -> ^( VAR ( variableDeclaration )+ ) )
			DebugEnterAlt(1);
			// JavaScript.g:996:4: VAR variableDeclaration ( COMMA variableDeclaration )* semic
			{
			DebugLocation(996, 4);
			VAR160=(IToken)Match(input,VAR,Follow._VAR_in_variableStatement4640);  
			stream_VAR.Add(VAR160);

			DebugLocation(996, 8);
			PushFollow(Follow._variableDeclaration_in_variableStatement4642);
			variableDeclaration161=variableDeclaration();
			PopFollow();

			stream_variableDeclaration.Add(variableDeclaration161.Tree);
			DebugLocation(996, 28);
			// JavaScript.g:996:28: ( COMMA variableDeclaration )*
			try { DebugEnterSubRule(46);
			while (true)
			{
				int alt46=2;
				try { DebugEnterDecision(46, false);
				int LA46_1 = input.LA(1);

				if ((LA46_1==COMMA))
				{
					alt46 = 1;
				}


				} finally { DebugExitDecision(46); }
				switch ( alt46 )
				{
				case 1:
					DebugEnterAlt(1);
					// JavaScript.g:996:30: COMMA variableDeclaration
					{
					DebugLocation(996, 30);
					COMMA162=(IToken)Match(input,COMMA,Follow._COMMA_in_variableStatement4646);  
					stream_COMMA.Add(COMMA162);

					DebugLocation(996, 36);
					PushFollow(Follow._variableDeclaration_in_variableStatement4648);
					variableDeclaration163=variableDeclaration();
					PopFollow();

					stream_variableDeclaration.Add(variableDeclaration163.Tree);

					}
					break;

				default:
					goto loop46;
				}
			}

			loop46:
				;

			} finally { DebugExitSubRule(46); }

			DebugLocation(996, 59);
			PushFollow(Follow._semic_in_variableStatement4653);
			semic164=semic();
			PopFollow();

			stream_semic.Add(semic164.Tree);


			{
			// AST REWRITE
			// elements: VAR, variableDeclaration
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			retval.Tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

			root_0 = (object)adaptor.Nil();
			// 997:2: -> ^( VAR ( variableDeclaration )+ )
			{
				DebugLocation(997, 5);
				// JavaScript.g:997:5: ^( VAR ( variableDeclaration )+ )
				{
				object root_1 = (object)adaptor.Nil();
				DebugLocation(997, 8);
				root_1 = (object)adaptor.BecomeRoot(stream_VAR.NextNode(), root_1);

				DebugLocation(997, 12);
				if (!(stream_variableDeclaration.HasNext))
				{
					throw new RewriteEarlyExitException();
				}
				while ( stream_variableDeclaration.HasNext )
				{
					DebugLocation(997, 12);
					adaptor.AddChild(root_1, stream_variableDeclaration.NextTree());

				}
				stream_variableDeclaration.Reset();

				adaptor.AddChild(root_0, root_1);
				}

			}

			retval.Tree = root_0;
			}

			}

			retval.Stop = (IToken)input.LT(-1);

			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);

		}
		 
		finally
		{
			TraceOut("variableStatement", 51);
			LeaveRule("variableStatement", 51);
			LeaveRule_variableStatement();
		}
		DebugLocation(998, 1);
		} finally { DebugExitRule(GrammarFileName, "variableStatement"); }
		return retval;

	}
	// $ANTLR end "variableStatement"

	partial void EnterRule_variableDeclaration();
	partial void LeaveRule_variableDeclaration();
	// $ANTLR start "variableDeclaration"
	// JavaScript.g:1000:1: variableDeclaration : Identifier ( ASSIGN ^ assignmentExpression )? ;
	[GrammarRule("variableDeclaration")]
	private AstParserRuleReturnScope<object, IToken> variableDeclaration()
	{
		EnterRule_variableDeclaration();
		EnterRule("variableDeclaration", 52);
		TraceIn("variableDeclaration", 52);
		AstParserRuleReturnScope<object, IToken> retval = new AstParserRuleReturnScope<object, IToken>();
		retval.Start = (IToken)input.LT(1);

		object root_0 = default(object);

		IToken Identifier165 = default(IToken);
		IToken ASSIGN166 = default(IToken);
		AstParserRuleReturnScope<object, IToken> assignmentExpression167 = default(AstParserRuleReturnScope<object, IToken>);

		object Identifier165_tree = default(object);
		object ASSIGN166_tree = default(object);
		try { DebugEnterRule(GrammarFileName, "variableDeclaration");
		DebugLocation(1000, 1);
		try
		{
			// JavaScript.g:1001:2: ( Identifier ( ASSIGN ^ assignmentExpression )? )
			DebugEnterAlt(1);
			// JavaScript.g:1001:4: Identifier ( ASSIGN ^ assignmentExpression )?
			{
			root_0 = (object)adaptor.Nil();

			DebugLocation(1001, 4);
			Identifier165=(IToken)Match(input,Identifier,Follow._Identifier_in_variableDeclaration4676); 
			Identifier165_tree = (object)adaptor.Create(Identifier165);
			adaptor.AddChild(root_0, Identifier165_tree);
			DebugLocation(1001, 15);
			// JavaScript.g:1001:15: ( ASSIGN ^ assignmentExpression )?
			int alt47=2;
			try { DebugEnterSubRule(47);
			try { DebugEnterDecision(47, false);
			int LA47_1 = input.LA(1);

			if ((LA47_1==ASSIGN))
			{
				alt47 = 1;
			}
			} finally { DebugExitDecision(47); }
			switch (alt47)
			{
			case 1:
				DebugEnterAlt(1);
				// JavaScript.g:1001:17: ASSIGN ^ assignmentExpression
				{
				DebugLocation(1001, 23);
				ASSIGN166=(IToken)Match(input,ASSIGN,Follow._ASSIGN_in_variableDeclaration4680); 
				ASSIGN166_tree = (object)adaptor.Create(ASSIGN166);
				root_0 = (object)adaptor.BecomeRoot(ASSIGN166_tree, root_0);
				DebugLocation(1001, 25);
				PushFollow(Follow._assignmentExpression_in_variableDeclaration4683);
				assignmentExpression167=assignmentExpression();
				PopFollow();

				adaptor.AddChild(root_0, assignmentExpression167.Tree);

				}
				break;

			}
			} finally { DebugExitSubRule(47); }


			}

			retval.Stop = (IToken)input.LT(-1);

			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);

		}
		 
		finally
		{
			TraceOut("variableDeclaration", 52);
			LeaveRule("variableDeclaration", 52);
			LeaveRule_variableDeclaration();
		}
		DebugLocation(1002, 1);
		} finally { DebugExitRule(GrammarFileName, "variableDeclaration"); }
		return retval;

	}
	// $ANTLR end "variableDeclaration"

	partial void EnterRule_variableDeclarationNoIn();
	partial void LeaveRule_variableDeclarationNoIn();
	// $ANTLR start "variableDeclarationNoIn"
	// JavaScript.g:1004:1: variableDeclarationNoIn : Identifier ( ASSIGN ^ assignmentExpressionNoIn )? ;
	[GrammarRule("variableDeclarationNoIn")]
	private AstParserRuleReturnScope<object, IToken> variableDeclarationNoIn()
	{
		EnterRule_variableDeclarationNoIn();
		EnterRule("variableDeclarationNoIn", 53);
		TraceIn("variableDeclarationNoIn", 53);
		AstParserRuleReturnScope<object, IToken> retval = new AstParserRuleReturnScope<object, IToken>();
		retval.Start = (IToken)input.LT(1);

		object root_0 = default(object);

		IToken Identifier168 = default(IToken);
		IToken ASSIGN169 = default(IToken);
		AstParserRuleReturnScope<object, IToken> assignmentExpressionNoIn170 = default(AstParserRuleReturnScope<object, IToken>);

		object Identifier168_tree = default(object);
		object ASSIGN169_tree = default(object);
		try { DebugEnterRule(GrammarFileName, "variableDeclarationNoIn");
		DebugLocation(1004, 1);
		try
		{
			// JavaScript.g:1005:2: ( Identifier ( ASSIGN ^ assignmentExpressionNoIn )? )
			DebugEnterAlt(1);
			// JavaScript.g:1005:4: Identifier ( ASSIGN ^ assignmentExpressionNoIn )?
			{
			root_0 = (object)adaptor.Nil();

			DebugLocation(1005, 4);
			Identifier168=(IToken)Match(input,Identifier,Follow._Identifier_in_variableDeclarationNoIn4698); 
			Identifier168_tree = (object)adaptor.Create(Identifier168);
			adaptor.AddChild(root_0, Identifier168_tree);
			DebugLocation(1005, 15);
			// JavaScript.g:1005:15: ( ASSIGN ^ assignmentExpressionNoIn )?
			int alt48=2;
			try { DebugEnterSubRule(48);
			try { DebugEnterDecision(48, false);
			int LA48_1 = input.LA(1);

			if ((LA48_1==ASSIGN))
			{
				alt48 = 1;
			}
			} finally { DebugExitDecision(48); }
			switch (alt48)
			{
			case 1:
				DebugEnterAlt(1);
				// JavaScript.g:1005:17: ASSIGN ^ assignmentExpressionNoIn
				{
				DebugLocation(1005, 23);
				ASSIGN169=(IToken)Match(input,ASSIGN,Follow._ASSIGN_in_variableDeclarationNoIn4702); 
				ASSIGN169_tree = (object)adaptor.Create(ASSIGN169);
				root_0 = (object)adaptor.BecomeRoot(ASSIGN169_tree, root_0);
				DebugLocation(1005, 25);
				PushFollow(Follow._assignmentExpressionNoIn_in_variableDeclarationNoIn4705);
				assignmentExpressionNoIn170=assignmentExpressionNoIn();
				PopFollow();

				adaptor.AddChild(root_0, assignmentExpressionNoIn170.Tree);

				}
				break;

			}
			} finally { DebugExitSubRule(48); }


			}

			retval.Stop = (IToken)input.LT(-1);

			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);

		}
		 
		finally
		{
			TraceOut("variableDeclarationNoIn", 53);
			LeaveRule("variableDeclarationNoIn", 53);
			LeaveRule_variableDeclarationNoIn();
		}
		DebugLocation(1006, 1);
		} finally { DebugExitRule(GrammarFileName, "variableDeclarationNoIn"); }
		return retval;

	}
	// $ANTLR end "variableDeclarationNoIn"

	partial void EnterRule_emptyStatement();
	partial void LeaveRule_emptyStatement();
	// $ANTLR start "emptyStatement"
	// JavaScript.g:1012:1: emptyStatement : SEMIC !;
	[GrammarRule("emptyStatement")]
	private AstParserRuleReturnScope<object, IToken> emptyStatement()
	{
		EnterRule_emptyStatement();
		EnterRule("emptyStatement", 54);
		TraceIn("emptyStatement", 54);
		AstParserRuleReturnScope<object, IToken> retval = new AstParserRuleReturnScope<object, IToken>();
		retval.Start = (IToken)input.LT(1);

		object root_0 = default(object);

		IToken SEMIC171 = default(IToken);

		object SEMIC171_tree = default(object);
		try { DebugEnterRule(GrammarFileName, "emptyStatement");
		DebugLocation(1012, 1);
		try
		{
			// JavaScript.g:1013:2: ( SEMIC !)
			DebugEnterAlt(1);
			// JavaScript.g:1013:4: SEMIC !
			{
			root_0 = (object)adaptor.Nil();

			DebugLocation(1013, 9);
			SEMIC171=(IToken)Match(input,SEMIC,Follow._SEMIC_in_emptyStatement4724); 

			}

			retval.Stop = (IToken)input.LT(-1);

			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);

		}
		 
		finally
		{
			TraceOut("emptyStatement", 54);
			LeaveRule("emptyStatement", 54);
			LeaveRule_emptyStatement();
		}
		DebugLocation(1014, 1);
		} finally { DebugExitRule(GrammarFileName, "emptyStatement"); }
		return retval;

	}
	// $ANTLR end "emptyStatement"

	partial void EnterRule_expressionStatement();
	partial void LeaveRule_expressionStatement();
	// $ANTLR start "expressionStatement"
	// JavaScript.g:1026:1: expressionStatement : expression semic !;
	[GrammarRule("expressionStatement")]
	private AstParserRuleReturnScope<object, IToken> expressionStatement()
	{
		EnterRule_expressionStatement();
		EnterRule("expressionStatement", 55);
		TraceIn("expressionStatement", 55);
		AstParserRuleReturnScope<object, IToken> retval = new AstParserRuleReturnScope<object, IToken>();
		retval.Start = (IToken)input.LT(1);

		object root_0 = default(object);

		AstParserRuleReturnScope<object, IToken> expression172 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> semic173 = default(AstParserRuleReturnScope<object, IToken>);

		try { DebugEnterRule(GrammarFileName, "expressionStatement");
		DebugLocation(1026, 1);
		try
		{
			// JavaScript.g:1027:2: ( expression semic !)
			DebugEnterAlt(1);
			// JavaScript.g:1027:4: expression semic !
			{
			root_0 = (object)adaptor.Nil();

			DebugLocation(1027, 4);
			PushFollow(Follow._expression_in_expressionStatement4743);
			expression172=expression();
			PopFollow();

			adaptor.AddChild(root_0, expression172.Tree);
			DebugLocation(1027, 20);
			PushFollow(Follow._semic_in_expressionStatement4745);
			semic173=semic();
			PopFollow();


			}

			retval.Stop = (IToken)input.LT(-1);

			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);

		}
		 
		finally
		{
			TraceOut("expressionStatement", 55);
			LeaveRule("expressionStatement", 55);
			LeaveRule_expressionStatement();
		}
		DebugLocation(1028, 1);
		} finally { DebugExitRule(GrammarFileName, "expressionStatement"); }
		return retval;

	}
	// $ANTLR end "expressionStatement"

	partial void EnterRule_ifStatement();
	partial void LeaveRule_ifStatement();
	// $ANTLR start "ifStatement"
	// JavaScript.g:1034:1: ifStatement : IF LPAREN expression RPAREN statement ({...}? ELSE statement )? -> ^( IF expression ( statement )+ ) ;
	[GrammarRule("ifStatement")]
	private AstParserRuleReturnScope<object, IToken> ifStatement()
	{
		EnterRule_ifStatement();
		EnterRule("ifStatement", 56);
		TraceIn("ifStatement", 56);
		AstParserRuleReturnScope<object, IToken> retval = new AstParserRuleReturnScope<object, IToken>();
		retval.Start = (IToken)input.LT(1);

		object root_0 = default(object);

		IToken IF174 = default(IToken);
		IToken LPAREN175 = default(IToken);
		IToken RPAREN177 = default(IToken);
		IToken ELSE179 = default(IToken);
		AstParserRuleReturnScope<object, IToken> expression176 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> statement178 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> statement180 = default(AstParserRuleReturnScope<object, IToken>);

		object IF174_tree = default(object);
		object LPAREN175_tree = default(object);
		object RPAREN177_tree = default(object);
		object ELSE179_tree = default(object);
		RewriteRuleITokenStream stream_IF=new RewriteRuleITokenStream(adaptor,"token IF");
		RewriteRuleITokenStream stream_LPAREN=new RewriteRuleITokenStream(adaptor,"token LPAREN");
		RewriteRuleITokenStream stream_RPAREN=new RewriteRuleITokenStream(adaptor,"token RPAREN");
		RewriteRuleITokenStream stream_ELSE=new RewriteRuleITokenStream(adaptor,"token ELSE");
		RewriteRuleSubtreeStream stream_expression=new RewriteRuleSubtreeStream(adaptor,"rule expression");
		RewriteRuleSubtreeStream stream_statement=new RewriteRuleSubtreeStream(adaptor,"rule statement");
		try { DebugEnterRule(GrammarFileName, "ifStatement");
		DebugLocation(1034, 1);
		try
		{
			// JavaScript.g:1036:2: ( IF LPAREN expression RPAREN statement ({...}? ELSE statement )? -> ^( IF expression ( statement )+ ) )
			DebugEnterAlt(1);
			// JavaScript.g:1036:4: IF LPAREN expression RPAREN statement ({...}? ELSE statement )?
			{
			DebugLocation(1036, 4);
			IF174=(IToken)Match(input,IF,Follow._IF_in_ifStatement4763);  
			stream_IF.Add(IF174);

			DebugLocation(1036, 7);
			LPAREN175=(IToken)Match(input,LPAREN,Follow._LPAREN_in_ifStatement4765);  
			stream_LPAREN.Add(LPAREN175);

			DebugLocation(1036, 14);
			PushFollow(Follow._expression_in_ifStatement4767);
			expression176=expression();
			PopFollow();

			stream_expression.Add(expression176.Tree);
			DebugLocation(1036, 25);
			RPAREN177=(IToken)Match(input,RPAREN,Follow._RPAREN_in_ifStatement4769);  
			stream_RPAREN.Add(RPAREN177);

			DebugLocation(1036, 32);
			PushFollow(Follow._statement_in_ifStatement4771);
			statement178=statement();
			PopFollow();

			stream_statement.Add(statement178.Tree);
			DebugLocation(1036, 42);
			// JavaScript.g:1036:42: ({...}? ELSE statement )?
			int alt49=2;
			try { DebugEnterSubRule(49);
			try { DebugEnterDecision(49, false);
			int LA49_1 = input.LA(1);

			if ((LA49_1==ELSE))
			{
				int LA49_2 = input.LA(2);

				if ((( input.LA(1) == ELSE )))
				{
					alt49 = 1;
				}
			}
			} finally { DebugExitDecision(49); }
			switch (alt49)
			{
			case 1:
				DebugEnterAlt(1);
				// JavaScript.g:1036:44: {...}? ELSE statement
				{
				DebugLocation(1036, 44);
				if (!(( input.LA(1) == ELSE )))
				{
					throw new FailedPredicateException(input, "ifStatement", " input.LA(1) == ELSE ");
				}
				DebugLocation(1036, 69);
				ELSE179=(IToken)Match(input,ELSE,Follow._ELSE_in_ifStatement4777);  
				stream_ELSE.Add(ELSE179);

				DebugLocation(1036, 74);
				PushFollow(Follow._statement_in_ifStatement4779);
				statement180=statement();
				PopFollow();

				stream_statement.Add(statement180.Tree);

				}
				break;

			}
			} finally { DebugExitSubRule(49); }



			{
			// AST REWRITE
			// elements: IF, expression, statement
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			retval.Tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

			root_0 = (object)adaptor.Nil();
			// 1037:2: -> ^( IF expression ( statement )+ )
			{
				DebugLocation(1037, 5);
				// JavaScript.g:1037:5: ^( IF expression ( statement )+ )
				{
				object root_1 = (object)adaptor.Nil();
				DebugLocation(1037, 8);
				root_1 = (object)adaptor.BecomeRoot(stream_IF.NextNode(), root_1);

				DebugLocation(1037, 11);
				adaptor.AddChild(root_1, stream_expression.NextTree());
				DebugLocation(1037, 22);
				if (!(stream_statement.HasNext))
				{
					throw new RewriteEarlyExitException();
				}
				while ( stream_statement.HasNext )
				{
					DebugLocation(1037, 22);
					adaptor.AddChild(root_1, stream_statement.NextTree());

				}
				stream_statement.Reset();

				adaptor.AddChild(root_0, root_1);
				}

			}

			retval.Tree = root_0;
			}

			}

			retval.Stop = (IToken)input.LT(-1);

			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);

		}
		 
		finally
		{
			TraceOut("ifStatement", 56);
			LeaveRule("ifStatement", 56);
			LeaveRule_ifStatement();
		}
		DebugLocation(1038, 1);
		} finally { DebugExitRule(GrammarFileName, "ifStatement"); }
		return retval;

	}
	// $ANTLR end "ifStatement"

	partial void EnterRule_iterationStatement();
	partial void LeaveRule_iterationStatement();
	// $ANTLR start "iterationStatement"
	// JavaScript.g:1044:1: iterationStatement : ( doStatement | whileStatement | forStatement );
	[GrammarRule("iterationStatement")]
	private AstParserRuleReturnScope<object, IToken> iterationStatement()
	{
		EnterRule_iterationStatement();
		EnterRule("iterationStatement", 57);
		TraceIn("iterationStatement", 57);
		AstParserRuleReturnScope<object, IToken> retval = new AstParserRuleReturnScope<object, IToken>();
		retval.Start = (IToken)input.LT(1);

		object root_0 = default(object);

		AstParserRuleReturnScope<object, IToken> doStatement181 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> whileStatement182 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> forStatement183 = default(AstParserRuleReturnScope<object, IToken>);

		try { DebugEnterRule(GrammarFileName, "iterationStatement");
		DebugLocation(1044, 1);
		try
		{
			// JavaScript.g:1045:2: ( doStatement | whileStatement | forStatement )
			int alt50=3;
			try { DebugEnterDecision(50, false);
			switch (input.LA(1))
			{
			case DO:
				{
				alt50 = 1;
				}
				break;
			case WHILE:
				{
				alt50 = 2;
				}
				break;
			case FOR:
				{
				alt50 = 3;
				}
				break;
			default:
				{
					NoViableAltException nvae = new NoViableAltException("", 50, 0, input, 1);
					DebugRecognitionException(nvae);
					throw nvae;
				}
			}

			} finally { DebugExitDecision(50); }
			switch (alt50)
			{
			case 1:
				DebugEnterAlt(1);
				// JavaScript.g:1045:4: doStatement
				{
				root_0 = (object)adaptor.Nil();

				DebugLocation(1045, 4);
				PushFollow(Follow._doStatement_in_iterationStatement4812);
				doStatement181=doStatement();
				PopFollow();

				adaptor.AddChild(root_0, doStatement181.Tree);

				}
				break;
			case 2:
				DebugEnterAlt(2);
				// JavaScript.g:1046:4: whileStatement
				{
				root_0 = (object)adaptor.Nil();

				DebugLocation(1046, 4);
				PushFollow(Follow._whileStatement_in_iterationStatement4817);
				whileStatement182=whileStatement();
				PopFollow();

				adaptor.AddChild(root_0, whileStatement182.Tree);

				}
				break;
			case 3:
				DebugEnterAlt(3);
				// JavaScript.g:1047:4: forStatement
				{
				root_0 = (object)adaptor.Nil();

				DebugLocation(1047, 4);
				PushFollow(Follow._forStatement_in_iterationStatement4822);
				forStatement183=forStatement();
				PopFollow();

				adaptor.AddChild(root_0, forStatement183.Tree);

				}
				break;

			}
			retval.Stop = (IToken)input.LT(-1);

			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);

		}
		 
		finally
		{
			TraceOut("iterationStatement", 57);
			LeaveRule("iterationStatement", 57);
			LeaveRule_iterationStatement();
		}
		DebugLocation(1048, 1);
		} finally { DebugExitRule(GrammarFileName, "iterationStatement"); }
		return retval;

	}
	// $ANTLR end "iterationStatement"

	partial void EnterRule_doStatement();
	partial void LeaveRule_doStatement();
	// $ANTLR start "doStatement"
	// JavaScript.g:1050:1: doStatement : DO statement WHILE LPAREN expression RPAREN semic -> ^( DO statement expression ) ;
	[GrammarRule("doStatement")]
	private AstParserRuleReturnScope<object, IToken> doStatement()
	{
		EnterRule_doStatement();
		EnterRule("doStatement", 58);
		TraceIn("doStatement", 58);
		AstParserRuleReturnScope<object, IToken> retval = new AstParserRuleReturnScope<object, IToken>();
		retval.Start = (IToken)input.LT(1);

		object root_0 = default(object);

		IToken DO184 = default(IToken);
		IToken WHILE186 = default(IToken);
		IToken LPAREN187 = default(IToken);
		IToken RPAREN189 = default(IToken);
		AstParserRuleReturnScope<object, IToken> statement185 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> expression188 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> semic190 = default(AstParserRuleReturnScope<object, IToken>);

		object DO184_tree = default(object);
		object WHILE186_tree = default(object);
		object LPAREN187_tree = default(object);
		object RPAREN189_tree = default(object);
		RewriteRuleITokenStream stream_DO=new RewriteRuleITokenStream(adaptor,"token DO");
		RewriteRuleITokenStream stream_WHILE=new RewriteRuleITokenStream(adaptor,"token WHILE");
		RewriteRuleITokenStream stream_LPAREN=new RewriteRuleITokenStream(adaptor,"token LPAREN");
		RewriteRuleITokenStream stream_RPAREN=new RewriteRuleITokenStream(adaptor,"token RPAREN");
		RewriteRuleSubtreeStream stream_statement=new RewriteRuleSubtreeStream(adaptor,"rule statement");
		RewriteRuleSubtreeStream stream_expression=new RewriteRuleSubtreeStream(adaptor,"rule expression");
		RewriteRuleSubtreeStream stream_semic=new RewriteRuleSubtreeStream(adaptor,"rule semic");
		try { DebugEnterRule(GrammarFileName, "doStatement");
		DebugLocation(1050, 1);
		try
		{
			// JavaScript.g:1051:2: ( DO statement WHILE LPAREN expression RPAREN semic -> ^( DO statement expression ) )
			DebugEnterAlt(1);
			// JavaScript.g:1051:4: DO statement WHILE LPAREN expression RPAREN semic
			{
			DebugLocation(1051, 4);
			DO184=(IToken)Match(input,DO,Follow._DO_in_doStatement4834);  
			stream_DO.Add(DO184);

			DebugLocation(1051, 7);
			PushFollow(Follow._statement_in_doStatement4836);
			statement185=statement();
			PopFollow();

			stream_statement.Add(statement185.Tree);
			DebugLocation(1051, 17);
			WHILE186=(IToken)Match(input,WHILE,Follow._WHILE_in_doStatement4838);  
			stream_WHILE.Add(WHILE186);

			DebugLocation(1051, 23);
			LPAREN187=(IToken)Match(input,LPAREN,Follow._LPAREN_in_doStatement4840);  
			stream_LPAREN.Add(LPAREN187);

			DebugLocation(1051, 30);
			PushFollow(Follow._expression_in_doStatement4842);
			expression188=expression();
			PopFollow();

			stream_expression.Add(expression188.Tree);
			DebugLocation(1051, 41);
			RPAREN189=(IToken)Match(input,RPAREN,Follow._RPAREN_in_doStatement4844);  
			stream_RPAREN.Add(RPAREN189);

			DebugLocation(1051, 48);
			PushFollow(Follow._semic_in_doStatement4846);
			semic190=semic();
			PopFollow();

			stream_semic.Add(semic190.Tree);


			{
			// AST REWRITE
			// elements: DO, statement, expression
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			retval.Tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

			root_0 = (object)adaptor.Nil();
			// 1052:2: -> ^( DO statement expression )
			{
				DebugLocation(1052, 5);
				// JavaScript.g:1052:5: ^( DO statement expression )
				{
				object root_1 = (object)adaptor.Nil();
				DebugLocation(1052, 8);
				root_1 = (object)adaptor.BecomeRoot(stream_DO.NextNode(), root_1);

				DebugLocation(1052, 11);
				adaptor.AddChild(root_1, stream_statement.NextTree());
				DebugLocation(1052, 21);
				adaptor.AddChild(root_1, stream_expression.NextTree());

				adaptor.AddChild(root_0, root_1);
				}

			}

			retval.Tree = root_0;
			}

			}

			retval.Stop = (IToken)input.LT(-1);

			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);

		}
		 
		finally
		{
			TraceOut("doStatement", 58);
			LeaveRule("doStatement", 58);
			LeaveRule_doStatement();
		}
		DebugLocation(1053, 1);
		} finally { DebugExitRule(GrammarFileName, "doStatement"); }
		return retval;

	}
	// $ANTLR end "doStatement"

	partial void EnterRule_whileStatement();
	partial void LeaveRule_whileStatement();
	// $ANTLR start "whileStatement"
	// JavaScript.g:1055:1: whileStatement : WHILE ^ LPAREN ! expression RPAREN ! statement ;
	[GrammarRule("whileStatement")]
	private AstParserRuleReturnScope<object, IToken> whileStatement()
	{
		EnterRule_whileStatement();
		EnterRule("whileStatement", 59);
		TraceIn("whileStatement", 59);
		AstParserRuleReturnScope<object, IToken> retval = new AstParserRuleReturnScope<object, IToken>();
		retval.Start = (IToken)input.LT(1);

		object root_0 = default(object);

		IToken WHILE191 = default(IToken);
		IToken LPAREN192 = default(IToken);
		IToken RPAREN194 = default(IToken);
		AstParserRuleReturnScope<object, IToken> expression193 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> statement195 = default(AstParserRuleReturnScope<object, IToken>);

		object WHILE191_tree = default(object);
		object LPAREN192_tree = default(object);
		object RPAREN194_tree = default(object);
		try { DebugEnterRule(GrammarFileName, "whileStatement");
		DebugLocation(1055, 1);
		try
		{
			// JavaScript.g:1056:2: ( WHILE ^ LPAREN ! expression RPAREN ! statement )
			DebugEnterAlt(1);
			// JavaScript.g:1056:4: WHILE ^ LPAREN ! expression RPAREN ! statement
			{
			root_0 = (object)adaptor.Nil();

			DebugLocation(1056, 9);
			WHILE191=(IToken)Match(input,WHILE,Follow._WHILE_in_whileStatement4871); 
			WHILE191_tree = (object)adaptor.Create(WHILE191);
			root_0 = (object)adaptor.BecomeRoot(WHILE191_tree, root_0);
			DebugLocation(1056, 17);
			LPAREN192=(IToken)Match(input,LPAREN,Follow._LPAREN_in_whileStatement4874); 
			DebugLocation(1056, 19);
			PushFollow(Follow._expression_in_whileStatement4877);
			expression193=expression();
			PopFollow();

			adaptor.AddChild(root_0, expression193.Tree);
			DebugLocation(1056, 36);
			RPAREN194=(IToken)Match(input,RPAREN,Follow._RPAREN_in_whileStatement4879); 
			DebugLocation(1056, 38);
			PushFollow(Follow._statement_in_whileStatement4882);
			statement195=statement();
			PopFollow();

			adaptor.AddChild(root_0, statement195.Tree);

			}

			retval.Stop = (IToken)input.LT(-1);

			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);

		}
		 
		finally
		{
			TraceOut("whileStatement", 59);
			LeaveRule("whileStatement", 59);
			LeaveRule_whileStatement();
		}
		DebugLocation(1057, 1);
		} finally { DebugExitRule(GrammarFileName, "whileStatement"); }
		return retval;

	}
	// $ANTLR end "whileStatement"

	partial void EnterRule_forStatement();
	partial void LeaveRule_forStatement();
	// $ANTLR start "forStatement"
	// JavaScript.g:1100:1: forStatement : FOR ^ LPAREN ! forControl RPAREN ! statement ;
	[GrammarRule("forStatement")]
	private AstParserRuleReturnScope<object, IToken> forStatement()
	{
		EnterRule_forStatement();
		EnterRule("forStatement", 60);
		TraceIn("forStatement", 60);
		AstParserRuleReturnScope<object, IToken> retval = new AstParserRuleReturnScope<object, IToken>();
		retval.Start = (IToken)input.LT(1);

		object root_0 = default(object);

		IToken FOR196 = default(IToken);
		IToken LPAREN197 = default(IToken);
		IToken RPAREN199 = default(IToken);
		AstParserRuleReturnScope<object, IToken> forControl198 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> statement200 = default(AstParserRuleReturnScope<object, IToken>);

		object FOR196_tree = default(object);
		object LPAREN197_tree = default(object);
		object RPAREN199_tree = default(object);
		try { DebugEnterRule(GrammarFileName, "forStatement");
		DebugLocation(1100, 1);
		try
		{
			// JavaScript.g:1101:2: ( FOR ^ LPAREN ! forControl RPAREN ! statement )
			DebugEnterAlt(1);
			// JavaScript.g:1101:4: FOR ^ LPAREN ! forControl RPAREN ! statement
			{
			root_0 = (object)adaptor.Nil();

			DebugLocation(1101, 7);
			FOR196=(IToken)Match(input,FOR,Follow._FOR_in_forStatement4895); 
			FOR196_tree = (object)adaptor.Create(FOR196);
			root_0 = (object)adaptor.BecomeRoot(FOR196_tree, root_0);
			DebugLocation(1101, 15);
			LPAREN197=(IToken)Match(input,LPAREN,Follow._LPAREN_in_forStatement4898); 
			DebugLocation(1101, 17);
			PushFollow(Follow._forControl_in_forStatement4901);
			forControl198=forControl();
			PopFollow();

			adaptor.AddChild(root_0, forControl198.Tree);
			DebugLocation(1101, 34);
			RPAREN199=(IToken)Match(input,RPAREN,Follow._RPAREN_in_forStatement4903); 
			DebugLocation(1101, 36);
			PushFollow(Follow._statement_in_forStatement4906);
			statement200=statement();
			PopFollow();

			adaptor.AddChild(root_0, statement200.Tree);

			}

			retval.Stop = (IToken)input.LT(-1);

			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);

		}
		 
		finally
		{
			TraceOut("forStatement", 60);
			LeaveRule("forStatement", 60);
			LeaveRule_forStatement();
		}
		DebugLocation(1102, 1);
		} finally { DebugExitRule(GrammarFileName, "forStatement"); }
		return retval;

	}
	// $ANTLR end "forStatement"

	partial void EnterRule_forControl();
	partial void LeaveRule_forControl();
	// $ANTLR start "forControl"
	// JavaScript.g:1104:1: forControl : ( forControlVar | forControlExpression | forControlSemic );
	[GrammarRule("forControl")]
	private AstParserRuleReturnScope<object, IToken> forControl()
	{
		EnterRule_forControl();
		EnterRule("forControl", 61);
		TraceIn("forControl", 61);
		AstParserRuleReturnScope<object, IToken> retval = new AstParserRuleReturnScope<object, IToken>();
		retval.Start = (IToken)input.LT(1);

		object root_0 = default(object);

		AstParserRuleReturnScope<object, IToken> forControlVar201 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> forControlExpression202 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> forControlSemic203 = default(AstParserRuleReturnScope<object, IToken>);

		try { DebugEnterRule(GrammarFileName, "forControl");
		DebugLocation(1104, 1);
		try
		{
			// JavaScript.g:1105:2: ( forControlVar | forControlExpression | forControlSemic )
			int alt51=3;
			try { DebugEnterDecision(51, false);
			switch (input.LA(1))
			{
			case VAR:
				{
				alt51 = 1;
				}
				break;
			case ADD:
			case DEC:
			case DELETE:
			case DecimalLiteral:
			case FALSE:
			case FUNCTION:
			case HexIntegerLiteral:
			case INC:
			case INV:
			case Identifier:
			case LBRACE:
			case LBRACK:
			case LPAREN:
			case NEW:
			case NOT:
			case NULL:
			case OctalIntegerLiteral:
			case RegularExpressionLiteral:
			case SUB:
			case StringLiteral:
			case THIS:
			case TRUE:
			case TYPEOF:
			case VOID:
				{
				alt51 = 2;
				}
				break;
			case SEMIC:
				{
				alt51 = 3;
				}
				break;
			default:
				{
					NoViableAltException nvae = new NoViableAltException("", 51, 0, input, 1);
					DebugRecognitionException(nvae);
					throw nvae;
				}
			}

			} finally { DebugExitDecision(51); }
			switch (alt51)
			{
			case 1:
				DebugEnterAlt(1);
				// JavaScript.g:1105:4: forControlVar
				{
				root_0 = (object)adaptor.Nil();

				DebugLocation(1105, 4);
				PushFollow(Follow._forControlVar_in_forControl4917);
				forControlVar201=forControlVar();
				PopFollow();

				adaptor.AddChild(root_0, forControlVar201.Tree);

				}
				break;
			case 2:
				DebugEnterAlt(2);
				// JavaScript.g:1106:4: forControlExpression
				{
				root_0 = (object)adaptor.Nil();

				DebugLocation(1106, 4);
				PushFollow(Follow._forControlExpression_in_forControl4922);
				forControlExpression202=forControlExpression();
				PopFollow();

				adaptor.AddChild(root_0, forControlExpression202.Tree);

				}
				break;
			case 3:
				DebugEnterAlt(3);
				// JavaScript.g:1107:4: forControlSemic
				{
				root_0 = (object)adaptor.Nil();

				DebugLocation(1107, 4);
				PushFollow(Follow._forControlSemic_in_forControl4927);
				forControlSemic203=forControlSemic();
				PopFollow();

				adaptor.AddChild(root_0, forControlSemic203.Tree);

				}
				break;

			}
			retval.Stop = (IToken)input.LT(-1);

			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);

		}
		 
		finally
		{
			TraceOut("forControl", 61);
			LeaveRule("forControl", 61);
			LeaveRule_forControl();
		}
		DebugLocation(1108, 1);
		} finally { DebugExitRule(GrammarFileName, "forControl"); }
		return retval;

	}
	// $ANTLR end "forControl"

	partial void EnterRule_forControlVar();
	partial void LeaveRule_forControlVar();
	// $ANTLR start "forControlVar"
	// JavaScript.g:1110:1: forControlVar : VAR variableDeclarationNoIn ( ( IN expression -> ^( FORITER ^( VAR variableDeclarationNoIn ) ^( EXPR expression ) ) ) | ( ( COMMA variableDeclarationNoIn )* SEMIC (ex1= expression )? SEMIC (ex2= expression )? -> ^( FORSTEP ^( VAR ( variableDeclarationNoIn )+ ) ^( EXPR ( $ex1)? ) ^( EXPR ( $ex2)? ) ) ) ) ;
	[GrammarRule("forControlVar")]
	private AstParserRuleReturnScope<object, IToken> forControlVar()
	{
		EnterRule_forControlVar();
		EnterRule("forControlVar", 62);
		TraceIn("forControlVar", 62);
		AstParserRuleReturnScope<object, IToken> retval = new AstParserRuleReturnScope<object, IToken>();
		retval.Start = (IToken)input.LT(1);

		object root_0 = default(object);

		IToken VAR204 = default(IToken);
		IToken IN206 = default(IToken);
		IToken COMMA208 = default(IToken);
		IToken SEMIC210 = default(IToken);
		IToken SEMIC211 = default(IToken);
		AstParserRuleReturnScope<object, IToken> ex1 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> ex2 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> variableDeclarationNoIn205 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> expression207 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> variableDeclarationNoIn209 = default(AstParserRuleReturnScope<object, IToken>);

		object VAR204_tree = default(object);
		object IN206_tree = default(object);
		object COMMA208_tree = default(object);
		object SEMIC210_tree = default(object);
		object SEMIC211_tree = default(object);
		RewriteRuleITokenStream stream_VAR=new RewriteRuleITokenStream(adaptor,"token VAR");
		RewriteRuleITokenStream stream_IN=new RewriteRuleITokenStream(adaptor,"token IN");
		RewriteRuleITokenStream stream_COMMA=new RewriteRuleITokenStream(adaptor,"token COMMA");
		RewriteRuleITokenStream stream_SEMIC=new RewriteRuleITokenStream(adaptor,"token SEMIC");
		RewriteRuleSubtreeStream stream_variableDeclarationNoIn=new RewriteRuleSubtreeStream(adaptor,"rule variableDeclarationNoIn");
		RewriteRuleSubtreeStream stream_expression=new RewriteRuleSubtreeStream(adaptor,"rule expression");
		try { DebugEnterRule(GrammarFileName, "forControlVar");
		DebugLocation(1110, 1);
		try
		{
			// JavaScript.g:1111:2: ( VAR variableDeclarationNoIn ( ( IN expression -> ^( FORITER ^( VAR variableDeclarationNoIn ) ^( EXPR expression ) ) ) | ( ( COMMA variableDeclarationNoIn )* SEMIC (ex1= expression )? SEMIC (ex2= expression )? -> ^( FORSTEP ^( VAR ( variableDeclarationNoIn )+ ) ^( EXPR ( $ex1)? ) ^( EXPR ( $ex2)? ) ) ) ) )
			DebugEnterAlt(1);
			// JavaScript.g:1111:4: VAR variableDeclarationNoIn ( ( IN expression -> ^( FORITER ^( VAR variableDeclarationNoIn ) ^( EXPR expression ) ) ) | ( ( COMMA variableDeclarationNoIn )* SEMIC (ex1= expression )? SEMIC (ex2= expression )? -> ^( FORSTEP ^( VAR ( variableDeclarationNoIn )+ ) ^( EXPR ( $ex1)? ) ^( EXPR ( $ex2)? ) ) ) )
			{
			DebugLocation(1111, 4);
			VAR204=(IToken)Match(input,VAR,Follow._VAR_in_forControlVar4938);  
			stream_VAR.Add(VAR204);

			DebugLocation(1111, 8);
			PushFollow(Follow._variableDeclarationNoIn_in_forControlVar4940);
			variableDeclarationNoIn205=variableDeclarationNoIn();
			PopFollow();

			stream_variableDeclarationNoIn.Add(variableDeclarationNoIn205.Tree);
			DebugLocation(1112, 2);
			// JavaScript.g:1112:2: ( ( IN expression -> ^( FORITER ^( VAR variableDeclarationNoIn ) ^( EXPR expression ) ) ) | ( ( COMMA variableDeclarationNoIn )* SEMIC (ex1= expression )? SEMIC (ex2= expression )? -> ^( FORSTEP ^( VAR ( variableDeclarationNoIn )+ ) ^( EXPR ( $ex1)? ) ^( EXPR ( $ex2)? ) ) ) )
			int alt55=2;
			try { DebugEnterSubRule(55);
			try { DebugEnterDecision(55, false);
			int LA55_1 = input.LA(1);

			if ((LA55_1==IN))
			{
				alt55 = 1;
			}
			else if ((LA55_1==COMMA||LA55_1==SEMIC))
			{
				alt55 = 2;
			}
			else
			{
				NoViableAltException nvae = new NoViableAltException("", 55, 0, input, 1);
				DebugRecognitionException(nvae);
				throw nvae;
			}
			} finally { DebugExitDecision(55); }
			switch (alt55)
			{
			case 1:
				DebugEnterAlt(1);
				// JavaScript.g:1113:3: ( IN expression -> ^( FORITER ^( VAR variableDeclarationNoIn ) ^( EXPR expression ) ) )
				{
				DebugLocation(1113, 3);
				// JavaScript.g:1113:3: ( IN expression -> ^( FORITER ^( VAR variableDeclarationNoIn ) ^( EXPR expression ) ) )
				DebugEnterAlt(1);
				// JavaScript.g:1114:4: IN expression
				{
				DebugLocation(1114, 4);
				IN206=(IToken)Match(input,IN,Follow._IN_in_forControlVar4952);  
				stream_IN.Add(IN206);

				DebugLocation(1114, 7);
				PushFollow(Follow._expression_in_forControlVar4954);
				expression207=expression();
				PopFollow();

				stream_expression.Add(expression207.Tree);


				{
				// AST REWRITE
				// elements: VAR, variableDeclarationNoIn, expression
				// token labels: 
				// rule labels: retval
				// token list labels: 
				// rule list labels: 
				// wildcard labels: 
				retval.Tree = root_0;
				RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

				root_0 = (object)adaptor.Nil();
				// 1115:4: -> ^( FORITER ^( VAR variableDeclarationNoIn ) ^( EXPR expression ) )
				{
					DebugLocation(1115, 7);
					// JavaScript.g:1115:7: ^( FORITER ^( VAR variableDeclarationNoIn ) ^( EXPR expression ) )
					{
					object root_1 = (object)adaptor.Nil();
					DebugLocation(1115, 10);
					root_1 = (object)adaptor.BecomeRoot((object)adaptor.Create(FORITER, "FORITER"), root_1);

					DebugLocation(1115, 18);
					// JavaScript.g:1115:18: ^( VAR variableDeclarationNoIn )
					{
					object root_2 = (object)adaptor.Nil();
					DebugLocation(1115, 21);
					root_2 = (object)adaptor.BecomeRoot(stream_VAR.NextNode(), root_2);

					DebugLocation(1115, 25);
					adaptor.AddChild(root_2, stream_variableDeclarationNoIn.NextTree());

					adaptor.AddChild(root_1, root_2);
					}
					DebugLocation(1115, 51);
					// JavaScript.g:1115:51: ^( EXPR expression )
					{
					object root_2 = (object)adaptor.Nil();
					DebugLocation(1115, 54);
					root_2 = (object)adaptor.BecomeRoot((object)adaptor.Create(EXPR, "EXPR"), root_2);

					DebugLocation(1115, 59);
					adaptor.AddChild(root_2, stream_expression.NextTree());

					adaptor.AddChild(root_1, root_2);
					}

					adaptor.AddChild(root_0, root_1);
					}

				}

				retval.Tree = root_0;
				}

				}


				}
				break;
			case 2:
				DebugEnterAlt(2);
				// JavaScript.g:1118:3: ( ( COMMA variableDeclarationNoIn )* SEMIC (ex1= expression )? SEMIC (ex2= expression )? -> ^( FORSTEP ^( VAR ( variableDeclarationNoIn )+ ) ^( EXPR ( $ex1)? ) ^( EXPR ( $ex2)? ) ) )
				{
				DebugLocation(1118, 3);
				// JavaScript.g:1118:3: ( ( COMMA variableDeclarationNoIn )* SEMIC (ex1= expression )? SEMIC (ex2= expression )? -> ^( FORSTEP ^( VAR ( variableDeclarationNoIn )+ ) ^( EXPR ( $ex1)? ) ^( EXPR ( $ex2)? ) ) )
				DebugEnterAlt(1);
				// JavaScript.g:1119:4: ( COMMA variableDeclarationNoIn )* SEMIC (ex1= expression )? SEMIC (ex2= expression )?
				{
				DebugLocation(1119, 4);
				// JavaScript.g:1119:4: ( COMMA variableDeclarationNoIn )*
				try { DebugEnterSubRule(52);
				while (true)
				{
					int alt52=2;
					try { DebugEnterDecision(52, false);
					int LA52_1 = input.LA(1);

					if ((LA52_1==COMMA))
					{
						alt52 = 1;
					}


					} finally { DebugExitDecision(52); }
					switch ( alt52 )
					{
					case 1:
						DebugEnterAlt(1);
						// JavaScript.g:1119:6: COMMA variableDeclarationNoIn
						{
						DebugLocation(1119, 6);
						COMMA208=(IToken)Match(input,COMMA,Follow._COMMA_in_forControlVar5000);  
						stream_COMMA.Add(COMMA208);

						DebugLocation(1119, 12);
						PushFollow(Follow._variableDeclarationNoIn_in_forControlVar5002);
						variableDeclarationNoIn209=variableDeclarationNoIn();
						PopFollow();

						stream_variableDeclarationNoIn.Add(variableDeclarationNoIn209.Tree);

						}
						break;

					default:
						goto loop52;
					}
				}

				loop52:
					;

				} finally { DebugExitSubRule(52); }

				DebugLocation(1119, 39);
				SEMIC210=(IToken)Match(input,SEMIC,Follow._SEMIC_in_forControlVar5007);  
				stream_SEMIC.Add(SEMIC210);

				DebugLocation(1119, 48);
				// JavaScript.g:1119:48: (ex1= expression )?
				int alt53=2;
				try { DebugEnterSubRule(53);
				try { DebugEnterDecision(53, false);
				int LA53_1 = input.LA(1);

				if ((LA53_1==ADD||LA53_1==DEC||LA53_1==DELETE||LA53_1==DecimalLiteral||LA53_1==FALSE||LA53_1==FUNCTION||LA53_1==HexIntegerLiteral||LA53_1==INC||LA53_1==INV||LA53_1==Identifier||(LA53_1>=LBRACE && LA53_1<=LBRACK)||LA53_1==LPAREN||(LA53_1>=NEW && LA53_1<=NOT)||LA53_1==NULL||LA53_1==OctalIntegerLiteral||LA53_1==RegularExpressionLiteral||LA53_1==SUB||LA53_1==StringLiteral||LA53_1==THIS||LA53_1==TRUE||LA53_1==TYPEOF||LA53_1==VOID))
				{
					alt53 = 1;
				}
				} finally { DebugExitDecision(53); }
				switch (alt53)
				{
				case 1:
					DebugEnterAlt(1);
					// JavaScript.g:1119:48: ex1= expression
					{
					DebugLocation(1119, 48);
					PushFollow(Follow._expression_in_forControlVar5011);
					ex1=expression();
					PopFollow();

					stream_expression.Add(ex1.Tree);

					}
					break;

				}
				} finally { DebugExitSubRule(53); }

				DebugLocation(1119, 61);
				SEMIC211=(IToken)Match(input,SEMIC,Follow._SEMIC_in_forControlVar5014);  
				stream_SEMIC.Add(SEMIC211);

				DebugLocation(1119, 70);
				// JavaScript.g:1119:70: (ex2= expression )?
				int alt54=2;
				try { DebugEnterSubRule(54);
				try { DebugEnterDecision(54, false);
				int LA54_1 = input.LA(1);

				if ((LA54_1==ADD||LA54_1==DEC||LA54_1==DELETE||LA54_1==DecimalLiteral||LA54_1==FALSE||LA54_1==FUNCTION||LA54_1==HexIntegerLiteral||LA54_1==INC||LA54_1==INV||LA54_1==Identifier||(LA54_1>=LBRACE && LA54_1<=LBRACK)||LA54_1==LPAREN||(LA54_1>=NEW && LA54_1<=NOT)||LA54_1==NULL||LA54_1==OctalIntegerLiteral||LA54_1==RegularExpressionLiteral||LA54_1==SUB||LA54_1==StringLiteral||LA54_1==THIS||LA54_1==TRUE||LA54_1==TYPEOF||LA54_1==VOID))
				{
					alt54 = 1;
				}
				} finally { DebugExitDecision(54); }
				switch (alt54)
				{
				case 1:
					DebugEnterAlt(1);
					// JavaScript.g:1119:70: ex2= expression
					{
					DebugLocation(1119, 70);
					PushFollow(Follow._expression_in_forControlVar5018);
					ex2=expression();
					PopFollow();

					stream_expression.Add(ex2.Tree);

					}
					break;

				}
				} finally { DebugExitSubRule(54); }



				{
				// AST REWRITE
				// elements: VAR, variableDeclarationNoIn, ex1, ex2
				// token labels: 
				// rule labels: ex1, ex2, retval
				// token list labels: 
				// rule list labels: 
				// wildcard labels: 
				retval.Tree = root_0;
				RewriteRuleSubtreeStream stream_ex1=new RewriteRuleSubtreeStream(adaptor,"rule ex1",ex1!=null?ex1.Tree:null);
				RewriteRuleSubtreeStream stream_ex2=new RewriteRuleSubtreeStream(adaptor,"rule ex2",ex2!=null?ex2.Tree:null);
				RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

				root_0 = (object)adaptor.Nil();
				// 1120:4: -> ^( FORSTEP ^( VAR ( variableDeclarationNoIn )+ ) ^( EXPR ( $ex1)? ) ^( EXPR ( $ex2)? ) )
				{
					DebugLocation(1120, 7);
					// JavaScript.g:1120:7: ^( FORSTEP ^( VAR ( variableDeclarationNoIn )+ ) ^( EXPR ( $ex1)? ) ^( EXPR ( $ex2)? ) )
					{
					object root_1 = (object)adaptor.Nil();
					DebugLocation(1120, 10);
					root_1 = (object)adaptor.BecomeRoot((object)adaptor.Create(FORSTEP, "FORSTEP"), root_1);

					DebugLocation(1120, 18);
					// JavaScript.g:1120:18: ^( VAR ( variableDeclarationNoIn )+ )
					{
					object root_2 = (object)adaptor.Nil();
					DebugLocation(1120, 21);
					root_2 = (object)adaptor.BecomeRoot(stream_VAR.NextNode(), root_2);

					DebugLocation(1120, 25);
					if (!(stream_variableDeclarationNoIn.HasNext))
					{
						throw new RewriteEarlyExitException();
					}
					while ( stream_variableDeclarationNoIn.HasNext )
					{
						DebugLocation(1120, 25);
						adaptor.AddChild(root_2, stream_variableDeclarationNoIn.NextTree());

					}
					stream_variableDeclarationNoIn.Reset();

					adaptor.AddChild(root_1, root_2);
					}
					DebugLocation(1120, 52);
					// JavaScript.g:1120:52: ^( EXPR ( $ex1)? )
					{
					object root_2 = (object)adaptor.Nil();
					DebugLocation(1120, 55);
					root_2 = (object)adaptor.BecomeRoot((object)adaptor.Create(EXPR, "EXPR"), root_2);

					DebugLocation(1120, 61);
					// JavaScript.g:1120:61: ( $ex1)?
					if (stream_ex1.HasNext)
					{
						DebugLocation(1120, 61);
						adaptor.AddChild(root_2, stream_ex1.NextTree());

					}
					stream_ex1.Reset();

					adaptor.AddChild(root_1, root_2);
					}
					DebugLocation(1120, 68);
					// JavaScript.g:1120:68: ^( EXPR ( $ex2)? )
					{
					object root_2 = (object)adaptor.Nil();
					DebugLocation(1120, 71);
					root_2 = (object)adaptor.BecomeRoot((object)adaptor.Create(EXPR, "EXPR"), root_2);

					DebugLocation(1120, 77);
					// JavaScript.g:1120:77: ( $ex2)?
					if (stream_ex2.HasNext)
					{
						DebugLocation(1120, 77);
						adaptor.AddChild(root_2, stream_ex2.NextTree());

					}
					stream_ex2.Reset();

					adaptor.AddChild(root_1, root_2);
					}

					adaptor.AddChild(root_0, root_1);
					}

				}

				retval.Tree = root_0;
				}

				}


				}
				break;

			}
			} finally { DebugExitSubRule(55); }


			}

			retval.Stop = (IToken)input.LT(-1);

			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);

		}
		 
		finally
		{
			TraceOut("forControlVar", 62);
			LeaveRule("forControlVar", 62);
			LeaveRule_forControlVar();
		}
		DebugLocation(1123, 1);
		} finally { DebugExitRule(GrammarFileName, "forControlVar"); }
		return retval;

	}
	// $ANTLR end "forControlVar"

	partial void EnterRule_forControlExpression();
	partial void LeaveRule_forControlExpression();
	// $ANTLR start "forControlExpression"
	// JavaScript.g:1125:1: forControlExpression : ex1= expressionNoIn ({...}? ( IN ex2= expression -> ^( FORITER ^( EXPR $ex1) ^( EXPR $ex2) ) ) | ( SEMIC (ex2= expression )? SEMIC (ex3= expression )? -> ^( FORSTEP ^( EXPR $ex1) ^( EXPR ( $ex2)? ) ^( EXPR ( $ex3)? ) ) ) ) ;
	[GrammarRule("forControlExpression")]
	private AstParserRuleReturnScope<object, IToken> forControlExpression()
	{
		EnterRule_forControlExpression();
		EnterRule("forControlExpression", 63);
		TraceIn("forControlExpression", 63);
		AstParserRuleReturnScope<object, IToken> retval = new AstParserRuleReturnScope<object, IToken>();
		retval.Start = (IToken)input.LT(1);

		object root_0 = default(object);

		IToken IN212 = default(IToken);
		IToken SEMIC213 = default(IToken);
		IToken SEMIC214 = default(IToken);
		AstParserRuleReturnScope<object, IToken> ex1 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> ex2 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> ex3 = default(AstParserRuleReturnScope<object, IToken>);

		object IN212_tree = default(object);
		object SEMIC213_tree = default(object);
		object SEMIC214_tree = default(object);
		RewriteRuleITokenStream stream_IN=new RewriteRuleITokenStream(adaptor,"token IN");
		RewriteRuleITokenStream stream_SEMIC=new RewriteRuleITokenStream(adaptor,"token SEMIC");
		RewriteRuleSubtreeStream stream_expressionNoIn=new RewriteRuleSubtreeStream(adaptor,"rule expressionNoIn");
		RewriteRuleSubtreeStream stream_expression=new RewriteRuleSubtreeStream(adaptor,"rule expression");

			bool? isLhs = null;

		try { DebugEnterRule(GrammarFileName, "forControlExpression");
		DebugLocation(1125, 1);
		try
		{
			// JavaScript.g:1130:2: (ex1= expressionNoIn ({...}? ( IN ex2= expression -> ^( FORITER ^( EXPR $ex1) ^( EXPR $ex2) ) ) | ( SEMIC (ex2= expression )? SEMIC (ex3= expression )? -> ^( FORSTEP ^( EXPR $ex1) ^( EXPR ( $ex2)? ) ^( EXPR ( $ex3)? ) ) ) ) )
			DebugEnterAlt(1);
			// JavaScript.g:1130:4: ex1= expressionNoIn ({...}? ( IN ex2= expression -> ^( FORITER ^( EXPR $ex1) ^( EXPR $ex2) ) ) | ( SEMIC (ex2= expression )? SEMIC (ex3= expression )? -> ^( FORSTEP ^( EXPR $ex1) ^( EXPR ( $ex2)? ) ^( EXPR ( $ex3)? ) ) ) )
			{
			DebugLocation(1130, 7);
			PushFollow(Follow._expressionNoIn_in_forControlExpression5084);
			ex1=expressionNoIn();
			PopFollow();

			stream_expressionNoIn.Add(ex1.Tree);
			DebugLocation(1131, 2);
			// JavaScript.g:1131:2: ({...}? ( IN ex2= expression -> ^( FORITER ^( EXPR $ex1) ^( EXPR $ex2) ) ) | ( SEMIC (ex2= expression )? SEMIC (ex3= expression )? -> ^( FORSTEP ^( EXPR $ex1) ^( EXPR ( $ex2)? ) ^( EXPR ( $ex3)? ) ) ) )
			int alt58=2;
			try { DebugEnterSubRule(58);
			try { DebugEnterDecision(58, false);
			int LA58_1 = input.LA(1);

			if ((LA58_1==IN))
			{
				alt58 = 1;
			}
			else if ((LA58_1==SEMIC))
			{
				alt58 = 2;
			}
			else
			{
				NoViableAltException nvae = new NoViableAltException("", 58, 0, input, 1);
				DebugRecognitionException(nvae);
				throw nvae;
			}
			} finally { DebugExitDecision(58); }
			switch (alt58)
			{
			case 1:
				DebugEnterAlt(1);
				// JavaScript.g:1132:3: {...}? ( IN ex2= expression -> ^( FORITER ^( EXPR $ex1) ^( EXPR $ex2) ) )
				{
				DebugLocation(1132, 3);
				if (!(( IsLeftHandSideIn(ex1, ref isLhs) )))
				{
					throw new FailedPredicateException(input, "forControlExpression", " IsLeftHandSideIn(ex1, ref isLhs) ");
				}
				DebugLocation(1132, 41);
				// JavaScript.g:1132:41: ( IN ex2= expression -> ^( FORITER ^( EXPR $ex1) ^( EXPR $ex2) ) )
				DebugEnterAlt(1);
				// JavaScript.g:1133:4: IN ex2= expression
				{
				DebugLocation(1133, 4);
				IN212=(IToken)Match(input,IN,Follow._IN_in_forControlExpression5099);  
				stream_IN.Add(IN212);

				DebugLocation(1133, 10);
				PushFollow(Follow._expression_in_forControlExpression5103);
				ex2=expression();
				PopFollow();

				stream_expression.Add(ex2.Tree);


				{
				// AST REWRITE
				// elements: ex1, ex2
				// token labels: 
				// rule labels: ex1, ex2, retval
				// token list labels: 
				// rule list labels: 
				// wildcard labels: 
				retval.Tree = root_0;
				RewriteRuleSubtreeStream stream_ex1=new RewriteRuleSubtreeStream(adaptor,"rule ex1",ex1!=null?ex1.Tree:null);
				RewriteRuleSubtreeStream stream_ex2=new RewriteRuleSubtreeStream(adaptor,"rule ex2",ex2!=null?ex2.Tree:null);
				RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

				root_0 = (object)adaptor.Nil();
				// 1134:4: -> ^( FORITER ^( EXPR $ex1) ^( EXPR $ex2) )
				{
					DebugLocation(1134, 7);
					// JavaScript.g:1134:7: ^( FORITER ^( EXPR $ex1) ^( EXPR $ex2) )
					{
					object root_1 = (object)adaptor.Nil();
					DebugLocation(1134, 10);
					root_1 = (object)adaptor.BecomeRoot((object)adaptor.Create(FORITER, "FORITER"), root_1);

					DebugLocation(1134, 18);
					// JavaScript.g:1134:18: ^( EXPR $ex1)
					{
					object root_2 = (object)adaptor.Nil();
					DebugLocation(1134, 21);
					root_2 = (object)adaptor.BecomeRoot((object)adaptor.Create(EXPR, "EXPR"), root_2);

					DebugLocation(1134, 27);
					adaptor.AddChild(root_2, stream_ex1.NextTree());

					adaptor.AddChild(root_1, root_2);
					}
					DebugLocation(1134, 33);
					// JavaScript.g:1134:33: ^( EXPR $ex2)
					{
					object root_2 = (object)adaptor.Nil();
					DebugLocation(1134, 36);
					root_2 = (object)adaptor.BecomeRoot((object)adaptor.Create(EXPR, "EXPR"), root_2);

					DebugLocation(1134, 42);
					adaptor.AddChild(root_2, stream_ex2.NextTree());

					adaptor.AddChild(root_1, root_2);
					}

					adaptor.AddChild(root_0, root_1);
					}

				}

				retval.Tree = root_0;
				}

				}


				}
				break;
			case 2:
				DebugEnterAlt(2);
				// JavaScript.g:1137:3: ( SEMIC (ex2= expression )? SEMIC (ex3= expression )? -> ^( FORSTEP ^( EXPR $ex1) ^( EXPR ( $ex2)? ) ^( EXPR ( $ex3)? ) ) )
				{
				DebugLocation(1137, 3);
				// JavaScript.g:1137:3: ( SEMIC (ex2= expression )? SEMIC (ex3= expression )? -> ^( FORSTEP ^( EXPR $ex1) ^( EXPR ( $ex2)? ) ^( EXPR ( $ex3)? ) ) )
				DebugEnterAlt(1);
				// JavaScript.g:1138:4: SEMIC (ex2= expression )? SEMIC (ex3= expression )?
				{
				DebugLocation(1138, 4);
				SEMIC213=(IToken)Match(input,SEMIC,Follow._SEMIC_in_forControlExpression5149);  
				stream_SEMIC.Add(SEMIC213);

				DebugLocation(1138, 13);
				// JavaScript.g:1138:13: (ex2= expression )?
				int alt56=2;
				try { DebugEnterSubRule(56);
				try { DebugEnterDecision(56, false);
				int LA56_1 = input.LA(1);

				if ((LA56_1==ADD||LA56_1==DEC||LA56_1==DELETE||LA56_1==DecimalLiteral||LA56_1==FALSE||LA56_1==FUNCTION||LA56_1==HexIntegerLiteral||LA56_1==INC||LA56_1==INV||LA56_1==Identifier||(LA56_1>=LBRACE && LA56_1<=LBRACK)||LA56_1==LPAREN||(LA56_1>=NEW && LA56_1<=NOT)||LA56_1==NULL||LA56_1==OctalIntegerLiteral||LA56_1==RegularExpressionLiteral||LA56_1==SUB||LA56_1==StringLiteral||LA56_1==THIS||LA56_1==TRUE||LA56_1==TYPEOF||LA56_1==VOID))
				{
					alt56 = 1;
				}
				} finally { DebugExitDecision(56); }
				switch (alt56)
				{
				case 1:
					DebugEnterAlt(1);
					// JavaScript.g:1138:13: ex2= expression
					{
					DebugLocation(1138, 13);
					PushFollow(Follow._expression_in_forControlExpression5153);
					ex2=expression();
					PopFollow();

					stream_expression.Add(ex2.Tree);

					}
					break;

				}
				} finally { DebugExitSubRule(56); }

				DebugLocation(1138, 26);
				SEMIC214=(IToken)Match(input,SEMIC,Follow._SEMIC_in_forControlExpression5156);  
				stream_SEMIC.Add(SEMIC214);

				DebugLocation(1138, 35);
				// JavaScript.g:1138:35: (ex3= expression )?
				int alt57=2;
				try { DebugEnterSubRule(57);
				try { DebugEnterDecision(57, false);
				int LA57_1 = input.LA(1);

				if ((LA57_1==ADD||LA57_1==DEC||LA57_1==DELETE||LA57_1==DecimalLiteral||LA57_1==FALSE||LA57_1==FUNCTION||LA57_1==HexIntegerLiteral||LA57_1==INC||LA57_1==INV||LA57_1==Identifier||(LA57_1>=LBRACE && LA57_1<=LBRACK)||LA57_1==LPAREN||(LA57_1>=NEW && LA57_1<=NOT)||LA57_1==NULL||LA57_1==OctalIntegerLiteral||LA57_1==RegularExpressionLiteral||LA57_1==SUB||LA57_1==StringLiteral||LA57_1==THIS||LA57_1==TRUE||LA57_1==TYPEOF||LA57_1==VOID))
				{
					alt57 = 1;
				}
				} finally { DebugExitDecision(57); }
				switch (alt57)
				{
				case 1:
					DebugEnterAlt(1);
					// JavaScript.g:1138:35: ex3= expression
					{
					DebugLocation(1138, 35);
					PushFollow(Follow._expression_in_forControlExpression5160);
					ex3=expression();
					PopFollow();

					stream_expression.Add(ex3.Tree);

					}
					break;

				}
				} finally { DebugExitSubRule(57); }



				{
				// AST REWRITE
				// elements: ex1, ex2, ex3
				// token labels: 
				// rule labels: ex1, ex2, ex3, retval
				// token list labels: 
				// rule list labels: 
				// wildcard labels: 
				retval.Tree = root_0;
				RewriteRuleSubtreeStream stream_ex1=new RewriteRuleSubtreeStream(adaptor,"rule ex1",ex1!=null?ex1.Tree:null);
				RewriteRuleSubtreeStream stream_ex2=new RewriteRuleSubtreeStream(adaptor,"rule ex2",ex2!=null?ex2.Tree:null);
				RewriteRuleSubtreeStream stream_ex3=new RewriteRuleSubtreeStream(adaptor,"rule ex3",ex3!=null?ex3.Tree:null);
				RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

				root_0 = (object)adaptor.Nil();
				// 1139:4: -> ^( FORSTEP ^( EXPR $ex1) ^( EXPR ( $ex2)? ) ^( EXPR ( $ex3)? ) )
				{
					DebugLocation(1139, 7);
					// JavaScript.g:1139:7: ^( FORSTEP ^( EXPR $ex1) ^( EXPR ( $ex2)? ) ^( EXPR ( $ex3)? ) )
					{
					object root_1 = (object)adaptor.Nil();
					DebugLocation(1139, 10);
					root_1 = (object)adaptor.BecomeRoot((object)adaptor.Create(FORSTEP, "FORSTEP"), root_1);

					DebugLocation(1139, 18);
					// JavaScript.g:1139:18: ^( EXPR $ex1)
					{
					object root_2 = (object)adaptor.Nil();
					DebugLocation(1139, 21);
					root_2 = (object)adaptor.BecomeRoot((object)adaptor.Create(EXPR, "EXPR"), root_2);

					DebugLocation(1139, 27);
					adaptor.AddChild(root_2, stream_ex1.NextTree());

					adaptor.AddChild(root_1, root_2);
					}
					DebugLocation(1139, 33);
					// JavaScript.g:1139:33: ^( EXPR ( $ex2)? )
					{
					object root_2 = (object)adaptor.Nil();
					DebugLocation(1139, 36);
					root_2 = (object)adaptor.BecomeRoot((object)adaptor.Create(EXPR, "EXPR"), root_2);

					DebugLocation(1139, 42);
					// JavaScript.g:1139:42: ( $ex2)?
					if (stream_ex2.HasNext)
					{
						DebugLocation(1139, 42);
						adaptor.AddChild(root_2, stream_ex2.NextTree());

					}
					stream_ex2.Reset();

					adaptor.AddChild(root_1, root_2);
					}
					DebugLocation(1139, 49);
					// JavaScript.g:1139:49: ^( EXPR ( $ex3)? )
					{
					object root_2 = (object)adaptor.Nil();
					DebugLocation(1139, 52);
					root_2 = (object)adaptor.BecomeRoot((object)adaptor.Create(EXPR, "EXPR"), root_2);

					DebugLocation(1139, 58);
					// JavaScript.g:1139:58: ( $ex3)?
					if (stream_ex3.HasNext)
					{
						DebugLocation(1139, 58);
						adaptor.AddChild(root_2, stream_ex3.NextTree());

					}
					stream_ex3.Reset();

					adaptor.AddChild(root_1, root_2);
					}

					adaptor.AddChild(root_0, root_1);
					}

				}

				retval.Tree = root_0;
				}

				}


				}
				break;

			}
			} finally { DebugExitSubRule(58); }


			}

			retval.Stop = (IToken)input.LT(-1);

			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);

		}
		 
		finally
		{
			TraceOut("forControlExpression", 63);
			LeaveRule("forControlExpression", 63);
			LeaveRule_forControlExpression();
		}
		DebugLocation(1142, 1);
		} finally { DebugExitRule(GrammarFileName, "forControlExpression"); }
		return retval;

	}
	// $ANTLR end "forControlExpression"

	partial void EnterRule_forControlSemic();
	partial void LeaveRule_forControlSemic();
	// $ANTLR start "forControlSemic"
	// JavaScript.g:1144:1: forControlSemic : SEMIC (ex1= expression )? SEMIC (ex2= expression )? -> ^( FORSTEP ^( EXPR ) ^( EXPR ( $ex1)? ) ^( EXPR ( $ex2)? ) ) ;
	[GrammarRule("forControlSemic")]
	private AstParserRuleReturnScope<object, IToken> forControlSemic()
	{
		EnterRule_forControlSemic();
		EnterRule("forControlSemic", 64);
		TraceIn("forControlSemic", 64);
		AstParserRuleReturnScope<object, IToken> retval = new AstParserRuleReturnScope<object, IToken>();
		retval.Start = (IToken)input.LT(1);

		object root_0 = default(object);

		IToken SEMIC215 = default(IToken);
		IToken SEMIC216 = default(IToken);
		AstParserRuleReturnScope<object, IToken> ex1 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> ex2 = default(AstParserRuleReturnScope<object, IToken>);

		object SEMIC215_tree = default(object);
		object SEMIC216_tree = default(object);
		RewriteRuleITokenStream stream_SEMIC=new RewriteRuleITokenStream(adaptor,"token SEMIC");
		RewriteRuleSubtreeStream stream_expression=new RewriteRuleSubtreeStream(adaptor,"rule expression");
		try { DebugEnterRule(GrammarFileName, "forControlSemic");
		DebugLocation(1144, 1);
		try
		{
			// JavaScript.g:1145:2: ( SEMIC (ex1= expression )? SEMIC (ex2= expression )? -> ^( FORSTEP ^( EXPR ) ^( EXPR ( $ex1)? ) ^( EXPR ( $ex2)? ) ) )
			DebugEnterAlt(1);
			// JavaScript.g:1145:4: SEMIC (ex1= expression )? SEMIC (ex2= expression )?
			{
			DebugLocation(1145, 4);
			SEMIC215=(IToken)Match(input,SEMIC,Follow._SEMIC_in_forControlSemic5219);  
			stream_SEMIC.Add(SEMIC215);

			DebugLocation(1145, 13);
			// JavaScript.g:1145:13: (ex1= expression )?
			int alt59=2;
			try { DebugEnterSubRule(59);
			try { DebugEnterDecision(59, false);
			int LA59_1 = input.LA(1);

			if ((LA59_1==ADD||LA59_1==DEC||LA59_1==DELETE||LA59_1==DecimalLiteral||LA59_1==FALSE||LA59_1==FUNCTION||LA59_1==HexIntegerLiteral||LA59_1==INC||LA59_1==INV||LA59_1==Identifier||(LA59_1>=LBRACE && LA59_1<=LBRACK)||LA59_1==LPAREN||(LA59_1>=NEW && LA59_1<=NOT)||LA59_1==NULL||LA59_1==OctalIntegerLiteral||LA59_1==RegularExpressionLiteral||LA59_1==SUB||LA59_1==StringLiteral||LA59_1==THIS||LA59_1==TRUE||LA59_1==TYPEOF||LA59_1==VOID))
			{
				alt59 = 1;
			}
			} finally { DebugExitDecision(59); }
			switch (alt59)
			{
			case 1:
				DebugEnterAlt(1);
				// JavaScript.g:1145:13: ex1= expression
				{
				DebugLocation(1145, 13);
				PushFollow(Follow._expression_in_forControlSemic5223);
				ex1=expression();
				PopFollow();

				stream_expression.Add(ex1.Tree);

				}
				break;

			}
			} finally { DebugExitSubRule(59); }

			DebugLocation(1145, 26);
			SEMIC216=(IToken)Match(input,SEMIC,Follow._SEMIC_in_forControlSemic5226);  
			stream_SEMIC.Add(SEMIC216);

			DebugLocation(1145, 35);
			// JavaScript.g:1145:35: (ex2= expression )?
			int alt60=2;
			try { DebugEnterSubRule(60);
			try { DebugEnterDecision(60, false);
			int LA60_1 = input.LA(1);

			if ((LA60_1==ADD||LA60_1==DEC||LA60_1==DELETE||LA60_1==DecimalLiteral||LA60_1==FALSE||LA60_1==FUNCTION||LA60_1==HexIntegerLiteral||LA60_1==INC||LA60_1==INV||LA60_1==Identifier||(LA60_1>=LBRACE && LA60_1<=LBRACK)||LA60_1==LPAREN||(LA60_1>=NEW && LA60_1<=NOT)||LA60_1==NULL||LA60_1==OctalIntegerLiteral||LA60_1==RegularExpressionLiteral||LA60_1==SUB||LA60_1==StringLiteral||LA60_1==THIS||LA60_1==TRUE||LA60_1==TYPEOF||LA60_1==VOID))
			{
				alt60 = 1;
			}
			} finally { DebugExitDecision(60); }
			switch (alt60)
			{
			case 1:
				DebugEnterAlt(1);
				// JavaScript.g:1145:35: ex2= expression
				{
				DebugLocation(1145, 35);
				PushFollow(Follow._expression_in_forControlSemic5230);
				ex2=expression();
				PopFollow();

				stream_expression.Add(ex2.Tree);

				}
				break;

			}
			} finally { DebugExitSubRule(60); }



			{
			// AST REWRITE
			// elements: ex1, ex2
			// token labels: 
			// rule labels: ex1, ex2, retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			retval.Tree = root_0;
			RewriteRuleSubtreeStream stream_ex1=new RewriteRuleSubtreeStream(adaptor,"rule ex1",ex1!=null?ex1.Tree:null);
			RewriteRuleSubtreeStream stream_ex2=new RewriteRuleSubtreeStream(adaptor,"rule ex2",ex2!=null?ex2.Tree:null);
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

			root_0 = (object)adaptor.Nil();
			// 1146:2: -> ^( FORSTEP ^( EXPR ) ^( EXPR ( $ex1)? ) ^( EXPR ( $ex2)? ) )
			{
				DebugLocation(1146, 5);
				// JavaScript.g:1146:5: ^( FORSTEP ^( EXPR ) ^( EXPR ( $ex1)? ) ^( EXPR ( $ex2)? ) )
				{
				object root_1 = (object)adaptor.Nil();
				DebugLocation(1146, 8);
				root_1 = (object)adaptor.BecomeRoot((object)adaptor.Create(FORSTEP, "FORSTEP"), root_1);

				DebugLocation(1146, 16);
				// JavaScript.g:1146:16: ^( EXPR )
				{
				object root_2 = (object)adaptor.Nil();
				DebugLocation(1146, 19);
				root_2 = (object)adaptor.BecomeRoot((object)adaptor.Create(EXPR, "EXPR"), root_2);

				adaptor.AddChild(root_1, root_2);
				}
				DebugLocation(1146, 26);
				// JavaScript.g:1146:26: ^( EXPR ( $ex1)? )
				{
				object root_2 = (object)adaptor.Nil();
				DebugLocation(1146, 29);
				root_2 = (object)adaptor.BecomeRoot((object)adaptor.Create(EXPR, "EXPR"), root_2);

				DebugLocation(1146, 35);
				// JavaScript.g:1146:35: ( $ex1)?
				if (stream_ex1.HasNext)
				{
					DebugLocation(1146, 35);
					adaptor.AddChild(root_2, stream_ex1.NextTree());

				}
				stream_ex1.Reset();

				adaptor.AddChild(root_1, root_2);
				}
				DebugLocation(1146, 42);
				// JavaScript.g:1146:42: ^( EXPR ( $ex2)? )
				{
				object root_2 = (object)adaptor.Nil();
				DebugLocation(1146, 45);
				root_2 = (object)adaptor.BecomeRoot((object)adaptor.Create(EXPR, "EXPR"), root_2);

				DebugLocation(1146, 51);
				// JavaScript.g:1146:51: ( $ex2)?
				if (stream_ex2.HasNext)
				{
					DebugLocation(1146, 51);
					adaptor.AddChild(root_2, stream_ex2.NextTree());

				}
				stream_ex2.Reset();

				adaptor.AddChild(root_1, root_2);
				}

				adaptor.AddChild(root_0, root_1);
				}

			}

			retval.Tree = root_0;
			}

			}

			retval.Stop = (IToken)input.LT(-1);

			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);

		}
		 
		finally
		{
			TraceOut("forControlSemic", 64);
			LeaveRule("forControlSemic", 64);
			LeaveRule_forControlSemic();
		}
		DebugLocation(1147, 1);
		} finally { DebugExitRule(GrammarFileName, "forControlSemic"); }
		return retval;

	}
	// $ANTLR end "forControlSemic"

	partial void EnterRule_continueStatement();
	partial void LeaveRule_continueStatement();
	// $ANTLR start "continueStatement"
	// JavaScript.g:1158:1: continueStatement : CONTINUE ^ ( Identifier )? semic !;
	[GrammarRule("continueStatement")]
	private AstParserRuleReturnScope<object, IToken> continueStatement()
	{
		EnterRule_continueStatement();
		EnterRule("continueStatement", 65);
		TraceIn("continueStatement", 65);
		AstParserRuleReturnScope<object, IToken> retval = new AstParserRuleReturnScope<object, IToken>();
		retval.Start = (IToken)input.LT(1);

		object root_0 = default(object);

		IToken CONTINUE217 = default(IToken);
		IToken Identifier218 = default(IToken);
		AstParserRuleReturnScope<object, IToken> semic219 = default(AstParserRuleReturnScope<object, IToken>);

		object CONTINUE217_tree = default(object);
		object Identifier218_tree = default(object);
		try { DebugEnterRule(GrammarFileName, "continueStatement");
		DebugLocation(1158, 1);
		try
		{
			// JavaScript.g:1159:2: ( CONTINUE ^ ( Identifier )? semic !)
			DebugEnterAlt(1);
			// JavaScript.g:1159:4: CONTINUE ^ ( Identifier )? semic !
			{
			root_0 = (object)adaptor.Nil();

			DebugLocation(1159, 12);
			CONTINUE217=(IToken)Match(input,CONTINUE,Follow._CONTINUE_in_continueStatement5284); 
			CONTINUE217_tree = (object)adaptor.Create(CONTINUE217);
			root_0 = (object)adaptor.BecomeRoot(CONTINUE217_tree, root_0);
			DebugLocation(1159, 14);
			 if (input.LA(1) == Identifier) PromoteEol(null); 
			DebugLocation(1159, 67);
			// JavaScript.g:1159:67: ( Identifier )?
			int alt61=2;
			try { DebugEnterSubRule(61);
			try { DebugEnterDecision(61, false);
			int LA61_1 = input.LA(1);

			if ((LA61_1==Identifier))
			{
				alt61 = 1;
			}
			} finally { DebugExitDecision(61); }
			switch (alt61)
			{
			case 1:
				DebugEnterAlt(1);
				// JavaScript.g:1159:67: Identifier
				{
				DebugLocation(1159, 67);
				Identifier218=(IToken)Match(input,Identifier,Follow._Identifier_in_continueStatement5289); 
				Identifier218_tree = (object)adaptor.Create(Identifier218);
				adaptor.AddChild(root_0, Identifier218_tree);

				}
				break;

			}
			} finally { DebugExitSubRule(61); }

			DebugLocation(1159, 84);
			PushFollow(Follow._semic_in_continueStatement5292);
			semic219=semic();
			PopFollow();


			}

			retval.Stop = (IToken)input.LT(-1);

			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);

		}
		 
		finally
		{
			TraceOut("continueStatement", 65);
			LeaveRule("continueStatement", 65);
			LeaveRule_continueStatement();
		}
		DebugLocation(1160, 1);
		} finally { DebugExitRule(GrammarFileName, "continueStatement"); }
		return retval;

	}
	// $ANTLR end "continueStatement"

	partial void EnterRule_breakStatement();
	partial void LeaveRule_breakStatement();
	// $ANTLR start "breakStatement"
	// JavaScript.g:1171:1: breakStatement : BREAK ^ ( Identifier )? semic !;
	[GrammarRule("breakStatement")]
	private AstParserRuleReturnScope<object, IToken> breakStatement()
	{
		EnterRule_breakStatement();
		EnterRule("breakStatement", 66);
		TraceIn("breakStatement", 66);
		AstParserRuleReturnScope<object, IToken> retval = new AstParserRuleReturnScope<object, IToken>();
		retval.Start = (IToken)input.LT(1);

		object root_0 = default(object);

		IToken BREAK220 = default(IToken);
		IToken Identifier221 = default(IToken);
		AstParserRuleReturnScope<object, IToken> semic222 = default(AstParserRuleReturnScope<object, IToken>);

		object BREAK220_tree = default(object);
		object Identifier221_tree = default(object);
		try { DebugEnterRule(GrammarFileName, "breakStatement");
		DebugLocation(1171, 1);
		try
		{
			// JavaScript.g:1172:2: ( BREAK ^ ( Identifier )? semic !)
			DebugEnterAlt(1);
			// JavaScript.g:1172:4: BREAK ^ ( Identifier )? semic !
			{
			root_0 = (object)adaptor.Nil();

			DebugLocation(1172, 9);
			BREAK220=(IToken)Match(input,BREAK,Follow._BREAK_in_breakStatement5311); 
			BREAK220_tree = (object)adaptor.Create(BREAK220);
			root_0 = (object)adaptor.BecomeRoot(BREAK220_tree, root_0);
			DebugLocation(1172, 11);
			 if (input.LA(1) == Identifier) PromoteEol(null); 
			DebugLocation(1172, 64);
			// JavaScript.g:1172:64: ( Identifier )?
			int alt62=2;
			try { DebugEnterSubRule(62);
			try { DebugEnterDecision(62, false);
			int LA62_1 = input.LA(1);

			if ((LA62_1==Identifier))
			{
				alt62 = 1;
			}
			} finally { DebugExitDecision(62); }
			switch (alt62)
			{
			case 1:
				DebugEnterAlt(1);
				// JavaScript.g:1172:64: Identifier
				{
				DebugLocation(1172, 64);
				Identifier221=(IToken)Match(input,Identifier,Follow._Identifier_in_breakStatement5316); 
				Identifier221_tree = (object)adaptor.Create(Identifier221);
				adaptor.AddChild(root_0, Identifier221_tree);

				}
				break;

			}
			} finally { DebugExitSubRule(62); }

			DebugLocation(1172, 81);
			PushFollow(Follow._semic_in_breakStatement5319);
			semic222=semic();
			PopFollow();


			}

			retval.Stop = (IToken)input.LT(-1);

			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);

		}
		 
		finally
		{
			TraceOut("breakStatement", 66);
			LeaveRule("breakStatement", 66);
			LeaveRule_breakStatement();
		}
		DebugLocation(1173, 1);
		} finally { DebugExitRule(GrammarFileName, "breakStatement"); }
		return retval;

	}
	// $ANTLR end "breakStatement"

	partial void EnterRule_returnStatement();
	partial void LeaveRule_returnStatement();
	// $ANTLR start "returnStatement"
	// JavaScript.g:1192:1: returnStatement : RETURN ^ ( expression )? semic !;
	[GrammarRule("returnStatement")]
	private AstParserRuleReturnScope<object, IToken> returnStatement()
	{
		EnterRule_returnStatement();
		EnterRule("returnStatement", 67);
		TraceIn("returnStatement", 67);
		AstParserRuleReturnScope<object, IToken> retval = new AstParserRuleReturnScope<object, IToken>();
		retval.Start = (IToken)input.LT(1);

		object root_0 = default(object);

		IToken RETURN223 = default(IToken);
		AstParserRuleReturnScope<object, IToken> expression224 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> semic225 = default(AstParserRuleReturnScope<object, IToken>);

		object RETURN223_tree = default(object);
		try { DebugEnterRule(GrammarFileName, "returnStatement");
		DebugLocation(1192, 1);
		try
		{
			// JavaScript.g:1193:2: ( RETURN ^ ( expression )? semic !)
			DebugEnterAlt(1);
			// JavaScript.g:1193:4: RETURN ^ ( expression )? semic !
			{
			root_0 = (object)adaptor.Nil();

			DebugLocation(1193, 10);
			RETURN223=(IToken)Match(input,RETURN,Follow._RETURN_in_returnStatement5338); 
			RETURN223_tree = (object)adaptor.Create(RETURN223);
			root_0 = (object)adaptor.BecomeRoot(RETURN223_tree, root_0);
			DebugLocation(1193, 12);
			 PromoteEol(null); 
			DebugLocation(1193, 34);
			// JavaScript.g:1193:34: ( expression )?
			int alt63=2;
			try { DebugEnterSubRule(63);
			try { DebugEnterDecision(63, false);
			int LA63_1 = input.LA(1);

			if ((LA63_1==ADD||LA63_1==DEC||LA63_1==DELETE||LA63_1==DecimalLiteral||LA63_1==FALSE||LA63_1==FUNCTION||LA63_1==HexIntegerLiteral||LA63_1==INC||LA63_1==INV||LA63_1==Identifier||(LA63_1>=LBRACE && LA63_1<=LBRACK)||LA63_1==LPAREN||(LA63_1>=NEW && LA63_1<=NOT)||LA63_1==NULL||LA63_1==OctalIntegerLiteral||LA63_1==RegularExpressionLiteral||LA63_1==SUB||LA63_1==StringLiteral||LA63_1==THIS||LA63_1==TRUE||LA63_1==TYPEOF||LA63_1==VOID))
			{
				alt63 = 1;
			}
			} finally { DebugExitDecision(63); }
			switch (alt63)
			{
			case 1:
				DebugEnterAlt(1);
				// JavaScript.g:1193:34: expression
				{
				DebugLocation(1193, 34);
				PushFollow(Follow._expression_in_returnStatement5343);
				expression224=expression();
				PopFollow();

				adaptor.AddChild(root_0, expression224.Tree);

				}
				break;

			}
			} finally { DebugExitSubRule(63); }

			DebugLocation(1193, 51);
			PushFollow(Follow._semic_in_returnStatement5346);
			semic225=semic();
			PopFollow();


			}

			retval.Stop = (IToken)input.LT(-1);

			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);

		}
		 
		finally
		{
			TraceOut("returnStatement", 67);
			LeaveRule("returnStatement", 67);
			LeaveRule_returnStatement();
		}
		DebugLocation(1194, 1);
		} finally { DebugExitRule(GrammarFileName, "returnStatement"); }
		return retval;

	}
	// $ANTLR end "returnStatement"

	partial void EnterRule_withStatement();
	partial void LeaveRule_withStatement();
	// $ANTLR start "withStatement"
	// JavaScript.g:1200:1: withStatement : WITH ^ LPAREN ! expression RPAREN ! statement ;
	[GrammarRule("withStatement")]
	private AstParserRuleReturnScope<object, IToken> withStatement()
	{
		EnterRule_withStatement();
		EnterRule("withStatement", 68);
		TraceIn("withStatement", 68);
		AstParserRuleReturnScope<object, IToken> retval = new AstParserRuleReturnScope<object, IToken>();
		retval.Start = (IToken)input.LT(1);

		object root_0 = default(object);

		IToken WITH226 = default(IToken);
		IToken LPAREN227 = default(IToken);
		IToken RPAREN229 = default(IToken);
		AstParserRuleReturnScope<object, IToken> expression228 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> statement230 = default(AstParserRuleReturnScope<object, IToken>);

		object WITH226_tree = default(object);
		object LPAREN227_tree = default(object);
		object RPAREN229_tree = default(object);
		try { DebugEnterRule(GrammarFileName, "withStatement");
		DebugLocation(1200, 1);
		try
		{
			// JavaScript.g:1201:2: ( WITH ^ LPAREN ! expression RPAREN ! statement )
			DebugEnterAlt(1);
			// JavaScript.g:1201:4: WITH ^ LPAREN ! expression RPAREN ! statement
			{
			root_0 = (object)adaptor.Nil();

			DebugLocation(1201, 8);
			WITH226=(IToken)Match(input,WITH,Follow._WITH_in_withStatement5363); 
			WITH226_tree = (object)adaptor.Create(WITH226);
			root_0 = (object)adaptor.BecomeRoot(WITH226_tree, root_0);
			DebugLocation(1201, 16);
			LPAREN227=(IToken)Match(input,LPAREN,Follow._LPAREN_in_withStatement5366); 
			DebugLocation(1201, 18);
			PushFollow(Follow._expression_in_withStatement5369);
			expression228=expression();
			PopFollow();

			adaptor.AddChild(root_0, expression228.Tree);
			DebugLocation(1201, 35);
			RPAREN229=(IToken)Match(input,RPAREN,Follow._RPAREN_in_withStatement5371); 
			DebugLocation(1201, 37);
			PushFollow(Follow._statement_in_withStatement5374);
			statement230=statement();
			PopFollow();

			adaptor.AddChild(root_0, statement230.Tree);

			}

			retval.Stop = (IToken)input.LT(-1);

			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);

		}
		 
		finally
		{
			TraceOut("withStatement", 68);
			LeaveRule("withStatement", 68);
			LeaveRule_withStatement();
		}
		DebugLocation(1202, 1);
		} finally { DebugExitRule(GrammarFileName, "withStatement"); }
		return retval;

	}
	// $ANTLR end "withStatement"

	partial void EnterRule_switchStatement();
	partial void LeaveRule_switchStatement();
	// $ANTLR start "switchStatement"
	// JavaScript.g:1208:1: switchStatement : SWITCH LPAREN expression RPAREN LBRACE ({...}? => defaultClause | caseClause )* RBRACE -> ^( SWITCH expression ( defaultClause )? ( caseClause )* ) ;
	[GrammarRule("switchStatement")]
	private AstParserRuleReturnScope<object, IToken> switchStatement()
	{
		EnterRule_switchStatement();
		EnterRule("switchStatement", 69);
		TraceIn("switchStatement", 69);
		AstParserRuleReturnScope<object, IToken> retval = new AstParserRuleReturnScope<object, IToken>();
		retval.Start = (IToken)input.LT(1);

		object root_0 = default(object);

		IToken SWITCH231 = default(IToken);
		IToken LPAREN232 = default(IToken);
		IToken RPAREN234 = default(IToken);
		IToken LBRACE235 = default(IToken);
		IToken RBRACE238 = default(IToken);
		AstParserRuleReturnScope<object, IToken> expression233 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> defaultClause236 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> caseClause237 = default(AstParserRuleReturnScope<object, IToken>);

		object SWITCH231_tree = default(object);
		object LPAREN232_tree = default(object);
		object RPAREN234_tree = default(object);
		object LBRACE235_tree = default(object);
		object RBRACE238_tree = default(object);
		RewriteRuleITokenStream stream_SWITCH=new RewriteRuleITokenStream(adaptor,"token SWITCH");
		RewriteRuleITokenStream stream_LPAREN=new RewriteRuleITokenStream(adaptor,"token LPAREN");
		RewriteRuleITokenStream stream_RPAREN=new RewriteRuleITokenStream(adaptor,"token RPAREN");
		RewriteRuleITokenStream stream_LBRACE=new RewriteRuleITokenStream(adaptor,"token LBRACE");
		RewriteRuleITokenStream stream_RBRACE=new RewriteRuleITokenStream(adaptor,"token RBRACE");
		RewriteRuleSubtreeStream stream_expression=new RewriteRuleSubtreeStream(adaptor,"rule expression");
		RewriteRuleSubtreeStream stream_defaultClause=new RewriteRuleSubtreeStream(adaptor,"rule defaultClause");
		RewriteRuleSubtreeStream stream_caseClause=new RewriteRuleSubtreeStream(adaptor,"rule caseClause");

			int defaultClauseCount = 0;

		try { DebugEnterRule(GrammarFileName, "switchStatement");
		DebugLocation(1208, 1);
		try
		{
			// JavaScript.g:1213:2: ( SWITCH LPAREN expression RPAREN LBRACE ({...}? => defaultClause | caseClause )* RBRACE -> ^( SWITCH expression ( defaultClause )? ( caseClause )* ) )
			DebugEnterAlt(1);
			// JavaScript.g:1213:4: SWITCH LPAREN expression RPAREN LBRACE ({...}? => defaultClause | caseClause )* RBRACE
			{
			DebugLocation(1213, 4);
			SWITCH231=(IToken)Match(input,SWITCH,Follow._SWITCH_in_switchStatement5395);  
			stream_SWITCH.Add(SWITCH231);

			DebugLocation(1213, 11);
			LPAREN232=(IToken)Match(input,LPAREN,Follow._LPAREN_in_switchStatement5397);  
			stream_LPAREN.Add(LPAREN232);

			DebugLocation(1213, 18);
			PushFollow(Follow._expression_in_switchStatement5399);
			expression233=expression();
			PopFollow();

			stream_expression.Add(expression233.Tree);
			DebugLocation(1213, 29);
			RPAREN234=(IToken)Match(input,RPAREN,Follow._RPAREN_in_switchStatement5401);  
			stream_RPAREN.Add(RPAREN234);

			DebugLocation(1213, 36);
			LBRACE235=(IToken)Match(input,LBRACE,Follow._LBRACE_in_switchStatement5403);  
			stream_LBRACE.Add(LBRACE235);

			DebugLocation(1213, 43);
			// JavaScript.g:1213:43: ({...}? => defaultClause | caseClause )*
			try { DebugEnterSubRule(64);
			while (true)
			{
				int alt64=3;
				try { DebugEnterDecision(64, false);
				int LA64_1 = input.LA(1);

				if ((LA64_1==DEFAULT) && (( defaultClauseCount == 0 )))
				{
					alt64 = 1;
				}
				else if ((LA64_1==CASE))
				{
					alt64 = 2;
				}


				} finally { DebugExitDecision(64); }
				switch ( alt64 )
				{
				case 1:
					DebugEnterAlt(1);
					// JavaScript.g:1213:45: {...}? => defaultClause
					{
					DebugLocation(1213, 45);
					if (!(( defaultClauseCount == 0 )))
					{
						throw new FailedPredicateException(input, "switchStatement", " defaultClauseCount == 0 ");
					}
					DebugLocation(1213, 76);
					PushFollow(Follow._defaultClause_in_switchStatement5410);
					defaultClause236=defaultClause();
					PopFollow();

					stream_defaultClause.Add(defaultClause236.Tree);
					DebugLocation(1213, 90);
					 defaultClauseCount++; 

					}
					break;
				case 2:
					DebugEnterAlt(2);
					// JavaScript.g:1213:118: caseClause
					{
					DebugLocation(1213, 118);
					PushFollow(Follow._caseClause_in_switchStatement5416);
					caseClause237=caseClause();
					PopFollow();

					stream_caseClause.Add(caseClause237.Tree);

					}
					break;

				default:
					goto loop64;
				}
			}

			loop64:
				;

			} finally { DebugExitSubRule(64); }

			DebugLocation(1213, 132);
			RBRACE238=(IToken)Match(input,RBRACE,Follow._RBRACE_in_switchStatement5421);  
			stream_RBRACE.Add(RBRACE238);



			{
			// AST REWRITE
			// elements: SWITCH, expression, defaultClause, caseClause
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			retval.Tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

			root_0 = (object)adaptor.Nil();
			// 1214:2: -> ^( SWITCH expression ( defaultClause )? ( caseClause )* )
			{
				DebugLocation(1214, 5);
				// JavaScript.g:1214:5: ^( SWITCH expression ( defaultClause )? ( caseClause )* )
				{
				object root_1 = (object)adaptor.Nil();
				DebugLocation(1214, 8);
				root_1 = (object)adaptor.BecomeRoot(stream_SWITCH.NextNode(), root_1);

				DebugLocation(1214, 15);
				adaptor.AddChild(root_1, stream_expression.NextTree());
				DebugLocation(1214, 26);
				// JavaScript.g:1214:26: ( defaultClause )?
				if (stream_defaultClause.HasNext)
				{
					DebugLocation(1214, 26);
					adaptor.AddChild(root_1, stream_defaultClause.NextTree());

				}
				stream_defaultClause.Reset();
				DebugLocation(1214, 41);
				// JavaScript.g:1214:41: ( caseClause )*
				while ( stream_caseClause.HasNext )
				{
					DebugLocation(1214, 41);
					adaptor.AddChild(root_1, stream_caseClause.NextTree());

				}
				stream_caseClause.Reset();

				adaptor.AddChild(root_0, root_1);
				}

			}

			retval.Tree = root_0;
			}

			}

			retval.Stop = (IToken)input.LT(-1);

			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);

		}
		 
		finally
		{
			TraceOut("switchStatement", 69);
			LeaveRule("switchStatement", 69);
			LeaveRule_switchStatement();
		}
		DebugLocation(1215, 1);
		} finally { DebugExitRule(GrammarFileName, "switchStatement"); }
		return retval;

	}
	// $ANTLR end "switchStatement"

	partial void EnterRule_caseClause();
	partial void LeaveRule_caseClause();
	// $ANTLR start "caseClause"
	// JavaScript.g:1217:1: caseClause : CASE ^ expression COLON ! ( statement )* ;
	[GrammarRule("caseClause")]
	private AstParserRuleReturnScope<object, IToken> caseClause()
	{
		EnterRule_caseClause();
		EnterRule("caseClause", 70);
		TraceIn("caseClause", 70);
		AstParserRuleReturnScope<object, IToken> retval = new AstParserRuleReturnScope<object, IToken>();
		retval.Start = (IToken)input.LT(1);

		object root_0 = default(object);

		IToken CASE239 = default(IToken);
		IToken COLON241 = default(IToken);
		AstParserRuleReturnScope<object, IToken> expression240 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> statement242 = default(AstParserRuleReturnScope<object, IToken>);

		object CASE239_tree = default(object);
		object COLON241_tree = default(object);
		try { DebugEnterRule(GrammarFileName, "caseClause");
		DebugLocation(1217, 1);
		try
		{
			// JavaScript.g:1218:2: ( CASE ^ expression COLON ! ( statement )* )
			DebugEnterAlt(1);
			// JavaScript.g:1218:4: CASE ^ expression COLON ! ( statement )*
			{
			root_0 = (object)adaptor.Nil();

			DebugLocation(1218, 8);
			CASE239=(IToken)Match(input,CASE,Follow._CASE_in_caseClause5449); 
			CASE239_tree = (object)adaptor.Create(CASE239);
			root_0 = (object)adaptor.BecomeRoot(CASE239_tree, root_0);
			DebugLocation(1218, 10);
			PushFollow(Follow._expression_in_caseClause5452);
			expression240=expression();
			PopFollow();

			adaptor.AddChild(root_0, expression240.Tree);
			DebugLocation(1218, 26);
			COLON241=(IToken)Match(input,COLON,Follow._COLON_in_caseClause5454); 
			DebugLocation(1218, 28);
			// JavaScript.g:1218:28: ( statement )*
			try { DebugEnterSubRule(65);
			while (true)
			{
				int alt65=2;
				try { DebugEnterDecision(65, false);
				int LA65_1 = input.LA(1);

				if ((LA65_1==ADD||LA65_1==BREAK||LA65_1==CONTINUE||LA65_1==DEC||LA65_1==DELETE||LA65_1==DO||LA65_1==DecimalLiteral||LA65_1==FALSE||LA65_1==FOR||LA65_1==FUNCTION||(LA65_1>=HexIntegerLiteral && LA65_1<=IF)||LA65_1==INC||LA65_1==INV||LA65_1==Identifier||(LA65_1>=LBRACE && LA65_1<=LBRACK)||LA65_1==LPAREN||(LA65_1>=NEW && LA65_1<=NOT)||LA65_1==NULL||LA65_1==OctalIntegerLiteral||LA65_1==RETURN||LA65_1==RegularExpressionLiteral||LA65_1==SEMIC||LA65_1==SUB||LA65_1==SWITCH||LA65_1==StringLiteral||(LA65_1>=THIS && LA65_1<=THROW)||(LA65_1>=TRUE && LA65_1<=TYPEOF)||(LA65_1>=VAR && LA65_1<=VOID)||(LA65_1>=WHILE && LA65_1<=WITH)))
				{
					alt65 = 1;
				}


				} finally { DebugExitDecision(65); }
				switch ( alt65 )
				{
				case 1:
					DebugEnterAlt(1);
					// JavaScript.g:1218:28: statement
					{
					DebugLocation(1218, 28);
					PushFollow(Follow._statement_in_caseClause5457);
					statement242=statement();
					PopFollow();

					adaptor.AddChild(root_0, statement242.Tree);

					}
					break;

				default:
					goto loop65;
				}
			}

			loop65:
				;

			} finally { DebugExitSubRule(65); }


			}

			retval.Stop = (IToken)input.LT(-1);

			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);

		}
		 
		finally
		{
			TraceOut("caseClause", 70);
			LeaveRule("caseClause", 70);
			LeaveRule_caseClause();
		}
		DebugLocation(1219, 1);
		} finally { DebugExitRule(GrammarFileName, "caseClause"); }
		return retval;

	}
	// $ANTLR end "caseClause"

	partial void EnterRule_defaultClause();
	partial void LeaveRule_defaultClause();
	// $ANTLR start "defaultClause"
	// JavaScript.g:1221:1: defaultClause : DEFAULT ^ COLON ! ( statement )* ;
	[GrammarRule("defaultClause")]
	private AstParserRuleReturnScope<object, IToken> defaultClause()
	{
		EnterRule_defaultClause();
		EnterRule("defaultClause", 71);
		TraceIn("defaultClause", 71);
		AstParserRuleReturnScope<object, IToken> retval = new AstParserRuleReturnScope<object, IToken>();
		retval.Start = (IToken)input.LT(1);

		object root_0 = default(object);

		IToken DEFAULT243 = default(IToken);
		IToken COLON244 = default(IToken);
		AstParserRuleReturnScope<object, IToken> statement245 = default(AstParserRuleReturnScope<object, IToken>);

		object DEFAULT243_tree = default(object);
		object COLON244_tree = default(object);
		try { DebugEnterRule(GrammarFileName, "defaultClause");
		DebugLocation(1221, 1);
		try
		{
			// JavaScript.g:1222:2: ( DEFAULT ^ COLON ! ( statement )* )
			DebugEnterAlt(1);
			// JavaScript.g:1222:4: DEFAULT ^ COLON ! ( statement )*
			{
			root_0 = (object)adaptor.Nil();

			DebugLocation(1222, 11);
			DEFAULT243=(IToken)Match(input,DEFAULT,Follow._DEFAULT_in_defaultClause5470); 
			DEFAULT243_tree = (object)adaptor.Create(DEFAULT243);
			root_0 = (object)adaptor.BecomeRoot(DEFAULT243_tree, root_0);
			DebugLocation(1222, 18);
			COLON244=(IToken)Match(input,COLON,Follow._COLON_in_defaultClause5473); 
			DebugLocation(1222, 20);
			// JavaScript.g:1222:20: ( statement )*
			try { DebugEnterSubRule(66);
			while (true)
			{
				int alt66=2;
				try { DebugEnterDecision(66, false);
				int LA66_1 = input.LA(1);

				if ((LA66_1==ADD||LA66_1==BREAK||LA66_1==CONTINUE||LA66_1==DEC||LA66_1==DELETE||LA66_1==DO||LA66_1==DecimalLiteral||LA66_1==FALSE||LA66_1==FOR||LA66_1==FUNCTION||(LA66_1>=HexIntegerLiteral && LA66_1<=IF)||LA66_1==INC||LA66_1==INV||LA66_1==Identifier||(LA66_1>=LBRACE && LA66_1<=LBRACK)||LA66_1==LPAREN||(LA66_1>=NEW && LA66_1<=NOT)||LA66_1==NULL||LA66_1==OctalIntegerLiteral||LA66_1==RETURN||LA66_1==RegularExpressionLiteral||LA66_1==SEMIC||LA66_1==SUB||LA66_1==SWITCH||LA66_1==StringLiteral||(LA66_1>=THIS && LA66_1<=THROW)||(LA66_1>=TRUE && LA66_1<=TYPEOF)||(LA66_1>=VAR && LA66_1<=VOID)||(LA66_1>=WHILE && LA66_1<=WITH)))
				{
					alt66 = 1;
				}


				} finally { DebugExitDecision(66); }
				switch ( alt66 )
				{
				case 1:
					DebugEnterAlt(1);
					// JavaScript.g:1222:20: statement
					{
					DebugLocation(1222, 20);
					PushFollow(Follow._statement_in_defaultClause5476);
					statement245=statement();
					PopFollow();

					adaptor.AddChild(root_0, statement245.Tree);

					}
					break;

				default:
					goto loop66;
				}
			}

			loop66:
				;

			} finally { DebugExitSubRule(66); }


			}

			retval.Stop = (IToken)input.LT(-1);

			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);

		}
		 
		finally
		{
			TraceOut("defaultClause", 71);
			LeaveRule("defaultClause", 71);
			LeaveRule_defaultClause();
		}
		DebugLocation(1223, 1);
		} finally { DebugExitRule(GrammarFileName, "defaultClause"); }
		return retval;

	}
	// $ANTLR end "defaultClause"

	partial void EnterRule_labelledStatement();
	partial void LeaveRule_labelledStatement();
	// $ANTLR start "labelledStatement"
	// JavaScript.g:1229:1: labelledStatement : Identifier COLON statement -> ^( LABELLED Identifier statement ) ;
	[GrammarRule("labelledStatement")]
	private AstParserRuleReturnScope<object, IToken> labelledStatement()
	{
		EnterRule_labelledStatement();
		EnterRule("labelledStatement", 72);
		TraceIn("labelledStatement", 72);
		AstParserRuleReturnScope<object, IToken> retval = new AstParserRuleReturnScope<object, IToken>();
		retval.Start = (IToken)input.LT(1);

		object root_0 = default(object);

		IToken Identifier246 = default(IToken);
		IToken COLON247 = default(IToken);
		AstParserRuleReturnScope<object, IToken> statement248 = default(AstParserRuleReturnScope<object, IToken>);

		object Identifier246_tree = default(object);
		object COLON247_tree = default(object);
		RewriteRuleITokenStream stream_Identifier=new RewriteRuleITokenStream(adaptor,"token Identifier");
		RewriteRuleITokenStream stream_COLON=new RewriteRuleITokenStream(adaptor,"token COLON");
		RewriteRuleSubtreeStream stream_statement=new RewriteRuleSubtreeStream(adaptor,"rule statement");
		try { DebugEnterRule(GrammarFileName, "labelledStatement");
		DebugLocation(1229, 1);
		try
		{
			// JavaScript.g:1230:2: ( Identifier COLON statement -> ^( LABELLED Identifier statement ) )
			DebugEnterAlt(1);
			// JavaScript.g:1230:4: Identifier COLON statement
			{
			DebugLocation(1230, 4);
			Identifier246=(IToken)Match(input,Identifier,Follow._Identifier_in_labelledStatement5493);  
			stream_Identifier.Add(Identifier246);

			DebugLocation(1230, 15);
			COLON247=(IToken)Match(input,COLON,Follow._COLON_in_labelledStatement5495);  
			stream_COLON.Add(COLON247);

			DebugLocation(1230, 21);
			PushFollow(Follow._statement_in_labelledStatement5497);
			statement248=statement();
			PopFollow();

			stream_statement.Add(statement248.Tree);


			{
			// AST REWRITE
			// elements: Identifier, statement
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			retval.Tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

			root_0 = (object)adaptor.Nil();
			// 1231:2: -> ^( LABELLED Identifier statement )
			{
				DebugLocation(1231, 5);
				// JavaScript.g:1231:5: ^( LABELLED Identifier statement )
				{
				object root_1 = (object)adaptor.Nil();
				DebugLocation(1231, 8);
				root_1 = (object)adaptor.BecomeRoot((object)adaptor.Create(LABELLED, "LABELLED"), root_1);

				DebugLocation(1231, 17);
				adaptor.AddChild(root_1, stream_Identifier.NextNode());
				DebugLocation(1231, 28);
				adaptor.AddChild(root_1, stream_statement.NextTree());

				adaptor.AddChild(root_0, root_1);
				}

			}

			retval.Tree = root_0;
			}

			}

			retval.Stop = (IToken)input.LT(-1);

			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);

		}
		 
		finally
		{
			TraceOut("labelledStatement", 72);
			LeaveRule("labelledStatement", 72);
			LeaveRule_labelledStatement();
		}
		DebugLocation(1232, 1);
		} finally { DebugExitRule(GrammarFileName, "labelledStatement"); }
		return retval;

	}
	// $ANTLR end "labelledStatement"

	partial void EnterRule_throwStatement();
	partial void LeaveRule_throwStatement();
	// $ANTLR start "throwStatement"
	// JavaScript.g:1253:1: throwStatement : THROW ^ expression semic !;
	[GrammarRule("throwStatement")]
	private AstParserRuleReturnScope<object, IToken> throwStatement()
	{
		EnterRule_throwStatement();
		EnterRule("throwStatement", 73);
		TraceIn("throwStatement", 73);
		AstParserRuleReturnScope<object, IToken> retval = new AstParserRuleReturnScope<object, IToken>();
		retval.Start = (IToken)input.LT(1);

		object root_0 = default(object);

		IToken THROW249 = default(IToken);
		AstParserRuleReturnScope<object, IToken> expression250 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> semic251 = default(AstParserRuleReturnScope<object, IToken>);

		object THROW249_tree = default(object);
		try { DebugEnterRule(GrammarFileName, "throwStatement");
		DebugLocation(1253, 1);
		try
		{
			// JavaScript.g:1254:2: ( THROW ^ expression semic !)
			DebugEnterAlt(1);
			// JavaScript.g:1254:4: THROW ^ expression semic !
			{
			root_0 = (object)adaptor.Nil();

			DebugLocation(1254, 9);
			THROW249=(IToken)Match(input,THROW,Follow._THROW_in_throwStatement5528); 
			THROW249_tree = (object)adaptor.Create(THROW249);
			root_0 = (object)adaptor.BecomeRoot(THROW249_tree, root_0);
			DebugLocation(1254, 11);
			 PromoteEol(null); 
			DebugLocation(1254, 33);
			PushFollow(Follow._expression_in_throwStatement5533);
			expression250=expression();
			PopFollow();

			adaptor.AddChild(root_0, expression250.Tree);
			DebugLocation(1254, 49);
			PushFollow(Follow._semic_in_throwStatement5535);
			semic251=semic();
			PopFollow();


			}

			retval.Stop = (IToken)input.LT(-1);

			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);

		}
		 
		finally
		{
			TraceOut("throwStatement", 73);
			LeaveRule("throwStatement", 73);
			LeaveRule_throwStatement();
		}
		DebugLocation(1255, 1);
		} finally { DebugExitRule(GrammarFileName, "throwStatement"); }
		return retval;

	}
	// $ANTLR end "throwStatement"

	partial void EnterRule_tryStatement();
	partial void LeaveRule_tryStatement();
	// $ANTLR start "tryStatement"
	// JavaScript.g:1261:1: tryStatement : TRY ^ block ( catchClause ( finallyClause )? | finallyClause ) ;
	[GrammarRule("tryStatement")]
	private AstParserRuleReturnScope<object, IToken> tryStatement()
	{
		EnterRule_tryStatement();
		EnterRule("tryStatement", 74);
		TraceIn("tryStatement", 74);
		AstParserRuleReturnScope<object, IToken> retval = new AstParserRuleReturnScope<object, IToken>();
		retval.Start = (IToken)input.LT(1);

		object root_0 = default(object);

		IToken TRY252 = default(IToken);
		AstParserRuleReturnScope<object, IToken> block253 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> catchClause254 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> finallyClause255 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> finallyClause256 = default(AstParserRuleReturnScope<object, IToken>);

		object TRY252_tree = default(object);
		try { DebugEnterRule(GrammarFileName, "tryStatement");
		DebugLocation(1261, 1);
		try
		{
			// JavaScript.g:1262:2: ( TRY ^ block ( catchClause ( finallyClause )? | finallyClause ) )
			DebugEnterAlt(1);
			// JavaScript.g:1262:4: TRY ^ block ( catchClause ( finallyClause )? | finallyClause )
			{
			root_0 = (object)adaptor.Nil();

			DebugLocation(1262, 7);
			TRY252=(IToken)Match(input,TRY,Follow._TRY_in_tryStatement5552); 
			TRY252_tree = (object)adaptor.Create(TRY252);
			root_0 = (object)adaptor.BecomeRoot(TRY252_tree, root_0);
			DebugLocation(1262, 9);
			PushFollow(Follow._block_in_tryStatement5555);
			block253=block();
			PopFollow();

			adaptor.AddChild(root_0, block253.Tree);
			DebugLocation(1262, 15);
			// JavaScript.g:1262:15: ( catchClause ( finallyClause )? | finallyClause )
			int alt68=2;
			try { DebugEnterSubRule(68);
			try { DebugEnterDecision(68, false);
			int LA68_1 = input.LA(1);

			if ((LA68_1==CATCH))
			{
				alt68 = 1;
			}
			else if ((LA68_1==FINALLY))
			{
				alt68 = 2;
			}
			else
			{
				NoViableAltException nvae = new NoViableAltException("", 68, 0, input, 1);
				DebugRecognitionException(nvae);
				throw nvae;
			}
			} finally { DebugExitDecision(68); }
			switch (alt68)
			{
			case 1:
				DebugEnterAlt(1);
				// JavaScript.g:1262:17: catchClause ( finallyClause )?
				{
				DebugLocation(1262, 17);
				PushFollow(Follow._catchClause_in_tryStatement5559);
				catchClause254=catchClause();
				PopFollow();

				adaptor.AddChild(root_0, catchClause254.Tree);
				DebugLocation(1262, 29);
				// JavaScript.g:1262:29: ( finallyClause )?
				int alt67=2;
				try { DebugEnterSubRule(67);
				try { DebugEnterDecision(67, false);
				int LA67_1 = input.LA(1);

				if ((LA67_1==FINALLY))
				{
					alt67 = 1;
				}
				} finally { DebugExitDecision(67); }
				switch (alt67)
				{
				case 1:
					DebugEnterAlt(1);
					// JavaScript.g:1262:29: finallyClause
					{
					DebugLocation(1262, 29);
					PushFollow(Follow._finallyClause_in_tryStatement5561);
					finallyClause255=finallyClause();
					PopFollow();

					adaptor.AddChild(root_0, finallyClause255.Tree);

					}
					break;

				}
				} finally { DebugExitSubRule(67); }


				}
				break;
			case 2:
				DebugEnterAlt(2);
				// JavaScript.g:1262:46: finallyClause
				{
				DebugLocation(1262, 46);
				PushFollow(Follow._finallyClause_in_tryStatement5566);
				finallyClause256=finallyClause();
				PopFollow();

				adaptor.AddChild(root_0, finallyClause256.Tree);

				}
				break;

			}
			} finally { DebugExitSubRule(68); }


			}

			retval.Stop = (IToken)input.LT(-1);

			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);

		}
		 
		finally
		{
			TraceOut("tryStatement", 74);
			LeaveRule("tryStatement", 74);
			LeaveRule_tryStatement();
		}
		DebugLocation(1263, 1);
		} finally { DebugExitRule(GrammarFileName, "tryStatement"); }
		return retval;

	}
	// $ANTLR end "tryStatement"

	partial void EnterRule_catchClause();
	partial void LeaveRule_catchClause();
	// $ANTLR start "catchClause"
	// JavaScript.g:1265:1: catchClause : CATCH ^ LPAREN ! Identifier RPAREN ! block ;
	[GrammarRule("catchClause")]
	private AstParserRuleReturnScope<object, IToken> catchClause()
	{
		EnterRule_catchClause();
		EnterRule("catchClause", 75);
		TraceIn("catchClause", 75);
		AstParserRuleReturnScope<object, IToken> retval = new AstParserRuleReturnScope<object, IToken>();
		retval.Start = (IToken)input.LT(1);

		object root_0 = default(object);

		IToken CATCH257 = default(IToken);
		IToken LPAREN258 = default(IToken);
		IToken Identifier259 = default(IToken);
		IToken RPAREN260 = default(IToken);
		AstParserRuleReturnScope<object, IToken> block261 = default(AstParserRuleReturnScope<object, IToken>);

		object CATCH257_tree = default(object);
		object LPAREN258_tree = default(object);
		object Identifier259_tree = default(object);
		object RPAREN260_tree = default(object);
		try { DebugEnterRule(GrammarFileName, "catchClause");
		DebugLocation(1265, 1);
		try
		{
			// JavaScript.g:1266:2: ( CATCH ^ LPAREN ! Identifier RPAREN ! block )
			DebugEnterAlt(1);
			// JavaScript.g:1266:4: CATCH ^ LPAREN ! Identifier RPAREN ! block
			{
			root_0 = (object)adaptor.Nil();

			DebugLocation(1266, 9);
			CATCH257=(IToken)Match(input,CATCH,Follow._CATCH_in_catchClause5580); 
			CATCH257_tree = (object)adaptor.Create(CATCH257);
			root_0 = (object)adaptor.BecomeRoot(CATCH257_tree, root_0);
			DebugLocation(1266, 17);
			LPAREN258=(IToken)Match(input,LPAREN,Follow._LPAREN_in_catchClause5583); 
			DebugLocation(1266, 19);
			Identifier259=(IToken)Match(input,Identifier,Follow._Identifier_in_catchClause5586); 
			Identifier259_tree = (object)adaptor.Create(Identifier259);
			adaptor.AddChild(root_0, Identifier259_tree);
			DebugLocation(1266, 36);
			RPAREN260=(IToken)Match(input,RPAREN,Follow._RPAREN_in_catchClause5588); 
			DebugLocation(1266, 38);
			PushFollow(Follow._block_in_catchClause5591);
			block261=block();
			PopFollow();

			adaptor.AddChild(root_0, block261.Tree);

			}

			retval.Stop = (IToken)input.LT(-1);

			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);

		}
		 
		finally
		{
			TraceOut("catchClause", 75);
			LeaveRule("catchClause", 75);
			LeaveRule_catchClause();
		}
		DebugLocation(1267, 1);
		} finally { DebugExitRule(GrammarFileName, "catchClause"); }
		return retval;

	}
	// $ANTLR end "catchClause"

	partial void EnterRule_finallyClause();
	partial void LeaveRule_finallyClause();
	// $ANTLR start "finallyClause"
	// JavaScript.g:1269:1: finallyClause : FINALLY ^ block ;
	[GrammarRule("finallyClause")]
	private AstParserRuleReturnScope<object, IToken> finallyClause()
	{
		EnterRule_finallyClause();
		EnterRule("finallyClause", 76);
		TraceIn("finallyClause", 76);
		AstParserRuleReturnScope<object, IToken> retval = new AstParserRuleReturnScope<object, IToken>();
		retval.Start = (IToken)input.LT(1);

		object root_0 = default(object);

		IToken FINALLY262 = default(IToken);
		AstParserRuleReturnScope<object, IToken> block263 = default(AstParserRuleReturnScope<object, IToken>);

		object FINALLY262_tree = default(object);
		try { DebugEnterRule(GrammarFileName, "finallyClause");
		DebugLocation(1269, 1);
		try
		{
			// JavaScript.g:1270:2: ( FINALLY ^ block )
			DebugEnterAlt(1);
			// JavaScript.g:1270:4: FINALLY ^ block
			{
			root_0 = (object)adaptor.Nil();

			DebugLocation(1270, 11);
			FINALLY262=(IToken)Match(input,FINALLY,Follow._FINALLY_in_finallyClause5603); 
			FINALLY262_tree = (object)adaptor.Create(FINALLY262);
			root_0 = (object)adaptor.BecomeRoot(FINALLY262_tree, root_0);
			DebugLocation(1270, 13);
			PushFollow(Follow._block_in_finallyClause5606);
			block263=block();
			PopFollow();

			adaptor.AddChild(root_0, block263.Tree);

			}

			retval.Stop = (IToken)input.LT(-1);

			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);

		}
		 
		finally
		{
			TraceOut("finallyClause", 76);
			LeaveRule("finallyClause", 76);
			LeaveRule_finallyClause();
		}
		DebugLocation(1271, 1);
		} finally { DebugExitRule(GrammarFileName, "finallyClause"); }
		return retval;

	}
	// $ANTLR end "finallyClause"

	partial void EnterRule_functionDeclaration();
	partial void LeaveRule_functionDeclaration();
	// $ANTLR start "functionDeclaration"
	// JavaScript.g:1283:1: functionDeclaration : FUNCTION name= Identifier formalParameterList functionBody -> ^( FUNCTION $name formalParameterList functionBody ) ;
	[GrammarRule("functionDeclaration")]
	private AstParserRuleReturnScope<object, IToken> functionDeclaration()
	{
		EnterRule_functionDeclaration();
		EnterRule("functionDeclaration", 77);
		TraceIn("functionDeclaration", 77);
		AstParserRuleReturnScope<object, IToken> retval = new AstParserRuleReturnScope<object, IToken>();
		retval.Start = (IToken)input.LT(1);

		object root_0 = default(object);

		IToken name = default(IToken);
		IToken FUNCTION264 = default(IToken);
		AstParserRuleReturnScope<object, IToken> formalParameterList265 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> functionBody266 = default(AstParserRuleReturnScope<object, IToken>);

		object name_tree = default(object);
		object FUNCTION264_tree = default(object);
		RewriteRuleITokenStream stream_FUNCTION=new RewriteRuleITokenStream(adaptor,"token FUNCTION");
		RewriteRuleITokenStream stream_Identifier=new RewriteRuleITokenStream(adaptor,"token Identifier");
		RewriteRuleSubtreeStream stream_formalParameterList=new RewriteRuleSubtreeStream(adaptor,"rule formalParameterList");
		RewriteRuleSubtreeStream stream_functionBody=new RewriteRuleSubtreeStream(adaptor,"rule functionBody");
		try { DebugEnterRule(GrammarFileName, "functionDeclaration");
		DebugLocation(1283, 1);
		try
		{
			// JavaScript.g:1284:2: ( FUNCTION name= Identifier formalParameterList functionBody -> ^( FUNCTION $name formalParameterList functionBody ) )
			DebugEnterAlt(1);
			// JavaScript.g:1284:4: FUNCTION name= Identifier formalParameterList functionBody
			{
			DebugLocation(1284, 4);
			FUNCTION264=(IToken)Match(input,FUNCTION,Follow._FUNCTION_in_functionDeclaration5627);  
			stream_FUNCTION.Add(FUNCTION264);

			DebugLocation(1284, 17);
			name=(IToken)Match(input,Identifier,Follow._Identifier_in_functionDeclaration5631);  
			stream_Identifier.Add(name);

			DebugLocation(1284, 29);
			PushFollow(Follow._formalParameterList_in_functionDeclaration5633);
			formalParameterList265=formalParameterList();
			PopFollow();

			stream_formalParameterList.Add(formalParameterList265.Tree);
			DebugLocation(1284, 49);
			PushFollow(Follow._functionBody_in_functionDeclaration5635);
			functionBody266=functionBody();
			PopFollow();

			stream_functionBody.Add(functionBody266.Tree);


			{
			// AST REWRITE
			// elements: FUNCTION, name, formalParameterList, functionBody
			// token labels: name
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			retval.Tree = root_0;
			RewriteRuleITokenStream stream_name=new RewriteRuleITokenStream(adaptor,"token name",name);
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

			root_0 = (object)adaptor.Nil();
			// 1285:2: -> ^( FUNCTION $name formalParameterList functionBody )
			{
				DebugLocation(1285, 5);
				// JavaScript.g:1285:5: ^( FUNCTION $name formalParameterList functionBody )
				{
				object root_1 = (object)adaptor.Nil();
				DebugLocation(1285, 8);
				root_1 = (object)adaptor.BecomeRoot(stream_FUNCTION.NextNode(), root_1);

				DebugLocation(1285, 18);
				adaptor.AddChild(root_1, stream_name.NextNode());
				DebugLocation(1285, 23);
				adaptor.AddChild(root_1, stream_formalParameterList.NextTree());
				DebugLocation(1285, 43);
				adaptor.AddChild(root_1, stream_functionBody.NextTree());

				adaptor.AddChild(root_0, root_1);
				}

			}

			retval.Tree = root_0;
			}

			}

			retval.Stop = (IToken)input.LT(-1);

			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);

		}
		 
		finally
		{
			TraceOut("functionDeclaration", 77);
			LeaveRule("functionDeclaration", 77);
			LeaveRule_functionDeclaration();
		}
		DebugLocation(1286, 1);
		} finally { DebugExitRule(GrammarFileName, "functionDeclaration"); }
		return retval;

	}
	// $ANTLR end "functionDeclaration"

	partial void EnterRule_functionExpression();
	partial void LeaveRule_functionExpression();
	// $ANTLR start "functionExpression"
	// JavaScript.g:1288:1: functionExpression : FUNCTION (name= Identifier )? formalParameterList functionBody -> ^( FUNCTION ( $name)? formalParameterList functionBody ) ;
	[GrammarRule("functionExpression")]
	private AstParserRuleReturnScope<object, IToken> functionExpression()
	{
		EnterRule_functionExpression();
		EnterRule("functionExpression", 78);
		TraceIn("functionExpression", 78);
		AstParserRuleReturnScope<object, IToken> retval = new AstParserRuleReturnScope<object, IToken>();
		retval.Start = (IToken)input.LT(1);

		object root_0 = default(object);

		IToken name = default(IToken);
		IToken FUNCTION267 = default(IToken);
		AstParserRuleReturnScope<object, IToken> formalParameterList268 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> functionBody269 = default(AstParserRuleReturnScope<object, IToken>);

		object name_tree = default(object);
		object FUNCTION267_tree = default(object);
		RewriteRuleITokenStream stream_FUNCTION=new RewriteRuleITokenStream(adaptor,"token FUNCTION");
		RewriteRuleITokenStream stream_Identifier=new RewriteRuleITokenStream(adaptor,"token Identifier");
		RewriteRuleSubtreeStream stream_formalParameterList=new RewriteRuleSubtreeStream(adaptor,"rule formalParameterList");
		RewriteRuleSubtreeStream stream_functionBody=new RewriteRuleSubtreeStream(adaptor,"rule functionBody");
		try { DebugEnterRule(GrammarFileName, "functionExpression");
		DebugLocation(1288, 1);
		try
		{
			// JavaScript.g:1289:2: ( FUNCTION (name= Identifier )? formalParameterList functionBody -> ^( FUNCTION ( $name)? formalParameterList functionBody ) )
			DebugEnterAlt(1);
			// JavaScript.g:1289:4: FUNCTION (name= Identifier )? formalParameterList functionBody
			{
			DebugLocation(1289, 4);
			FUNCTION267=(IToken)Match(input,FUNCTION,Follow._FUNCTION_in_functionExpression5662);  
			stream_FUNCTION.Add(FUNCTION267);

			DebugLocation(1289, 17);
			// JavaScript.g:1289:17: (name= Identifier )?
			int alt69=2;
			try { DebugEnterSubRule(69);
			try { DebugEnterDecision(69, false);
			int LA69_1 = input.LA(1);

			if ((LA69_1==Identifier))
			{
				alt69 = 1;
			}
			} finally { DebugExitDecision(69); }
			switch (alt69)
			{
			case 1:
				DebugEnterAlt(1);
				// JavaScript.g:1289:17: name= Identifier
				{
				DebugLocation(1289, 17);
				name=(IToken)Match(input,Identifier,Follow._Identifier_in_functionExpression5666);  
				stream_Identifier.Add(name);


				}
				break;

			}
			} finally { DebugExitSubRule(69); }

			DebugLocation(1289, 30);
			PushFollow(Follow._formalParameterList_in_functionExpression5669);
			formalParameterList268=formalParameterList();
			PopFollow();

			stream_formalParameterList.Add(formalParameterList268.Tree);
			DebugLocation(1289, 50);
			PushFollow(Follow._functionBody_in_functionExpression5671);
			functionBody269=functionBody();
			PopFollow();

			stream_functionBody.Add(functionBody269.Tree);


			{
			// AST REWRITE
			// elements: FUNCTION, name, formalParameterList, functionBody
			// token labels: name
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			retval.Tree = root_0;
			RewriteRuleITokenStream stream_name=new RewriteRuleITokenStream(adaptor,"token name",name);
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

			root_0 = (object)adaptor.Nil();
			// 1290:2: -> ^( FUNCTION ( $name)? formalParameterList functionBody )
			{
				DebugLocation(1290, 5);
				// JavaScript.g:1290:5: ^( FUNCTION ( $name)? formalParameterList functionBody )
				{
				object root_1 = (object)adaptor.Nil();
				DebugLocation(1290, 8);
				root_1 = (object)adaptor.BecomeRoot(stream_FUNCTION.NextNode(), root_1);

				DebugLocation(1290, 18);
				// JavaScript.g:1290:18: ( $name)?
				if (stream_name.HasNext)
				{
					DebugLocation(1290, 18);
					adaptor.AddChild(root_1, stream_name.NextNode());

				}
				stream_name.Reset();
				DebugLocation(1290, 24);
				adaptor.AddChild(root_1, stream_formalParameterList.NextTree());
				DebugLocation(1290, 44);
				adaptor.AddChild(root_1, stream_functionBody.NextTree());

				adaptor.AddChild(root_0, root_1);
				}

			}

			retval.Tree = root_0;
			}

			}

			retval.Stop = (IToken)input.LT(-1);

			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);

		}
		 
		finally
		{
			TraceOut("functionExpression", 78);
			LeaveRule("functionExpression", 78);
			LeaveRule_functionExpression();
		}
		DebugLocation(1291, 1);
		} finally { DebugExitRule(GrammarFileName, "functionExpression"); }
		return retval;

	}
	// $ANTLR end "functionExpression"

	partial void EnterRule_formalParameterList();
	partial void LeaveRule_formalParameterList();
	// $ANTLR start "formalParameterList"
	// JavaScript.g:1293:1: formalParameterList : LPAREN ( Identifier ( COMMA Identifier )* )? RPAREN -> ^( ARGS ( Identifier )* ) ;
	[GrammarRule("formalParameterList")]
	private AstParserRuleReturnScope<object, IToken> formalParameterList()
	{
		EnterRule_formalParameterList();
		EnterRule("formalParameterList", 79);
		TraceIn("formalParameterList", 79);
		AstParserRuleReturnScope<object, IToken> retval = new AstParserRuleReturnScope<object, IToken>();
		retval.Start = (IToken)input.LT(1);

		object root_0 = default(object);

		IToken LPAREN270 = default(IToken);
		IToken Identifier271 = default(IToken);
		IToken COMMA272 = default(IToken);
		IToken Identifier273 = default(IToken);
		IToken RPAREN274 = default(IToken);

		object LPAREN270_tree = default(object);
		object Identifier271_tree = default(object);
		object COMMA272_tree = default(object);
		object Identifier273_tree = default(object);
		object RPAREN274_tree = default(object);
		RewriteRuleITokenStream stream_LPAREN=new RewriteRuleITokenStream(adaptor,"token LPAREN");
		RewriteRuleITokenStream stream_Identifier=new RewriteRuleITokenStream(adaptor,"token Identifier");
		RewriteRuleITokenStream stream_COMMA=new RewriteRuleITokenStream(adaptor,"token COMMA");
		RewriteRuleITokenStream stream_RPAREN=new RewriteRuleITokenStream(adaptor,"token RPAREN");
		try { DebugEnterRule(GrammarFileName, "formalParameterList");
		DebugLocation(1293, 1);
		try
		{
			// JavaScript.g:1294:2: ( LPAREN ( Identifier ( COMMA Identifier )* )? RPAREN -> ^( ARGS ( Identifier )* ) )
			DebugEnterAlt(1);
			// JavaScript.g:1294:4: LPAREN ( Identifier ( COMMA Identifier )* )? RPAREN
			{
			DebugLocation(1294, 4);
			LPAREN270=(IToken)Match(input,LPAREN,Follow._LPAREN_in_formalParameterList5699);  
			stream_LPAREN.Add(LPAREN270);

			DebugLocation(1294, 11);
			// JavaScript.g:1294:11: ( Identifier ( COMMA Identifier )* )?
			int alt71=2;
			try { DebugEnterSubRule(71);
			try { DebugEnterDecision(71, false);
			int LA71_1 = input.LA(1);

			if ((LA71_1==Identifier))
			{
				alt71 = 1;
			}
			} finally { DebugExitDecision(71); }
			switch (alt71)
			{
			case 1:
				DebugEnterAlt(1);
				// JavaScript.g:1294:13: Identifier ( COMMA Identifier )*
				{
				DebugLocation(1294, 13);
				Identifier271=(IToken)Match(input,Identifier,Follow._Identifier_in_formalParameterList5703);  
				stream_Identifier.Add(Identifier271);

				DebugLocation(1294, 24);
				// JavaScript.g:1294:24: ( COMMA Identifier )*
				try { DebugEnterSubRule(70);
				while (true)
				{
					int alt70=2;
					try { DebugEnterDecision(70, false);
					int LA70_1 = input.LA(1);

					if ((LA70_1==COMMA))
					{
						alt70 = 1;
					}


					} finally { DebugExitDecision(70); }
					switch ( alt70 )
					{
					case 1:
						DebugEnterAlt(1);
						// JavaScript.g:1294:26: COMMA Identifier
						{
						DebugLocation(1294, 26);
						COMMA272=(IToken)Match(input,COMMA,Follow._COMMA_in_formalParameterList5707);  
						stream_COMMA.Add(COMMA272);

						DebugLocation(1294, 32);
						Identifier273=(IToken)Match(input,Identifier,Follow._Identifier_in_formalParameterList5709);  
						stream_Identifier.Add(Identifier273);


						}
						break;

					default:
						goto loop70;
					}
				}

				loop70:
					;

				} finally { DebugExitSubRule(70); }


				}
				break;

			}
			} finally { DebugExitSubRule(71); }

			DebugLocation(1294, 49);
			RPAREN274=(IToken)Match(input,RPAREN,Follow._RPAREN_in_formalParameterList5717);  
			stream_RPAREN.Add(RPAREN274);



			{
			// AST REWRITE
			// elements: Identifier
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			retval.Tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

			root_0 = (object)adaptor.Nil();
			// 1295:2: -> ^( ARGS ( Identifier )* )
			{
				DebugLocation(1295, 5);
				// JavaScript.g:1295:5: ^( ARGS ( Identifier )* )
				{
				object root_1 = (object)adaptor.Nil();
				DebugLocation(1295, 8);
				root_1 = (object)adaptor.BecomeRoot((object)adaptor.Create(ARGS, "ARGS"), root_1);

				DebugLocation(1295, 13);
				// JavaScript.g:1295:13: ( Identifier )*
				while ( stream_Identifier.HasNext )
				{
					DebugLocation(1295, 13);
					adaptor.AddChild(root_1, stream_Identifier.NextNode());

				}
				stream_Identifier.Reset();

				adaptor.AddChild(root_0, root_1);
				}

			}

			retval.Tree = root_0;
			}

			}

			retval.Stop = (IToken)input.LT(-1);

			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);

		}
		 
		finally
		{
			TraceOut("formalParameterList", 79);
			LeaveRule("formalParameterList", 79);
			LeaveRule_formalParameterList();
		}
		DebugLocation(1296, 1);
		} finally { DebugExitRule(GrammarFileName, "formalParameterList"); }
		return retval;

	}
	// $ANTLR end "formalParameterList"

	partial void EnterRule_functionBody();
	partial void LeaveRule_functionBody();
	// $ANTLR start "functionBody"
	// JavaScript.g:1298:1: functionBody : lb= LBRACE ( sourceElement )* RBRACE -> ^( BLOCK[$lb, \"BLOCK\"] ( sourceElement )* ) ;
	[GrammarRule("functionBody")]
	private AstParserRuleReturnScope<object, IToken> functionBody()
	{
		EnterRule_functionBody();
		EnterRule("functionBody", 80);
		TraceIn("functionBody", 80);
		AstParserRuleReturnScope<object, IToken> retval = new AstParserRuleReturnScope<object, IToken>();
		retval.Start = (IToken)input.LT(1);

		object root_0 = default(object);

		IToken lb = default(IToken);
		IToken RBRACE276 = default(IToken);
		AstParserRuleReturnScope<object, IToken> sourceElement275 = default(AstParserRuleReturnScope<object, IToken>);

		object lb_tree = default(object);
		object RBRACE276_tree = default(object);
		RewriteRuleITokenStream stream_LBRACE=new RewriteRuleITokenStream(adaptor,"token LBRACE");
		RewriteRuleITokenStream stream_RBRACE=new RewriteRuleITokenStream(adaptor,"token RBRACE");
		RewriteRuleSubtreeStream stream_sourceElement=new RewriteRuleSubtreeStream(adaptor,"rule sourceElement");
		try { DebugEnterRule(GrammarFileName, "functionBody");
		DebugLocation(1298, 1);
		try
		{
			// JavaScript.g:1299:2: (lb= LBRACE ( sourceElement )* RBRACE -> ^( BLOCK[$lb, \"BLOCK\"] ( sourceElement )* ) )
			DebugEnterAlt(1);
			// JavaScript.g:1299:4: lb= LBRACE ( sourceElement )* RBRACE
			{
			DebugLocation(1299, 6);
			lb=(IToken)Match(input,LBRACE,Follow._LBRACE_in_functionBody5742);  
			stream_LBRACE.Add(lb);

			DebugLocation(1299, 14);
			// JavaScript.g:1299:14: ( sourceElement )*
			try { DebugEnterSubRule(72);
			while (true)
			{
				int alt72=2;
				try { DebugEnterDecision(72, false);
				int LA72_1 = input.LA(1);

				if ((LA72_1==ADD||LA72_1==BREAK||LA72_1==CONTINUE||LA72_1==DEC||LA72_1==DELETE||LA72_1==DO||LA72_1==DecimalLiteral||LA72_1==FALSE||LA72_1==FOR||LA72_1==FUNCTION||(LA72_1>=HexIntegerLiteral && LA72_1<=IF)||LA72_1==INC||LA72_1==INV||LA72_1==Identifier||(LA72_1>=LBRACE && LA72_1<=LBRACK)||LA72_1==LPAREN||(LA72_1>=NEW && LA72_1<=NOT)||LA72_1==NULL||LA72_1==OctalIntegerLiteral||LA72_1==RETURN||LA72_1==RegularExpressionLiteral||LA72_1==SEMIC||LA72_1==SUB||LA72_1==SWITCH||LA72_1==StringLiteral||(LA72_1>=THIS && LA72_1<=THROW)||(LA72_1>=TRUE && LA72_1<=TYPEOF)||(LA72_1>=VAR && LA72_1<=VOID)||(LA72_1>=WHILE && LA72_1<=WITH)))
				{
					alt72 = 1;
				}


				} finally { DebugExitDecision(72); }
				switch ( alt72 )
				{
				case 1:
					DebugEnterAlt(1);
					// JavaScript.g:1299:14: sourceElement
					{
					DebugLocation(1299, 14);
					PushFollow(Follow._sourceElement_in_functionBody5744);
					sourceElement275=sourceElement();
					PopFollow();

					stream_sourceElement.Add(sourceElement275.Tree);

					}
					break;

				default:
					goto loop72;
				}
			}

			loop72:
				;

			} finally { DebugExitSubRule(72); }

			DebugLocation(1299, 29);
			RBRACE276=(IToken)Match(input,RBRACE,Follow._RBRACE_in_functionBody5747);  
			stream_RBRACE.Add(RBRACE276);



			{
			// AST REWRITE
			// elements: sourceElement
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			retval.Tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

			root_0 = (object)adaptor.Nil();
			// 1300:2: -> ^( BLOCK[$lb, \"BLOCK\"] ( sourceElement )* )
			{
				DebugLocation(1300, 5);
				// JavaScript.g:1300:5: ^( BLOCK[$lb, \"BLOCK\"] ( sourceElement )* )
				{
				object root_1 = (object)adaptor.Nil();
				DebugLocation(1300, 8);
				root_1 = (object)adaptor.BecomeRoot((object)adaptor.Create(BLOCK, lb, "BLOCK"), root_1);

				DebugLocation(1300, 28);
				// JavaScript.g:1300:28: ( sourceElement )*
				while ( stream_sourceElement.HasNext )
				{
					DebugLocation(1300, 28);
					adaptor.AddChild(root_1, stream_sourceElement.NextTree());

				}
				stream_sourceElement.Reset();

				adaptor.AddChild(root_0, root_1);
				}

			}

			retval.Tree = root_0;
			}

			}

			retval.Stop = (IToken)input.LT(-1);

			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);

		}
		 
		finally
		{
			TraceOut("functionBody", 80);
			LeaveRule("functionBody", 80);
			LeaveRule_functionBody();
		}
		DebugLocation(1301, 1);
		} finally { DebugExitRule(GrammarFileName, "functionBody"); }
		return retval;

	}
	// $ANTLR end "functionBody"

	partial void EnterRule_program();
	partial void LeaveRule_program();
	// $ANTLR start "program"
	// JavaScript.g:1307:8: public program : ( sourceElement )* ;
	[GrammarRule("program")]
	public AstParserRuleReturnScope<object, IToken> program()
	{
		EnterRule_program();
		EnterRule("program", 81);
		TraceIn("program", 81);
		AstParserRuleReturnScope<object, IToken> retval = new AstParserRuleReturnScope<object, IToken>();
		retval.Start = (IToken)input.LT(1);

		object root_0 = default(object);

		AstParserRuleReturnScope<object, IToken> sourceElement277 = default(AstParserRuleReturnScope<object, IToken>);

		try { DebugEnterRule(GrammarFileName, "program");
		DebugLocation(1307, 1);
		try
		{
			// JavaScript.g:1308:2: ( ( sourceElement )* )
			DebugEnterAlt(1);
			// JavaScript.g:1308:4: ( sourceElement )*
			{
			root_0 = (object)adaptor.Nil();

			DebugLocation(1308, 4);
			// JavaScript.g:1308:4: ( sourceElement )*
			try { DebugEnterSubRule(73);
			while (true)
			{
				int alt73=2;
				try { DebugEnterDecision(73, false);
				int LA73_1 = input.LA(1);

				if ((LA73_1==ADD||LA73_1==BREAK||LA73_1==CONTINUE||LA73_1==DEC||LA73_1==DELETE||LA73_1==DO||LA73_1==DecimalLiteral||LA73_1==FALSE||LA73_1==FOR||LA73_1==FUNCTION||(LA73_1>=HexIntegerLiteral && LA73_1<=IF)||LA73_1==INC||LA73_1==INV||LA73_1==Identifier||(LA73_1>=LBRACE && LA73_1<=LBRACK)||LA73_1==LPAREN||(LA73_1>=NEW && LA73_1<=NOT)||LA73_1==NULL||LA73_1==OctalIntegerLiteral||LA73_1==RETURN||LA73_1==RegularExpressionLiteral||LA73_1==SEMIC||LA73_1==SUB||LA73_1==SWITCH||LA73_1==StringLiteral||(LA73_1>=THIS && LA73_1<=THROW)||(LA73_1>=TRUE && LA73_1<=TYPEOF)||(LA73_1>=VAR && LA73_1<=VOID)||(LA73_1>=WHILE && LA73_1<=WITH)))
				{
					alt73 = 1;
				}


				} finally { DebugExitDecision(73); }
				switch ( alt73 )
				{
				case 1:
					DebugEnterAlt(1);
					// JavaScript.g:1308:4: sourceElement
					{
					DebugLocation(1308, 4);
					PushFollow(Follow._sourceElement_in_program5778);
					sourceElement277=sourceElement();
					PopFollow();

					adaptor.AddChild(root_0, sourceElement277.Tree);

					}
					break;

				default:
					goto loop73;
				}
			}

			loop73:
				;

			} finally { DebugExitSubRule(73); }


			}

			retval.Stop = (IToken)input.LT(-1);

			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);

		}
		 
		finally
		{
			TraceOut("program", 81);
			LeaveRule("program", 81);
			LeaveRule_program();
		}
		DebugLocation(1309, 1);
		} finally { DebugExitRule(GrammarFileName, "program"); }
		return retval;

	}
	// $ANTLR end "program"

	partial void EnterRule_sourceElement();
	partial void LeaveRule_sourceElement();
	// $ANTLR start "sourceElement"
	// JavaScript.g:1316:1: sourceElement options {k=1; } : ({...}? functionDeclaration | statement );
	[GrammarRule("sourceElement")]
	private AstParserRuleReturnScope<object, IToken> sourceElement()
	{
		EnterRule_sourceElement();
		EnterRule("sourceElement", 82);
		TraceIn("sourceElement", 82);
		AstParserRuleReturnScope<object, IToken> retval = new AstParserRuleReturnScope<object, IToken>();
		retval.Start = (IToken)input.LT(1);

		object root_0 = default(object);

		AstParserRuleReturnScope<object, IToken> functionDeclaration278 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> statement279 = default(AstParserRuleReturnScope<object, IToken>);

		try { DebugEnterRule(GrammarFileName, "sourceElement");
		DebugLocation(1316, 1);
		try
		{
			// JavaScript.g:1321:2: ({...}? functionDeclaration | statement )
			int alt74=2;
			try { DebugEnterDecision(74, false);
			int LA74_1 = input.LA(1);

			if ((LA74_1==FUNCTION))
			{
				int LA74_2 = input.LA(2);

				if ((( input.LA(1) == FUNCTION )))
				{
					alt74 = 1;
				}
				else if ((true))
				{
					alt74 = 2;
				}
				else
				{
					NoViableAltException nvae = new NoViableAltException("", 74, 1, input, 2);
					DebugRecognitionException(nvae);
					throw nvae;
				}
			}
			else if ((LA74_1==ADD||LA74_1==BREAK||LA74_1==CONTINUE||LA74_1==DEC||LA74_1==DELETE||LA74_1==DO||LA74_1==DecimalLiteral||LA74_1==FALSE||LA74_1==FOR||(LA74_1>=HexIntegerLiteral && LA74_1<=IF)||LA74_1==INC||LA74_1==INV||LA74_1==Identifier||(LA74_1>=LBRACE && LA74_1<=LBRACK)||LA74_1==LPAREN||(LA74_1>=NEW && LA74_1<=NOT)||LA74_1==NULL||LA74_1==OctalIntegerLiteral||LA74_1==RETURN||LA74_1==RegularExpressionLiteral||LA74_1==SEMIC||LA74_1==SUB||LA74_1==SWITCH||LA74_1==StringLiteral||(LA74_1>=THIS && LA74_1<=THROW)||(LA74_1>=TRUE && LA74_1<=TYPEOF)||(LA74_1>=VAR && LA74_1<=VOID)||(LA74_1>=WHILE && LA74_1<=WITH)))
			{
				alt74 = 2;
			}
			else
			{
				NoViableAltException nvae = new NoViableAltException("", 74, 0, input, 1);
				DebugRecognitionException(nvae);
				throw nvae;
			}
			} finally { DebugExitDecision(74); }
			switch (alt74)
			{
			case 1:
				DebugEnterAlt(1);
				// JavaScript.g:1321:4: {...}? functionDeclaration
				{
				root_0 = (object)adaptor.Nil();

				DebugLocation(1321, 4);
				if (!(( input.LA(1) == FUNCTION )))
				{
					throw new FailedPredicateException(input, "sourceElement", " input.LA(1) == FUNCTION ");
				}
				DebugLocation(1321, 33);
				PushFollow(Follow._functionDeclaration_in_sourceElement5807);
				functionDeclaration278=functionDeclaration();
				PopFollow();

				adaptor.AddChild(root_0, functionDeclaration278.Tree);

				}
				break;
			case 2:
				DebugEnterAlt(2);
				// JavaScript.g:1322:4: statement
				{
				root_0 = (object)adaptor.Nil();

				DebugLocation(1322, 4);
				PushFollow(Follow._statement_in_sourceElement5812);
				statement279=statement();
				PopFollow();

				adaptor.AddChild(root_0, statement279.Tree);

				}
				break;

			}
			retval.Stop = (IToken)input.LT(-1);

			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);

		}
		 
		finally
		{
			TraceOut("sourceElement", 82);
			LeaveRule("sourceElement", 82);
			LeaveRule_sourceElement();
		}
		DebugLocation(1323, 1);
		} finally { DebugExitRule(GrammarFileName, "sourceElement"); }
		return retval;

	}
	// $ANTLR end "sourceElement"
	#endregion Rules


	#region Follow sets
	private static class Follow
	{
		public static readonly BitSet _reservedWord_in_token1759 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _Identifier_in_token1764 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _punctuator_in_token1769 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _numericLiteral_in_token1774 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _StringLiteral_in_token1779 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _keyword_in_reservedWord1792 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _futureReservedWord_in_reservedWord1797 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _NULL_in_reservedWord1802 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _booleanLiteral_in_reservedWord1807 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _NULL_in_literal2488 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _booleanLiteral_in_literal2493 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _numericLiteral_in_literal2498 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _StringLiteral_in_literal2503 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _RegularExpressionLiteral_in_literal2508 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _THIS_in_primaryExpression3121 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _Identifier_in_primaryExpression3126 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _literal_in_primaryExpression3131 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _arrayLiteral_in_primaryExpression3136 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _objectLiteral_in_primaryExpression3141 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _LPAREN_in_primaryExpression3148 = new BitSet(new ulong[]{0x4040100A00000020UL,0x416000460A210UL,0x451410008UL});
		public static readonly BitSet _expression_in_primaryExpression3150 = new BitSet(new ulong[]{0x0UL,0x0UL,0x1UL});
		public static readonly BitSet _RPAREN_in_primaryExpression3152 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _LBRACK_in_arrayLiteral3176 = new BitSet(new ulong[]{0x4040100A08000020UL,0x400416000460A210UL,0x451410008UL});
		public static readonly BitSet _arrayItem_in_arrayLiteral3180 = new BitSet(new ulong[]{0x8000000UL,0x4000000000000000UL});
		public static readonly BitSet _COMMA_in_arrayLiteral3184 = new BitSet(new ulong[]{0x4040100A08000020UL,0x400416000460A210UL,0x451410008UL});
		public static readonly BitSet _arrayItem_in_arrayLiteral3186 = new BitSet(new ulong[]{0x8000000UL,0x4000000000000000UL});
		public static readonly BitSet _RBRACK_in_arrayLiteral3194 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _assignmentExpression_in_arrayItem3222 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _LBRACE_in_objectLiteral3254 = new BitSet(new ulong[]{0x100000000000UL,0x2004000000008010UL,0x400000UL});
		public static readonly BitSet _nameValuePair_in_objectLiteral3258 = new BitSet(new ulong[]{0x8000000UL,0x2000000000000000UL});
		public static readonly BitSet _COMMA_in_objectLiteral3262 = new BitSet(new ulong[]{0x100000000000UL,0x4000000008010UL,0x400000UL});
		public static readonly BitSet _nameValuePair_in_objectLiteral3264 = new BitSet(new ulong[]{0x8000000UL,0x2000000000000000UL});
		public static readonly BitSet _RBRACE_in_objectLiteral3272 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _propertyName_in_nameValuePair3297 = new BitSet(new ulong[]{0x4000000UL});
		public static readonly BitSet _COLON_in_nameValuePair3299 = new BitSet(new ulong[]{0x4040100A00000020UL,0x416000460A210UL,0x451410008UL});
		public static readonly BitSet _assignmentExpression_in_nameValuePair3301 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _Identifier_in_propertyName3325 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _StringLiteral_in_propertyName3330 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _numericLiteral_in_propertyName3335 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _primaryExpression_in_memberExpression3353 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _functionExpression_in_memberExpression3358 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _newExpression_in_memberExpression3363 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _NEW_in_newExpression3374 = new BitSet(new ulong[]{0x40100000000000UL,0x4100004608010UL,0x11400008UL});
		public static readonly BitSet _primaryExpression_in_newExpression3377 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _LPAREN_in_arguments3390 = new BitSet(new ulong[]{0x4040100A00000020UL,0x416000460A210UL,0x451410009UL});
		public static readonly BitSet _assignmentExpression_in_arguments3394 = new BitSet(new ulong[]{0x8000000UL,0x0UL,0x1UL});
		public static readonly BitSet _COMMA_in_arguments3398 = new BitSet(new ulong[]{0x4040100A00000020UL,0x416000460A210UL,0x451410008UL});
		public static readonly BitSet _assignmentExpression_in_arguments3400 = new BitSet(new ulong[]{0x8000000UL,0x0UL,0x1UL});
		public static readonly BitSet _RPAREN_in_arguments3408 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _memberExpression_in_leftHandSideExpression3437 = new BitSet(new ulong[]{0x8000000002UL,0x4400000UL});
		public static readonly BitSet _arguments_in_leftHandSideExpression3453 = new BitSet(new ulong[]{0x8000000002UL,0x4400000UL});
		public static readonly BitSet _LBRACK_in_leftHandSideExpression3474 = new BitSet(new ulong[]{0x4040100A00000020UL,0x416000460A210UL,0x451410008UL});
		public static readonly BitSet _expression_in_leftHandSideExpression3476 = new BitSet(new ulong[]{0x0UL,0x4000000000000000UL});
		public static readonly BitSet _RBRACK_in_leftHandSideExpression3478 = new BitSet(new ulong[]{0x8000000002UL,0x4400000UL});
		public static readonly BitSet _DOT_in_leftHandSideExpression3497 = new BitSet(new ulong[]{0x0UL,0x8000UL});
		public static readonly BitSet _Identifier_in_leftHandSideExpression3499 = new BitSet(new ulong[]{0x8000000002UL,0x4400000UL});
		public static readonly BitSet _leftHandSideExpression_in_postfixExpression3534 = new BitSet(new ulong[]{0x200000002UL,0x200UL});
		public static readonly BitSet _postfixOperator_in_postfixExpression3540 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _INC_in_postfixOperator3558 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _DEC_in_postfixOperator3567 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _postfixExpression_in_unaryExpression3584 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _unaryOperator_in_unaryExpression3589 = new BitSet(new ulong[]{0x4040100A00000020UL,0x416000460A210UL,0x451410008UL});
		public static readonly BitSet _unaryExpression_in_unaryExpression3592 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _DELETE_in_unaryOperator3604 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _VOID_in_unaryOperator3609 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _TYPEOF_in_unaryOperator3614 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _INC_in_unaryOperator3619 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _DEC_in_unaryOperator3624 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _ADD_in_unaryOperator3631 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _SUB_in_unaryOperator3640 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _INV_in_unaryOperator3647 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _NOT_in_unaryOperator3652 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _unaryExpression_in_multiplicativeExpression3667 = new BitSet(new ulong[]{0x1000000002UL,0x280000000UL});
		public static readonly BitSet _set_in_multiplicativeExpression3671 = new BitSet(new ulong[]{0x4040100A00000020UL,0x416000460A210UL,0x451410008UL});
		public static readonly BitSet _unaryExpression_in_multiplicativeExpression3686 = new BitSet(new ulong[]{0x1000000002UL,0x280000000UL});
		public static readonly BitSet _multiplicativeExpression_in_additiveExpression3704 = new BitSet(new ulong[]{0x22UL,0x0UL,0x10000UL});
		public static readonly BitSet _set_in_additiveExpression3708 = new BitSet(new ulong[]{0x4040100A00000020UL,0x416000460A210UL,0x451410008UL});
		public static readonly BitSet _multiplicativeExpression_in_additiveExpression3719 = new BitSet(new ulong[]{0x22UL,0x0UL,0x10000UL});
		public static readonly BitSet _additiveExpression_in_shiftExpression3738 = new BitSet(new ulong[]{0x2UL,0x0UL,0xA40UL});
		public static readonly BitSet _set_in_shiftExpression3742 = new BitSet(new ulong[]{0x4040100A00000020UL,0x416000460A210UL,0x451410008UL});
		public static readonly BitSet _additiveExpression_in_shiftExpression3757 = new BitSet(new ulong[]{0x2UL,0x0UL,0xA40UL});
		public static readonly BitSet _shiftExpression_in_relationalExpression3776 = new BitSet(new ulong[]{0x2UL,0x30000503UL});
		public static readonly BitSet _set_in_relationalExpression3780 = new BitSet(new ulong[]{0x4040100A00000020UL,0x416000460A210UL,0x451410008UL});
		public static readonly BitSet _shiftExpression_in_relationalExpression3807 = new BitSet(new ulong[]{0x2UL,0x30000503UL});
		public static readonly BitSet _shiftExpression_in_relationalExpressionNoIn3821 = new BitSet(new ulong[]{0x2UL,0x30000403UL});
		public static readonly BitSet _set_in_relationalExpressionNoIn3825 = new BitSet(new ulong[]{0x4040100A00000020UL,0x416000460A210UL,0x451410008UL});
		public static readonly BitSet _shiftExpression_in_relationalExpressionNoIn3848 = new BitSet(new ulong[]{0x2UL,0x30000403UL});
		public static readonly BitSet _relationalExpression_in_equalityExpression3867 = new BitSet(new ulong[]{0x1000000000002UL,0x90000000000UL,0x10UL});
		public static readonly BitSet _set_in_equalityExpression3871 = new BitSet(new ulong[]{0x4040100A00000020UL,0x416000460A210UL,0x451410008UL});
		public static readonly BitSet _relationalExpression_in_equalityExpression3890 = new BitSet(new ulong[]{0x1000000000002UL,0x90000000000UL,0x10UL});
		public static readonly BitSet _relationalExpressionNoIn_in_equalityExpressionNoIn3904 = new BitSet(new ulong[]{0x1000000000002UL,0x90000000000UL,0x10UL});
		public static readonly BitSet _set_in_equalityExpressionNoIn3908 = new BitSet(new ulong[]{0x4040100A00000020UL,0x416000460A210UL,0x451410008UL});
		public static readonly BitSet _relationalExpressionNoIn_in_equalityExpressionNoIn3927 = new BitSet(new ulong[]{0x1000000000002UL,0x90000000000UL,0x10UL});
		public static readonly BitSet _equalityExpression_in_bitwiseANDExpression3947 = new BitSet(new ulong[]{0x82UL});
		public static readonly BitSet _AND_in_bitwiseANDExpression3951 = new BitSet(new ulong[]{0x4040100A00000020UL,0x416000460A210UL,0x451410008UL});
		public static readonly BitSet _equalityExpression_in_bitwiseANDExpression3954 = new BitSet(new ulong[]{0x82UL});
		public static readonly BitSet _equalityExpressionNoIn_in_bitwiseANDExpressionNoIn3968 = new BitSet(new ulong[]{0x82UL});
		public static readonly BitSet _AND_in_bitwiseANDExpressionNoIn3972 = new BitSet(new ulong[]{0x4040100A00000020UL,0x416000460A210UL,0x451410008UL});
		public static readonly BitSet _equalityExpressionNoIn_in_bitwiseANDExpressionNoIn3975 = new BitSet(new ulong[]{0x82UL});
		public static readonly BitSet _bitwiseANDExpression_in_bitwiseXORExpression3991 = new BitSet(new ulong[]{0x2UL,0x0UL,0x10000000000UL});
		public static readonly BitSet _XOR_in_bitwiseXORExpression3995 = new BitSet(new ulong[]{0x4040100A00000020UL,0x416000460A210UL,0x451410008UL});
		public static readonly BitSet _bitwiseANDExpression_in_bitwiseXORExpression3998 = new BitSet(new ulong[]{0x2UL,0x0UL,0x10000000000UL});
		public static readonly BitSet _bitwiseANDExpressionNoIn_in_bitwiseXORExpressionNoIn4014 = new BitSet(new ulong[]{0x2UL,0x0UL,0x10000000000UL});
		public static readonly BitSet _XOR_in_bitwiseXORExpressionNoIn4018 = new BitSet(new ulong[]{0x4040100A00000020UL,0x416000460A210UL,0x451410008UL});
		public static readonly BitSet _bitwiseANDExpressionNoIn_in_bitwiseXORExpressionNoIn4021 = new BitSet(new ulong[]{0x2UL,0x0UL,0x10000000000UL});
		public static readonly BitSet _bitwiseXORExpression_in_bitwiseORExpression4036 = new BitSet(new ulong[]{0x2UL,0x400000000000UL});
		public static readonly BitSet _OR_in_bitwiseORExpression4040 = new BitSet(new ulong[]{0x4040100A00000020UL,0x416000460A210UL,0x451410008UL});
		public static readonly BitSet _bitwiseXORExpression_in_bitwiseORExpression4043 = new BitSet(new ulong[]{0x2UL,0x400000000000UL});
		public static readonly BitSet _bitwiseXORExpressionNoIn_in_bitwiseORExpressionNoIn4058 = new BitSet(new ulong[]{0x2UL,0x400000000000UL});
		public static readonly BitSet _OR_in_bitwiseORExpressionNoIn4062 = new BitSet(new ulong[]{0x4040100A00000020UL,0x416000460A210UL,0x451410008UL});
		public static readonly BitSet _bitwiseXORExpressionNoIn_in_bitwiseORExpressionNoIn4065 = new BitSet(new ulong[]{0x2UL,0x400000000000UL});
		public static readonly BitSet _bitwiseORExpression_in_logicalANDExpression4084 = new BitSet(new ulong[]{0x2UL,0x100000UL});
		public static readonly BitSet _LAND_in_logicalANDExpression4088 = new BitSet(new ulong[]{0x4040100A00000020UL,0x416000460A210UL,0x451410008UL});
		public static readonly BitSet _bitwiseORExpression_in_logicalANDExpression4091 = new BitSet(new ulong[]{0x2UL,0x100000UL});
		public static readonly BitSet _bitwiseORExpressionNoIn_in_logicalANDExpressionNoIn4105 = new BitSet(new ulong[]{0x2UL,0x100000UL});
		public static readonly BitSet _LAND_in_logicalANDExpressionNoIn4109 = new BitSet(new ulong[]{0x4040100A00000020UL,0x416000460A210UL,0x451410008UL});
		public static readonly BitSet _bitwiseORExpressionNoIn_in_logicalANDExpressionNoIn4112 = new BitSet(new ulong[]{0x2UL,0x100000UL});
		public static readonly BitSet _logicalANDExpression_in_logicalORExpression4127 = new BitSet(new ulong[]{0x2UL,0x2000000UL});
		public static readonly BitSet _LOR_in_logicalORExpression4131 = new BitSet(new ulong[]{0x4040100A00000020UL,0x416000460A210UL,0x451410008UL});
		public static readonly BitSet _logicalANDExpression_in_logicalORExpression4134 = new BitSet(new ulong[]{0x2UL,0x2000000UL});
		public static readonly BitSet _logicalANDExpressionNoIn_in_logicalORExpressionNoIn4149 = new BitSet(new ulong[]{0x2UL,0x2000000UL});
		public static readonly BitSet _LOR_in_logicalORExpressionNoIn4153 = new BitSet(new ulong[]{0x4040100A00000020UL,0x416000460A210UL,0x451410008UL});
		public static readonly BitSet _logicalANDExpressionNoIn_in_logicalORExpressionNoIn4156 = new BitSet(new ulong[]{0x2UL,0x2000000UL});
		public static readonly BitSet _logicalORExpression_in_conditionalExpression4175 = new BitSet(new ulong[]{0x2UL,0x1000000000000000UL});
		public static readonly BitSet _QUE_in_conditionalExpression4179 = new BitSet(new ulong[]{0x4040100A00000020UL,0x416000460A210UL,0x451410008UL});
		public static readonly BitSet _assignmentExpression_in_conditionalExpression4182 = new BitSet(new ulong[]{0x4000000UL});
		public static readonly BitSet _COLON_in_conditionalExpression4184 = new BitSet(new ulong[]{0x4040100A00000020UL,0x416000460A210UL,0x451410008UL});
		public static readonly BitSet _assignmentExpression_in_conditionalExpression4187 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _logicalORExpressionNoIn_in_conditionalExpressionNoIn4201 = new BitSet(new ulong[]{0x2UL,0x1000000000000000UL});
		public static readonly BitSet _QUE_in_conditionalExpressionNoIn4205 = new BitSet(new ulong[]{0x4040100A00000020UL,0x416000460A210UL,0x451410008UL});
		public static readonly BitSet _assignmentExpressionNoIn_in_conditionalExpressionNoIn4208 = new BitSet(new ulong[]{0x4000000UL});
		public static readonly BitSet _COLON_in_conditionalExpressionNoIn4210 = new BitSet(new ulong[]{0x4040100A00000020UL,0x416000460A210UL,0x451410008UL});
		public static readonly BitSet _assignmentExpressionNoIn_in_conditionalExpressionNoIn4213 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _conditionalExpression_in_assignmentExpression4241 = new BitSet(new ulong[]{0x2000000942UL,0x800500000000UL,0x20000021480UL});
		public static readonly BitSet _assignmentOperator_in_assignmentExpression4248 = new BitSet(new ulong[]{0x4040100A00000020UL,0x416000460A210UL,0x451410008UL});
		public static readonly BitSet _assignmentExpression_in_assignmentExpression4251 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _conditionalExpressionNoIn_in_assignmentExpressionNoIn4328 = new BitSet(new ulong[]{0x2000000942UL,0x800500000000UL,0x20000021480UL});
		public static readonly BitSet _assignmentOperator_in_assignmentExpressionNoIn4335 = new BitSet(new ulong[]{0x4040100A00000020UL,0x416000460A210UL,0x451410008UL});
		public static readonly BitSet _assignmentExpressionNoIn_in_assignmentExpressionNoIn4338 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _assignmentExpression_in_expression4360 = new BitSet(new ulong[]{0x8000002UL});
		public static readonly BitSet _COMMA_in_expression4364 = new BitSet(new ulong[]{0x4040100A00000020UL,0x416000460A210UL,0x451410008UL});
		public static readonly BitSet _assignmentExpression_in_expression4368 = new BitSet(new ulong[]{0x8000002UL});
		public static readonly BitSet _assignmentExpressionNoIn_in_expressionNoIn4405 = new BitSet(new ulong[]{0x8000002UL});
		public static readonly BitSet _COMMA_in_expressionNoIn4409 = new BitSet(new ulong[]{0x4040100A00000020UL,0x416000460A210UL,0x451410008UL});
		public static readonly BitSet _assignmentExpressionNoIn_in_expressionNoIn4413 = new BitSet(new ulong[]{0x8000002UL});
		public static readonly BitSet _SEMIC_in_semic4464 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _EOF_in_semic4469 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _RBRACE_in_semic4474 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _EOL_in_semic4481 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _MultiLineComment_in_semic4485 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _block_in_statement4514 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _statementTail_in_statement4519 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _variableStatement_in_statementTail4531 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _emptyStatement_in_statementTail4536 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _expressionStatement_in_statementTail4541 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _ifStatement_in_statementTail4546 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _iterationStatement_in_statementTail4551 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _continueStatement_in_statementTail4556 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _breakStatement_in_statementTail4561 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _returnStatement_in_statementTail4566 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _withStatement_in_statementTail4571 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _labelledStatement_in_statementTail4576 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _switchStatement_in_statementTail4581 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _throwStatement_in_statementTail4586 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _tryStatement_in_statementTail4591 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _LBRACE_in_block4606 = new BitSet(new ulong[]{0x4840104A20004020UL,0xA00416000460A230UL,0x6673490028UL});
		public static readonly BitSet _statement_in_block4608 = new BitSet(new ulong[]{0x4840104A20004020UL,0xA00416000460A230UL,0x6673490028UL});
		public static readonly BitSet _RBRACE_in_block4611 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _VAR_in_variableStatement4640 = new BitSet(new ulong[]{0x0UL,0x8000UL});
		public static readonly BitSet _variableDeclaration_in_variableStatement4642 = new BitSet(new ulong[]{0x0UL});
		public static readonly BitSet _COMMA_in_variableStatement4646 = new BitSet(new ulong[]{0x0UL,0x8000UL});
		public static readonly BitSet _variableDeclaration_in_variableStatement4648 = new BitSet(new ulong[]{0x0UL});
		public static readonly BitSet _semic_in_variableStatement4653 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _Identifier_in_variableDeclaration4676 = new BitSet(new ulong[]{0x802UL});
		public static readonly BitSet _ASSIGN_in_variableDeclaration4680 = new BitSet(new ulong[]{0x4040100A00000020UL,0x416000460A210UL,0x451410008UL});
		public static readonly BitSet _assignmentExpression_in_variableDeclaration4683 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _Identifier_in_variableDeclarationNoIn4698 = new BitSet(new ulong[]{0x802UL});
		public static readonly BitSet _ASSIGN_in_variableDeclarationNoIn4702 = new BitSet(new ulong[]{0x4040100A00000020UL,0x416000460A210UL,0x451410008UL});
		public static readonly BitSet _assignmentExpressionNoIn_in_variableDeclarationNoIn4705 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _SEMIC_in_emptyStatement4724 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _expression_in_expressionStatement4743 = new BitSet(new ulong[]{0x0UL});
		public static readonly BitSet _semic_in_expressionStatement4745 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _IF_in_ifStatement4763 = new BitSet(new ulong[]{0x0UL,0x4000000UL});
		public static readonly BitSet _LPAREN_in_ifStatement4765 = new BitSet(new ulong[]{0x4040100A00000020UL,0x416000460A210UL,0x451410008UL});
		public static readonly BitSet _expression_in_ifStatement4767 = new BitSet(new ulong[]{0x0UL,0x0UL,0x1UL});
		public static readonly BitSet _RPAREN_in_ifStatement4769 = new BitSet(new ulong[]{0x4840104A20004020UL,0x800416000460A230UL,0x6673490028UL});
		public static readonly BitSet _statement_in_ifStatement4771 = new BitSet(new ulong[]{0x200000000002UL});
		public static readonly BitSet _ELSE_in_ifStatement4777 = new BitSet(new ulong[]{0x4840104A20004020UL,0x800416000460A230UL,0x6673490028UL});
		public static readonly BitSet _statement_in_ifStatement4779 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _doStatement_in_iterationStatement4812 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _whileStatement_in_iterationStatement4817 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _forStatement_in_iterationStatement4822 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _DO_in_doStatement4834 = new BitSet(new ulong[]{0x4840104A20004020UL,0x800416000460A230UL,0x6673490028UL});
		public static readonly BitSet _statement_in_doStatement4836 = new BitSet(new ulong[]{0x0UL,0x0UL,0x2000000000UL});
		public static readonly BitSet _WHILE_in_doStatement4838 = new BitSet(new ulong[]{0x0UL,0x4000000UL});
		public static readonly BitSet _LPAREN_in_doStatement4840 = new BitSet(new ulong[]{0x4040100A00000020UL,0x416000460A210UL,0x451410008UL});
		public static readonly BitSet _expression_in_doStatement4842 = new BitSet(new ulong[]{0x0UL,0x0UL,0x1UL});
		public static readonly BitSet _RPAREN_in_doStatement4844 = new BitSet(new ulong[]{0x0UL});
		public static readonly BitSet _semic_in_doStatement4846 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _WHILE_in_whileStatement4871 = new BitSet(new ulong[]{0x0UL,0x4000000UL});
		public static readonly BitSet _LPAREN_in_whileStatement4874 = new BitSet(new ulong[]{0x4040100A00000020UL,0x416000460A210UL,0x451410008UL});
		public static readonly BitSet _expression_in_whileStatement4877 = new BitSet(new ulong[]{0x0UL,0x0UL,0x1UL});
		public static readonly BitSet _RPAREN_in_whileStatement4879 = new BitSet(new ulong[]{0x4840104A20004020UL,0x800416000460A230UL,0x6673490028UL});
		public static readonly BitSet _statement_in_whileStatement4882 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _FOR_in_forStatement4895 = new BitSet(new ulong[]{0x0UL,0x4000000UL});
		public static readonly BitSet _LPAREN_in_forStatement4898 = new BitSet(new ulong[]{0x4040100A00000020UL,0x416000460A210UL,0x651410028UL});
		public static readonly BitSet _forControl_in_forStatement4901 = new BitSet(new ulong[]{0x0UL,0x0UL,0x1UL});
		public static readonly BitSet _RPAREN_in_forStatement4903 = new BitSet(new ulong[]{0x4840104A20004020UL,0x800416000460A230UL,0x6673490028UL});
		public static readonly BitSet _statement_in_forStatement4906 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _forControlVar_in_forControl4917 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _forControlExpression_in_forControl4922 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _forControlSemic_in_forControl4927 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _VAR_in_forControlVar4938 = new BitSet(new ulong[]{0x0UL,0x8000UL});
		public static readonly BitSet _variableDeclarationNoIn_in_forControlVar4940 = new BitSet(new ulong[]{0x8000000UL,0x100UL,0x20UL});
		public static readonly BitSet _IN_in_forControlVar4952 = new BitSet(new ulong[]{0x4040100A00000020UL,0x416000460A210UL,0x451410008UL});
		public static readonly BitSet _expression_in_forControlVar4954 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _COMMA_in_forControlVar5000 = new BitSet(new ulong[]{0x0UL,0x8000UL});
		public static readonly BitSet _variableDeclarationNoIn_in_forControlVar5002 = new BitSet(new ulong[]{0x8000000UL,0x0UL,0x20UL});
		public static readonly BitSet _SEMIC_in_forControlVar5007 = new BitSet(new ulong[]{0x4040100A00000020UL,0x416000460A210UL,0x451410028UL});
		public static readonly BitSet _expression_in_forControlVar5011 = new BitSet(new ulong[]{0x0UL,0x0UL,0x20UL});
		public static readonly BitSet _SEMIC_in_forControlVar5014 = new BitSet(new ulong[]{0x4040100A00000022UL,0x416000460A210UL,0x451410008UL});
		public static readonly BitSet _expression_in_forControlVar5018 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _expressionNoIn_in_forControlExpression5084 = new BitSet(new ulong[]{0x0UL,0x100UL,0x20UL});
		public static readonly BitSet _IN_in_forControlExpression5099 = new BitSet(new ulong[]{0x4040100A00000020UL,0x416000460A210UL,0x451410008UL});
		public static readonly BitSet _expression_in_forControlExpression5103 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _SEMIC_in_forControlExpression5149 = new BitSet(new ulong[]{0x4040100A00000020UL,0x416000460A210UL,0x451410028UL});
		public static readonly BitSet _expression_in_forControlExpression5153 = new BitSet(new ulong[]{0x0UL,0x0UL,0x20UL});
		public static readonly BitSet _SEMIC_in_forControlExpression5156 = new BitSet(new ulong[]{0x4040100A00000022UL,0x416000460A210UL,0x451410008UL});
		public static readonly BitSet _expression_in_forControlExpression5160 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _SEMIC_in_forControlSemic5219 = new BitSet(new ulong[]{0x4040100A00000020UL,0x416000460A210UL,0x451410028UL});
		public static readonly BitSet _expression_in_forControlSemic5223 = new BitSet(new ulong[]{0x0UL,0x0UL,0x20UL});
		public static readonly BitSet _SEMIC_in_forControlSemic5226 = new BitSet(new ulong[]{0x4040100A00000022UL,0x416000460A210UL,0x451410008UL});
		public static readonly BitSet _expression_in_forControlSemic5230 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _CONTINUE_in_continueStatement5284 = new BitSet(new ulong[]{0x0UL});
		public static readonly BitSet _Identifier_in_continueStatement5289 = new BitSet(new ulong[]{0x0UL});
		public static readonly BitSet _semic_in_continueStatement5292 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _BREAK_in_breakStatement5311 = new BitSet(new ulong[]{0x0UL});
		public static readonly BitSet _Identifier_in_breakStatement5316 = new BitSet(new ulong[]{0x0UL});
		public static readonly BitSet _semic_in_breakStatement5319 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _RETURN_in_returnStatement5338 = new BitSet(new ulong[]{0x0UL});
		public static readonly BitSet _expression_in_returnStatement5343 = new BitSet(new ulong[]{0x0UL});
		public static readonly BitSet _semic_in_returnStatement5346 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _WITH_in_withStatement5363 = new BitSet(new ulong[]{0x0UL,0x4000000UL});
		public static readonly BitSet _LPAREN_in_withStatement5366 = new BitSet(new ulong[]{0x4040100A00000020UL,0x416000460A210UL,0x451410008UL});
		public static readonly BitSet _expression_in_withStatement5369 = new BitSet(new ulong[]{0x0UL,0x0UL,0x1UL});
		public static readonly BitSet _RPAREN_in_withStatement5371 = new BitSet(new ulong[]{0x4840104A20004020UL,0x800416000460A230UL,0x6673490028UL});
		public static readonly BitSet _statement_in_withStatement5374 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _SWITCH_in_switchStatement5395 = new BitSet(new ulong[]{0x0UL,0x4000000UL});
		public static readonly BitSet _LPAREN_in_switchStatement5397 = new BitSet(new ulong[]{0x4040100A00000020UL,0x416000460A210UL,0x451410008UL});
		public static readonly BitSet _expression_in_switchStatement5399 = new BitSet(new ulong[]{0x0UL,0x0UL,0x1UL});
		public static readonly BitSet _RPAREN_in_switchStatement5401 = new BitSet(new ulong[]{0x0UL,0x200000UL});
		public static readonly BitSet _LBRACE_in_switchStatement5403 = new BitSet(new ulong[]{0x400200000UL,0x2000000000000000UL});
		public static readonly BitSet _defaultClause_in_switchStatement5410 = new BitSet(new ulong[]{0x400200000UL,0x2000000000000000UL});
		public static readonly BitSet _caseClause_in_switchStatement5416 = new BitSet(new ulong[]{0x400200000UL,0x2000000000000000UL});
		public static readonly BitSet _RBRACE_in_switchStatement5421 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _CASE_in_caseClause5449 = new BitSet(new ulong[]{0x4040100A00000020UL,0x416000460A210UL,0x451410008UL});
		public static readonly BitSet _expression_in_caseClause5452 = new BitSet(new ulong[]{0x4000000UL});
		public static readonly BitSet _COLON_in_caseClause5454 = new BitSet(new ulong[]{0x4840104A20004022UL,0x800416000460A230UL,0x6673490028UL});
		public static readonly BitSet _statement_in_caseClause5457 = new BitSet(new ulong[]{0x4840104A20004022UL,0x800416000460A230UL,0x6673490028UL});
		public static readonly BitSet _DEFAULT_in_defaultClause5470 = new BitSet(new ulong[]{0x4000000UL});
		public static readonly BitSet _COLON_in_defaultClause5473 = new BitSet(new ulong[]{0x4840104A20004022UL,0x800416000460A230UL,0x6673490028UL});
		public static readonly BitSet _statement_in_defaultClause5476 = new BitSet(new ulong[]{0x4840104A20004022UL,0x800416000460A230UL,0x6673490028UL});
		public static readonly BitSet _Identifier_in_labelledStatement5493 = new BitSet(new ulong[]{0x4000000UL});
		public static readonly BitSet _COLON_in_labelledStatement5495 = new BitSet(new ulong[]{0x4840104A20004020UL,0x800416000460A230UL,0x6673490028UL});
		public static readonly BitSet _statement_in_labelledStatement5497 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _THROW_in_throwStatement5528 = new BitSet(new ulong[]{0x4040100A00000020UL,0x416000460A210UL,0x451410008UL});
		public static readonly BitSet _expression_in_throwStatement5533 = new BitSet(new ulong[]{0x0UL});
		public static readonly BitSet _semic_in_throwStatement5535 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _TRY_in_tryStatement5552 = new BitSet(new ulong[]{0x0UL,0x200000UL});
		public static readonly BitSet _block_in_tryStatement5555 = new BitSet(new ulong[]{0x200000000400000UL});
		public static readonly BitSet _catchClause_in_tryStatement5559 = new BitSet(new ulong[]{0x200000000000002UL});
		public static readonly BitSet _finallyClause_in_tryStatement5561 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _finallyClause_in_tryStatement5566 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _CATCH_in_catchClause5580 = new BitSet(new ulong[]{0x0UL,0x4000000UL});
		public static readonly BitSet _LPAREN_in_catchClause5583 = new BitSet(new ulong[]{0x0UL,0x8000UL});
		public static readonly BitSet _Identifier_in_catchClause5586 = new BitSet(new ulong[]{0x0UL,0x0UL,0x1UL});
		public static readonly BitSet _RPAREN_in_catchClause5588 = new BitSet(new ulong[]{0x0UL,0x200000UL});
		public static readonly BitSet _block_in_catchClause5591 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _FINALLY_in_finallyClause5603 = new BitSet(new ulong[]{0x0UL,0x200000UL});
		public static readonly BitSet _block_in_finallyClause5606 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _FUNCTION_in_functionDeclaration5627 = new BitSet(new ulong[]{0x0UL,0x8000UL});
		public static readonly BitSet _Identifier_in_functionDeclaration5631 = new BitSet(new ulong[]{0x0UL,0x4000000UL});
		public static readonly BitSet _formalParameterList_in_functionDeclaration5633 = new BitSet(new ulong[]{0x0UL,0x200000UL});
		public static readonly BitSet _functionBody_in_functionDeclaration5635 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _FUNCTION_in_functionExpression5662 = new BitSet(new ulong[]{0x0UL,0x4008000UL});
		public static readonly BitSet _Identifier_in_functionExpression5666 = new BitSet(new ulong[]{0x0UL,0x4000000UL});
		public static readonly BitSet _formalParameterList_in_functionExpression5669 = new BitSet(new ulong[]{0x0UL,0x200000UL});
		public static readonly BitSet _functionBody_in_functionExpression5671 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _LPAREN_in_formalParameterList5699 = new BitSet(new ulong[]{0x0UL,0x8000UL,0x1UL});
		public static readonly BitSet _Identifier_in_formalParameterList5703 = new BitSet(new ulong[]{0x8000000UL,0x0UL,0x1UL});
		public static readonly BitSet _COMMA_in_formalParameterList5707 = new BitSet(new ulong[]{0x0UL,0x8000UL});
		public static readonly BitSet _Identifier_in_formalParameterList5709 = new BitSet(new ulong[]{0x8000000UL,0x0UL,0x1UL});
		public static readonly BitSet _RPAREN_in_formalParameterList5717 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _LBRACE_in_functionBody5742 = new BitSet(new ulong[]{0x4840104A20004020UL,0xA00416000460A230UL,0x6673490028UL});
		public static readonly BitSet _sourceElement_in_functionBody5744 = new BitSet(new ulong[]{0x4840104A20004020UL,0xA00416000460A230UL,0x6673490028UL});
		public static readonly BitSet _RBRACE_in_functionBody5747 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _sourceElement_in_program5778 = new BitSet(new ulong[]{0x4840104A20004022UL,0x800416000460A230UL,0x6673490028UL});
		public static readonly BitSet _functionDeclaration_in_sourceElement5807 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _statement_in_sourceElement5812 = new BitSet(new ulong[]{0x2UL});
	}
	#endregion Follow sets
}

} // namespace  JsParser.Net 
